func_before,lines_before
"    DidFinishNavigation(NavigationHandle* handle) {
  if (handle->GetFrameTreeNodeId() != frame_tree_node_id_)
    return;
  if (!handle->HasCommitted())
    return;
  if (handle->GetRenderFrameHost()->GetSiteInstance() != parent_site_instance_)
    return;
  if (!handle->GetURL().IsAboutBlank())
    return;
  if (!handle->GetRenderFrameHost()->PrepareForInnerWebContentsAttach()) {
    filter_->ResumeAttachOrDestroy(element_instance_id_,
                                   MSG_ROUTING_NONE /* no plugin frame */);
  }
  base::PostTaskWithTraits(
      FROM_HERE, {BrowserThread::UI},
      base::BindOnce(&ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy,
                     filter_, element_instance_id_,
                     handle->GetRenderFrameHost()->GetRoutingID()));
}
","  if (handle->GetFrameTreeNodeId() != frame_tree_node_id_)
    return;
  if (!handle->HasCommitted())
    return;
  if (handle->GetRenderFrameHost()->GetSiteInstance() != parent_site_instance_)
    return;
  if (!handle->GetURL().IsAboutBlank())
    return;
  if (!handle->GetRenderFrameHost()->PrepareForInnerWebContentsAttach()) {
    filter_->ResumeAttachOrDestroy(element_instance_id_,
                                   MSG_ROUTING_NONE /* no plugin frame */);
  }
  base::PostTaskWithTraits(
      FROM_HERE, {BrowserThread::UI},
      base::BindOnce(&ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy,
                     filter_, element_instance_id_,
                     handle->GetRenderFrameHost()->GetRoutingID()));
}
"
" ExtensionsGuestViewMessageFilter::ExtensionsGuestViewMessageFilter(
     int render_process_id,
    BrowserContext* context)
    : GuestViewMessageFilter(kFilteredMessageClasses,
                             base::size(kFilteredMessageClasses),
                              render_process_id,
                              context),
       content::BrowserAssociatedInterface<mojom::GuestView>(this, this) {
  GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);
 }
","  GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);
"
"void ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameDeleted(
    RenderFrameHost* render_frame_host) {
  if (render_frame_host->GetFrameTreeNodeId() != frame_tree_node_id_)
    return;
  filter_->ResumeAttachOrDestroy(element_instance_id_,
                                 MSG_ROUTING_NONE /* no plugin frame */);
}
","    RenderFrameHost* render_frame_host) {
  if (render_frame_host->GetFrameTreeNodeId() != frame_tree_node_id_)
    return;
  filter_->ResumeAttachOrDestroy(element_instance_id_,
                                 MSG_ROUTING_NONE /* no plugin frame */);
}
"
"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(
    RenderFrameHost* plugin_rfh,
    int32_t guest_instance_id,
    int32_t element_instance_id,
    bool is_full_page_plugin,
    ExtensionsGuestViewMessageFilter* filter)
    : content::WebContentsObserver(
          content::WebContents::FromRenderFrameHost(plugin_rfh)),
      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),
      guest_instance_id_(guest_instance_id),
      element_instance_id_(element_instance_id),
      is_full_page_plugin_(is_full_page_plugin),
      filter_(filter),
      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),
      weak_factory_(this) {
  DCHECK(GetGuestView());
  NavigateToAboutBlank();
  base::PostDelayedTaskWithTraits(
      FROM_HERE, {BrowserThread::UI},
      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::
                         CancelPendingTask,
                     weak_factory_.GetWeakPtr()),
      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));
}
","    RenderFrameHost* plugin_rfh,
    int32_t guest_instance_id,
    int32_t element_instance_id,
    bool is_full_page_plugin,
    ExtensionsGuestViewMessageFilter* filter)
    : content::WebContentsObserver(
          content::WebContents::FromRenderFrameHost(plugin_rfh)),
      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),
      guest_instance_id_(guest_instance_id),
      element_instance_id_(element_instance_id),
      is_full_page_plugin_(is_full_page_plugin),
      filter_(filter),
      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),
      weak_factory_(this) {
  DCHECK(GetGuestView());
  NavigateToAboutBlank();
  base::PostDelayedTaskWithTraits(
      FROM_HERE, {BrowserThread::UI},
      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::
                         CancelPendingTask,
                     weak_factory_.GetWeakPtr()),
      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));
}
"
"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::GetGuestView() const {
  return MimeHandlerViewGuest::From(
             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)
      ->As<MimeHandlerViewGuest>();
}
","  return MimeHandlerViewGuest::From(
             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)
      ->As<MimeHandlerViewGuest>();
}
"
"ProcessIdToFilterMap* GetProcessIdToFilterMap() {
  static base::NoDestructor<ProcessIdToFilterMap> instance;
  return instance.get();
}
","  static base::NoDestructor<ProcessIdToFilterMap> instance;
  return instance.get();
}
"
"ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(
    NavigationHandle* handle) {
  DCHECK(content::MimeHandlerViewMode::UsesCrossProcessFrame());
  if (!handle->GetParentFrame()) {
    return nullptr;
  }
  int32_t parent_process_id = handle->GetParentFrame()->GetProcess()->GetID();
  auto& map = *GetProcessIdToFilterMap();
  if (!base::ContainsKey(map, parent_process_id) || !map[parent_process_id]) {
    return nullptr;
  }
  for (auto& pair : map[parent_process_id]->frame_navigation_helpers_) {
    if (!pair.second->ShouldCancelAndIgnore(handle))
      continue;
    return std::make_unique<CancelAndIgnoreNavigationForPluginFrameThrottle>(
        handle);
  }
  return nullptr;
}
","    NavigationHandle* handle) {
  DCHECK(content::MimeHandlerViewMode::UsesCrossProcessFrame());
  if (!handle->GetParentFrame()) {
    return nullptr;
  }
  int32_t parent_process_id = handle->GetParentFrame()->GetProcess()->GetID();
  auto& map = *GetProcessIdToFilterMap();
  if (!base::ContainsKey(map, parent_process_id) || !map[parent_process_id]) {
    return nullptr;
  }
  for (auto& pair : map[parent_process_id]->frame_navigation_helpers_) {
    if (!pair.second->ShouldCancelAndIgnore(handle))
      continue;
    return std::make_unique<CancelAndIgnoreNavigationForPluginFrameThrottle>(
        handle);
  }
  return nullptr;
}
"
"    NavigateToAboutBlank() {
  GURL about_blank(url::kAboutBlankURL);
  content::NavigationController::LoadURLParams params(about_blank);
  params.frame_tree_node_id = frame_tree_node_id_;
  params.source_site_instance = parent_site_instance_;
  params.is_renderer_initiated = true;
  web_contents()->GetController().LoadURLWithParams(params);
}
","  GURL about_blank(url::kAboutBlankURL);
  content::NavigationController::LoadURLParams params(about_blank);
  params.frame_tree_node_id = frame_tree_node_id_;
  params.source_site_instance = parent_site_instance_;
  params.is_renderer_initiated = true;
  web_contents()->GetController().LoadURLWithParams(params);
}
"
"void RemoveProcessIdFromGlobalMap(int32_t process_id) {
  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  GetProcessIdToFilterMap()->erase(process_id);
}
","  DCHECK_CURRENTLY_ON(BrowserThread::UI);
  GetProcessIdToFilterMap()->erase(process_id);
}
"
"void ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy(
    int32_t element_instance_id,
    int32_t plugin_frame_routing_id) {
  auto it = frame_navigation_helpers_.find(element_instance_id);
  if (it == frame_navigation_helpers_.end()) {
    return;
  }
  auto* plugin_rfh = content::RenderFrameHost::FromID(render_process_id_,
                                                      plugin_frame_routing_id);
  auto* helper = it->second.get();
  auto* guest_view = helper->GetGuestView();
  if (!guest_view)
    return;
 
  if (plugin_rfh) {
    DCHECK(
        guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh));
    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,
                                              helper->is_full_page_plugin());
  } else {
    guest_view->GetEmbedderFrame()->Send(
        new ExtensionsGuestViewMsg_DestroyFrameContainer(element_instance_id));
    guest_view->Destroy(true);
  }
  frame_navigation_helpers_.erase(element_instance_id);
 }
","    int32_t element_instance_id,
    int32_t plugin_frame_routing_id) {
  auto it = frame_navigation_helpers_.find(element_instance_id);
  if (it == frame_navigation_helpers_.end()) {
    return;
  }
  auto* plugin_rfh = content::RenderFrameHost::FromID(render_process_id_,
                                                      plugin_frame_routing_id);
  auto* helper = it->second.get();
  auto* guest_view = helper->GetGuestView();
  if (!guest_view)
    return;
  if (plugin_rfh) {
    DCHECK(
        guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh));
    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,
                                              helper->is_full_page_plugin());
  } else {
    guest_view->GetEmbedderFrame()->Send(
        new ExtensionsGuestViewMsg_DestroyFrameContainer(element_instance_id));
    guest_view->Destroy(true);
  }
  frame_navigation_helpers_.erase(element_instance_id);
"
"    ShouldCancelAndIgnore(NavigationHandle* handle) {
  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;
}
","  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;
}
"
"  SiteInstance* parent_site_instance() const {
    return parent_site_instance_.get();
  }
","    return parent_site_instance_.get();
  }
"
" ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;
  base::PostTaskWithTraits(
      FROM_HERE, BrowserThread::UI,
      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));
 }
","  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;
  base::PostTaskWithTraits(
      FROM_HERE, BrowserThread::UI,
      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));
"
"void DOMStorageContextWrapper::OpenSessionStorage(
    int process_id,
    const std::string& namespace_id,
    mojo::ReportBadMessageCallback bad_message_callback,
     blink::mojom::SessionStorageNamespaceRequest request) {
   if (!mojo_session_state_)
     return;
  mojo_task_runner_->PostTask(
       FROM_HERE,
       base::BindOnce(&SessionStorageContextMojo::OpenSessionStorage,
                      base::Unretained(mojo_session_state_), process_id,
                     namespace_id, std::move(bad_message_callback),
                      std::move(request)));
 }
","                     namespace_id, std::move(bad_message_callback),
"
" void DOMStorageContextWrapper::Shutdown() {
  DCHECK(context_.get());
  mojo_task_runner_->PostTask(
      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,
                                base::Unretained(mojo_state_)));
  mojo_state_ = nullptr;
   if (mojo_session_state_) {
     mojo_task_runner_->PostTask(
         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,
                                   base::Unretained(mojo_session_state_)));
     mojo_session_state_ = nullptr;
   }
   memory_pressure_listener_.reset();
  context_->task_runner()->PostShutdownBlockingTask(
      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,
      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));
 }
","  DCHECK(context_.get());
  mojo_task_runner_->PostTask(
      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,
                                base::Unretained(mojo_state_)));
  mojo_state_ = nullptr;
  context_->task_runner()->PostShutdownBlockingTask(
      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,
      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));
"
"void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
    const ContentSecurityPolicy* policy_to_inherit,
    const ContentSecurityPolicy* previous_document_csp) {
   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());
 
   GetContentSecurityPolicy()->BindToExecutionContext(this);
 
  if (policy_to_inherit) {
     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else {
    if (frame_) {
       Frame* inherit_from = frame_->Tree().Parent()
                                 ? frame_->Tree().Parent()
                                 : frame_->Client()->Opener();
       if (inherit_from && frame_ != inherit_from) {
         DCHECK(inherit_from->GetSecurityContext() &&
                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
        policy_to_inherit =
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
       }
     }
    if (!policy_to_inherit)
      policy_to_inherit = previous_document_csp;
    if (policy_to_inherit &&
        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
         url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")))
      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
 }
","    ContentSecurityPolicy* csp,
    const ContentSecurityPolicy* policy_to_inherit,
    const ContentSecurityPolicy* previous_document_csp) {
  if (policy_to_inherit) {
  } else {
    if (frame_) {
        policy_to_inherit =
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
    if (!policy_to_inherit)
      policy_to_inherit = previous_document_csp;
    if (policy_to_inherit &&
        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
         url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")))
      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
"
"DocumentInit& DocumentInit::WithPreviousDocumentCSP(
    const ContentSecurityPolicy* previous_csp) {
  DCHECK(!previous_csp_);
  previous_csp_ = previous_csp;
  return *this;
}
","    const ContentSecurityPolicy* previous_csp) {
  DCHECK(!previous_csp_);
  previous_csp_ = previous_csp;
  return *this;
}
"
"bool ContentSecurityPolicy::AllowPluginTypeForDocument(
    const Document& document,
    const String& type,
    const String& type_attribute,
    const KURL& url,
    SecurityViolationReportingPolicy reporting_policy) const {
  if (document.GetContentSecurityPolicy() &&
      !document.GetContentSecurityPolicy()->AllowPluginType(
           type, type_attribute, url, reporting_policy))
     return false;
 
  LocalFrame* frame = document.GetFrame();
  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {
    ContentSecurityPolicy* parent_csp = frame->Tree()
                                            .Parent()
                                            ->GetSecurityContext()
                                            ->GetContentSecurityPolicy();
    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,
                                                   reporting_policy))
      return false;
  }
   return true;
 }
","  LocalFrame* frame = document.GetFrame();
  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {
    ContentSecurityPolicy* parent_csp = frame->Tree()
                                            .Parent()
                                            ->GetSecurityContext()
                                            ->GetContentSecurityPolicy();
    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,
                                                   reporting_policy))
      return false;
  }
"
"void DocumentLoader::DidInstallNewDocument(
    Document* document,
    const ContentSecurityPolicy* previous_csp) {
   document->SetReadyState(Document::kLoading);
   if (content_security_policy_) {
    document->InitContentSecurityPolicy(content_security_policy_.Release(),
                                        nullptr, previous_csp);
   }
 
   if (history_item_ && IsBackForwardLoadType(load_type_))
    document->SetStateForNewFormElements(history_item_->GetDocumentState());

  DCHECK(document->GetFrame());
  document->GetFrame()->GetClientHintsPreferences().UpdateFrom(
      client_hints_preferences_);

  Settings* settings = document->GetSettings();
  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());
  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());

  const AtomicString& dns_prefetch_control =
      response_.HttpHeaderField(http_names::kXDNSPrefetchControl);
  if (!dns_prefetch_control.IsEmpty())
    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);

  String header_content_language =
      response_.HttpHeaderField(http_names::kContentLanguage);
  if (!header_content_language.IsEmpty()) {
    wtf_size_t comma_index = header_content_language.find(',');
    header_content_language.Truncate(comma_index);
    header_content_language =
        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);
    if (!header_content_language.IsEmpty())
      document->SetContentLanguage(AtomicString(header_content_language));
  }

  String referrer_policy_header =
      response_.HttpHeaderField(http_names::kReferrerPolicy);
  if (!referrer_policy_header.IsNull()) {
    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);
    document->ParseAndSetReferrerPolicy(referrer_policy_header);
  }

  if (response_.IsSignedExchangeInnerResponse())
    UseCounter::Count(*document, WebFeature::kSignedExchangeInnerResponse);

  GetLocalFrameClient().DidCreateNewDocument();
}
","    Document* document,
    const ContentSecurityPolicy* previous_csp) {
    document->InitContentSecurityPolicy(content_security_policy_.Release(),
                                        nullptr, previous_csp);
"
" std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,
                                            const std::wstring& switch_name) {
   assert(!command_line.empty());
   assert(!switch_name.empty());
 
   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);
   std::wstring switch_with_equal = L""--"" + switch_name + L""="";
  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)
       return arg.substr(switch_with_equal.size());
   }

  return std::wstring();
}
","  for (size_t i = 1; i < as_array.size(); ++i) {
    const std::wstring& arg = as_array[i];
"
"DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {
  DCHECK_EQ(read_type_, kReadAsArrayBuffer);
  if (array_buffer_result_)
    return array_buffer_result_;

   if (!raw_data_ || error_code_ != FileErrorCode::kOK)
     return nullptr;
 
  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
   }
  return result;
 }
","  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());
  if (finished_loading_) {
    array_buffer_result_ = result;
    AdjustReportedMemoryUsageToV8(
        -1 * static_cast<int64_t>(raw_data_->ByteLength()));
    raw_data_.reset();
  return result;
"
" bool SVGElement::HasSVGParent() const {
  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
 }
","  return ParentOrShadowHostElement() &&
         ParentOrShadowHostElement()->IsSVGElement();
"
" ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(
     ImageBitmapFactories& factory,
     base::Optional<IntRect> crop_rect,
     ScriptState* script_state,
     const ImageBitmapOptions* options)
    : loader_(
           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),
       factory_(&factory),
       resolver_(ScriptPromiseResolver::Create(script_state)),
       crop_rect_(crop_rect),
       options_(options) {}
","    : loader_(
"
"void ImageBitmapFactories::ImageBitmapLoader::LoadBlobAsync(
    Blob* blob) {
   loader_->Start(blob->GetBlobDataHandle());
 }
","    Blob* blob) {
"
"void ImageBitmapFactories::Trace(blink::Visitor* visitor) {
  visitor->Trace(pending_loaders_);
  Supplement<LocalDOMWindow>::Trace(visitor);
  Supplement<WorkerGlobalScope>::Trace(visitor);
 }
","  visitor->Trace(pending_loaders_);
  Supplement<LocalDOMWindow>::Trace(visitor);
  Supplement<WorkerGlobalScope>::Trace(visitor);
"
"void RenderFrameImpl::OnSelectPopupMenuItem(int selected_index) {
  if (external_popup_menu_ == NULL)
     return;
 
   blink::WebScopedUserGesture gesture(frame_);
  external_popup_menu_->DidSelectItem(selected_index);
  external_popup_menu_.reset();
 }
","  external_popup_menu_->DidSelectItem(selected_index);
  external_popup_menu_.reset();
"
" void RenderFrameImpl::OnSelectPopupMenuItems(
    bool canceled,
    const std::vector<int>& selected_indices) {
  if (!external_popup_menu_)
     return;
 
   blink::WebScopedUserGesture gesture(frame_);
  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
 }
","  external_popup_menu_->DidSelectItems(canceled, selected_indices);
  external_popup_menu_.reset();
"
"   void ProcessStateChangesPlanB(WebRtcSetDescriptionObserver::States states) {
     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kPlanB);
     std::vector<RTCRtpReceiver*> removed_receivers;
    for (auto it = handler_->rtp_receivers_.begin();
         it != handler_->rtp_receivers_.end(); ++it) {
      if (ReceiverWasRemoved(*(*it), states.transceiver_states))
        removed_receivers.push_back(it->get());
    }
 
     for (auto& transceiver_state : states.transceiver_states) {
      if (ReceiverWasAdded(transceiver_state)) {
         handler_->OnAddReceiverPlanB(transceiver_state.MoveReceiverState());
       }
     }
     for (auto* removed_receiver : removed_receivers) {
      handler_->OnRemoveReceiverPlanB(RTCRtpReceiver::getId(
          removed_receiver->state().webrtc_receiver().get()));
     }
   }
","      if (ReceiverWasAdded(transceiver_state)) {
      handler_->OnRemoveReceiverPlanB(RTCRtpReceiver::getId(
          removed_receiver->state().webrtc_receiver().get()));
"
"   void ProcessStateChangesUnifiedPlan(
       WebRtcSetDescriptionObserver::States states) {
     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kUnifiedPlan);
    handler_->OnModifyTransceivers(
        std::move(states.transceiver_states),
        action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);
   }
","    handler_->OnModifyTransceivers(
        std::move(states.transceiver_states),
        action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);
"
"void PaymentRequest::AreRequestedMethodsSupportedCallback(
    bool methods_supported) {
  if (methods_supported) {
    if (SatisfiesSkipUIConstraints()) {
      skipped_payment_request_ui_ = true;
      Pay();
    }
  } else {
    journey_logger_.SetNotShown(
        JourneyLogger::NOT_SHOWN_REASON_NO_SUPPORTED_PAYMENT_METHOD);
    client_->OnError(mojom::PaymentErrorReason::NOT_SUPPORTED);
    if (observer_for_testing_)
      observer_for_testing_->OnNotSupportedError();
     OnConnectionTerminated();
   }
}
","    bool methods_supported) {
  if (methods_supported) {
    if (SatisfiesSkipUIConstraints()) {
      skipped_payment_request_ui_ = true;
      Pay();
    }
  } else {
    journey_logger_.SetNotShown(
        JourneyLogger::NOT_SHOWN_REASON_NO_SUPPORTED_PAYMENT_METHOD);
    client_->OnError(mojom::PaymentErrorReason::NOT_SUPPORTED);
    if (observer_for_testing_)
      observer_for_testing_->OnNotSupportedError();
}
"
" void PaymentRequest::Complete(mojom::PaymentComplete result) {
  if (!client_.is_bound())
     return;
 
  if (result == mojom::PaymentComplete::FAIL) {
    delegate_->ShowErrorMessage();
  } else {
    DCHECK(!has_recorded_completion_);
    journey_logger_.SetCompleted();
    has_recorded_completion_ = true;

    delegate_->GetPrefService()->SetBoolean(kPaymentsFirstTransactionCompleted,
                                            true);
    client_->OnComplete();
    state_->RecordUseStats();
  }
 }
","  if (!client_.is_bound())
"
" void PaymentRequest::Retry(mojom::PaymentValidationErrorsPtr errors) {
  if (!client_.is_bound() || !binding_.is_bound()) {
    DLOG(ERROR) << ""Attempted Retry(), but binding(s) missing."";
     OnConnectionTerminated();
     return;
   }
 
  if (!display_handle_) {
    DLOG(ERROR) << ""Attempted Retry(), but display_handle_ is nullptr."";
     OnConnectionTerminated();
     return;
   }
 
   std::string error;
   if (!PaymentsValidators::IsValidPaymentValidationErrorsFormat(errors,
                                                                 &error)) {
    DLOG(ERROR) << error;
     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);
     OnConnectionTerminated();
     return;
  }

  spec()->Retry(std::move(errors));
   display_handle_->Retry();
 }
","  if (!client_.is_bound() || !binding_.is_bound()) {
    DLOG(ERROR) << ""Attempted Retry(), but binding(s) missing."";
  if (!display_handle_) {
    DLOG(ERROR) << ""Attempted Retry(), but display_handle_ is nullptr."";
    DLOG(ERROR) << error;
"
"bool PaymentRequest::SatisfiesSkipUIConstraints() const {
  return base::FeatureList::IsEnabled(features::kWebPaymentsSingleAppUiSkip) &&
         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&
         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&
         state()->available_instruments().size() == 1 &&
         spec()->stringified_method_data().size() == 1 &&
         !spec()->request_shipping() && !spec()->request_payer_name() &&
         !spec()->request_payer_phone() &&
         !spec()->request_payer_email()
         && spec()->url_payment_method_identifiers().size() == 1;
}
","  return base::FeatureList::IsEnabled(features::kWebPaymentsSingleAppUiSkip) &&
         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&
         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&
         state()->available_instruments().size() == 1 &&
         spec()->stringified_method_data().size() == 1 &&
         !spec()->request_shipping() && !spec()->request_payer_name() &&
         !spec()->request_payer_phone() &&
         !spec()->request_payer_email()
         && spec()->url_payment_method_identifiers().size() == 1;
}
"
" void PaymentRequest::Show(bool is_user_gesture) {
  if (!client_.is_bound() || !binding_.is_bound()) {
    LOG(ERROR) << ""Attempted Show(), but binding(s) missing."";
     OnConnectionTerminated();
     return;
   }
 
   display_handle_ = display_manager_->TryShow(delegate_.get());
   if (!display_handle_) {
    LOG(ERROR) << ""A PaymentRequest UI is already showing"";
     journey_logger_.SetNotShown(
         JourneyLogger::NOT_SHOWN_REASON_CONCURRENT_REQUESTS);
     client_->OnError(mojom::PaymentErrorReason::ALREADY_SHOWING);
    OnConnectionTerminated();
    return;
   }
 
   if (!delegate_->IsBrowserWindowActive()) {
    LOG(ERROR) << ""Cannot show PaymentRequest UI in a background tab"";
     journey_logger_.SetNotShown(JourneyLogger::NOT_SHOWN_REASON_OTHER);
     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);
     OnConnectionTerminated();
     return;
   }
 
   if (!state_) {
     AreRequestedMethodsSupportedCallback(false);
     return;
   }

  is_show_user_gesture_ = is_user_gesture;

  display_handle_->Show(this);

  state_->AreRequestedMethodsSupported(
      base::BindOnce(&PaymentRequest::AreRequestedMethodsSupportedCallback,
                     weak_ptr_factory_.GetWeakPtr()));
 }
","  if (!client_.is_bound() || !binding_.is_bound()) {
    LOG(ERROR) << ""Attempted Show(), but binding(s) missing."";
    LOG(ERROR) << ""A PaymentRequest UI is already showing"";
    LOG(ERROR) << ""Cannot show PaymentRequest UI in a background tab"";
"
"void PaymentRequest::UpdateWith(mojom::PaymentDetailsPtr details) {
   std::string error;
   if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {
    LOG(ERROR) << error;
     OnConnectionTerminated();
     return;
   }
 
   if (details->shipping_address_errors &&
       !PaymentsValidators::IsValidAddressErrorsFormat(
           details->shipping_address_errors, &error)) {
    DLOG(ERROR) << error;
     OnConnectionTerminated();
     return;
   }
 
   if (!details->total) {
    LOG(ERROR) << ""Missing total"";
     OnConnectionTerminated();
     return;
   }

  spec_->UpdateWith(std::move(details));
 }
","    LOG(ERROR) << error;
    DLOG(ERROR) << error;
    LOG(ERROR) << ""Missing total"";
"
"void RenderFrameHostImpl::CreateMediaStreamDispatcherHost(
    MediaStreamManager* media_stream_manager,
    mojom::MediaStreamDispatcherHostRequest request) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  if (!media_stream_dispatcher_host_) {
    media_stream_dispatcher_host_.reset(new MediaStreamDispatcherHost(
        GetProcess()->GetID(), GetRoutingID(), media_stream_manager));
  }
  media_stream_dispatcher_host_->BindRequest(std::move(request));
}
","    MediaStreamManager* media_stream_manager,
    mojom::MediaStreamDispatcherHostRequest request) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  if (!media_stream_dispatcher_host_) {
    media_stream_dispatcher_host_.reset(new MediaStreamDispatcherHost(
        GetProcess()->GetID(), GetRoutingID(), media_stream_manager));
  }
  media_stream_dispatcher_host_->BindRequest(std::move(request));
}
"
"void MediaStreamDispatcherHost::BindRequest(
     mojom::MediaStreamDispatcherHostRequest request) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
  bindings_.AddBinding(this, std::move(request));
 }
","  bindings_.AddBinding(this, std::move(request));
"
" void MediaStreamDispatcherHost::CancelAllRequests() {
  if (!bindings_.empty())
    return;
  media_stream_manager_->CancelAllRequests(render_process_id_,
                                           render_frame_id_);
 }
","  if (!bindings_.empty())
    return;
  media_stream_manager_->CancelAllRequests(render_process_id_,
                                           render_frame_id_);
"
"void MediaStreamDispatcherHost::CancelRequest(int page_request_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   media_stream_manager_->CancelRequest(render_process_id_, render_frame_id_,
                                       page_request_id);
 }
","                                       page_request_id);
"
"void MediaStreamDispatcherHost::DoGenerateStream(
    int32_t page_request_id,
    const StreamControls& controls,
    bool user_gesture,
    GenerateStreamCallback callback,
    MediaDeviceSaltAndOrigin salt_and_origin) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,
                                           salt_and_origin.origin)) {
    std::move(callback).Run(MEDIA_DEVICE_INVALID_SECURITY_ORIGIN, std::string(),
                            MediaStreamDevices(), MediaStreamDevices());
    return;
   }
 
   media_stream_manager_->GenerateStream(
      render_process_id_, render_frame_id_, page_request_id, controls,
      std::move(salt_and_origin), user_gesture, std::move(callback),
       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,
                           weak_factory_.GetWeakPtr()),
       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceChanged,
                          weak_factory_.GetWeakPtr()));
}
","      render_process_id_, render_frame_id_, page_request_id, controls,
      std::move(salt_and_origin), user_gesture, std::move(callback),
"
"void MediaStreamDispatcherHost::DoOpenDevice(
    int32_t page_request_id,
    const std::string& device_id,
    MediaStreamType type,
    OpenDeviceCallback callback,
    MediaDeviceSaltAndOrigin salt_and_origin) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,
                                           salt_and_origin.origin)) {
    std::move(callback).Run(false /* success */, std::string(),
                            MediaStreamDevice());
    return;
   }
 
   media_stream_manager_->OpenDevice(
      render_process_id_, render_frame_id_, page_request_id, device_id, type,
      std::move(salt_and_origin), std::move(callback),
       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,
                           weak_factory_.GetWeakPtr()));
 }
","      render_process_id_, render_frame_id_, page_request_id, device_id, type,
      std::move(salt_and_origin), std::move(callback),
"
" MediaStreamDispatcherHost::MediaStreamDispatcherHost(
     int render_process_id,
     int render_frame_id,
     MediaStreamManager* media_stream_manager)
     : render_process_id_(render_process_id),
       render_frame_id_(render_frame_id),
       media_stream_manager_(media_stream_manager),
       salt_and_origin_callback_(
           base::BindRepeating(&GetMediaDeviceSaltAndOrigin)),
       weak_factory_(this) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
  bindings_.set_connection_error_handler(
      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,
                 weak_factory_.GetWeakPtr()));
 }
","  bindings_.set_connection_error_handler(
      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,
                 weak_factory_.GetWeakPtr()));
"
" void MediaStreamDispatcherHost::StopStreamDevice(const std::string& device_id,
                                                  int32_t session_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   media_stream_manager_->StopStreamDevice(render_process_id_, render_frame_id_,
                                          device_id, session_id);
 }
","                                          device_id, session_id);
"
" MediaStreamDispatcherHost::~MediaStreamDispatcherHost() {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
  bindings_.CloseAllBindings();
   CancelAllRequests();
 }
","  bindings_.CloseAllBindings();
"
" void MediaStreamManager::CancelAllRequests(int render_process_id,
                                           int render_frame_id) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   auto request_it = requests_.begin();
   while (request_it != requests_.end()) {
     if (request_it->second->requesting_process_id != render_process_id ||
        request_it->second->requesting_frame_id != render_frame_id) {
       ++request_it;
       continue;
     }
    const std::string label = request_it->first;
    ++request_it;
    CancelRequest(label);
  }
}
","                                           int render_frame_id) {
        request_it->second->requesting_frame_id != render_frame_id) {
"
" void MediaStreamManager::GenerateStream(
     int render_process_id,
     int render_frame_id,
     int page_request_id,
     const StreamControls& controls,
     MediaDeviceSaltAndOrigin salt_and_origin,
    bool user_gesture,
    GenerateStreamCallback generate_stream_cb,
    DeviceStoppedCallback device_stopped_cb,
    DeviceChangedCallback device_changed_cb) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DVLOG(1) << ""GenerateStream()"";
 
   DeviceRequest* request = new DeviceRequest(
      render_process_id, render_frame_id, page_request_id, user_gesture,
      MEDIA_GENERATE_STREAM, controls, std::move(salt_and_origin),
       std::move(device_stopped_cb));
   request->device_changed_cb = std::move(device_changed_cb);
 
  const std::string& label = AddRequest(request);

  request->generate_stream_cb = std::move(generate_stream_cb);

  if (generate_stream_test_callback_) {
    if (std::move(generate_stream_test_callback_).Run(controls)) {
      FinalizeGenerateStream(label, request);
    } else {
      FinalizeRequestFailed(label, request, MEDIA_DEVICE_INVALID_STATE);
    }
    return;
  }

  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},
                           base::BindOnce(&MediaStreamManager::SetUpRequest,
                                          base::Unretained(this), label));
}
","      render_process_id, render_frame_id, page_request_id, user_gesture,
      MEDIA_GENERATE_STREAM, controls, std::move(salt_and_origin),
"
" std::string MediaStreamManager::MakeMediaAccessRequest(
     int render_process_id,
     int render_frame_id,
     int page_request_id,
     const StreamControls& controls,
     const url::Origin& security_origin,
     MediaAccessRequestCallback callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   DeviceRequest* request = new DeviceRequest(
      render_process_id, render_frame_id, page_request_id,
       false /* user gesture */, MEDIA_DEVICE_ACCESS, controls,
       MediaDeviceSaltAndOrigin{std::string() /* salt */,
                                std::string() /* group_id_salt */,
                               security_origin});

  const std::string& label = AddRequest(request);

  request->media_access_request_cb = std::move(callback);
  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},
                           base::BindOnce(&MediaStreamManager::SetUpRequest,
                                          base::Unretained(this), label));
  return label;
}
","      render_process_id, render_frame_id, page_request_id,
"
" void MediaStreamManager::OpenDevice(int render_process_id,
                                     int render_frame_id,
                                     int page_request_id,
                                     const std::string& device_id,
                                     MediaStreamType type,
                                    MediaDeviceSaltAndOrigin salt_and_origin,
                                    OpenDeviceCallback open_device_cb,
                                    DeviceStoppedCallback device_stopped_cb) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);
  DCHECK(type == MEDIA_DEVICE_AUDIO_CAPTURE ||
         type == MEDIA_DEVICE_VIDEO_CAPTURE);
  DVLOG(1) << ""OpenDevice ({page_request_id = "" << page_request_id << ""})"";
  StreamControls controls;
  if (IsAudioInputMediaType(type)) {
    controls.audio.requested = true;
    controls.audio.stream_type = type;
    controls.audio.device_id = device_id;
  } else if (IsVideoInputMediaType(type)) {
    controls.video.requested = true;
    controls.video.stream_type = type;
    controls.video.device_id = device_id;
  } else {
     NOTREACHED();
   }
   DeviceRequest* request = new DeviceRequest(
      render_process_id, render_frame_id, page_request_id,
       false /* user gesture */, MEDIA_OPEN_DEVICE_PEPPER_ONLY, controls,
       std::move(salt_and_origin), std::move(device_stopped_cb));
 
  const std::string& label = AddRequest(request);

  request->open_device_cb = std::move(open_device_cb);
  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},
                           base::BindOnce(&MediaStreamManager::SetUpRequest,
                                          base::Unretained(this), label));
}
","      render_process_id, render_frame_id, page_request_id,
"
"   std::string MakeMediaAccessRequest(int index) {
     const int render_process_id = 1;
     const int render_frame_id = 1;
     const int page_request_id = 1;
     const url::Origin security_origin;
     MediaStreamManager::MediaAccessRequestCallback callback =
         base::BindOnce(&MediaStreamManagerTest::ResponseCallback,
                        base::Unretained(this), index);
     StreamControls controls(true, true);
     return media_stream_manager_->MakeMediaAccessRequest(
        render_process_id, render_frame_id, page_request_id, controls,
        security_origin, std::move(callback));
   }
","        render_process_id, render_frame_id, page_request_id, controls,
        security_origin, std::move(callback));
"
" VideoCaptureManager::~VideoCaptureManager() {
  DCHECK(controllers_.empty());
   DCHECK(device_start_request_queue_.empty());
   if (screenlock_monitor_) {
     screenlock_monitor_->RemoveObserver(this);
  }
}
","  DCHECK(controllers_.empty());
"
"   void OpenSession() {
     const int render_process_id = 1;
     const int render_frame_id = 1;
     const int page_request_id = 1;
     const url::Origin security_origin =
         url::Origin::Create(GURL(""http://test.com""));

    ASSERT_TRUE(opened_device_label_.empty());

    MediaDeviceInfoArray video_devices;
    {
      base::RunLoop run_loop;
      MediaDevicesManager::BoolDeviceTypes devices_to_enumerate;
      devices_to_enumerate[MEDIA_DEVICE_TYPE_VIDEO_INPUT] = true;
      media_stream_manager_->media_devices_manager()->EnumerateDevices(
          devices_to_enumerate,
          base::BindOnce(&VideoInputDevicesEnumerated, run_loop.QuitClosure(),
                         browser_context_.GetMediaDeviceIDSalt(),
                         security_origin, &video_devices));
      run_loop.Run();
    }
    ASSERT_FALSE(video_devices.empty());

     {
       base::RunLoop run_loop;
       media_stream_manager_->OpenDevice(
          render_process_id, render_frame_id, page_request_id,
           video_devices[0].device_id, MEDIA_DEVICE_VIDEO_CAPTURE,
           MediaDeviceSaltAndOrigin{browser_context_.GetMediaDeviceIDSalt(),
                                    browser_context_.GetMediaDeviceIDSalt(),
                                   security_origin},
          base::BindOnce(&VideoCaptureTest::OnDeviceOpened,
                         base::Unretained(this), run_loop.QuitClosure()),
          MediaStreamManager::DeviceStoppedCallback());
      run_loop.Run();
    }
    ASSERT_NE(MediaStreamDevice::kNoId, opened_session_id_);
  }
","          render_process_id, render_frame_id, page_request_id,
"
"void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,
                                                              bool ask_user,
                                                              bool is_allowed) {
  DCHECK_CURRENTLY_ON(BrowserThread::IO);

  auto iter = sessions_.find(session_id);
  if (iter == sessions_.end())
    return;

  Session* session = iter->second.get();

  if (session->abort_requested)
    return;

   if (ask_user) {
     SpeechRecognitionSessionContext& context = session->context;
     context.label = media_stream_manager_->MakeMediaAccessRequest(
        context.render_process_id, context.render_frame_id, session_id,
        StreamControls(true, false), context.security_origin,
         base::BindOnce(
             &SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,
             weak_factory_.GetWeakPtr(), session_id));
    return;
  }

  if (is_allowed) {
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE,
        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,
                       weak_factory_.GetWeakPtr(), session_id, EVENT_START));
  } else {
    OnRecognitionError(
        session_id, blink::mojom::SpeechRecognitionError(
                        blink::mojom::SpeechRecognitionErrorCode::kNotAllowed,
                        blink::mojom::SpeechAudioErrorDetails::kNone));
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE,
        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,
                       weak_factory_.GetWeakPtr(), session_id, EVENT_ABORT));
  }
}
","        context.render_process_id, context.render_frame_id, session_id,
        StreamControls(true, false), context.security_origin,
"
"DOMHandler::DOMHandler()
     : DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr) {
}
","      host_(nullptr) {
}
"
"bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {
  if (!ShouldAllowSession(session))
    return false;

   protocol::EmulationHandler* emulation_handler =
       new protocol::EmulationHandler();
   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
   session->AddHandler(base::WrapUnique(emulation_handler));
   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));
   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
  session->AddHandler(base::WrapUnique(new protocol::IOHandler(
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(
      GetId(),
      frame_tree_node_ ? frame_tree_node_->devtools_frame_token()
                       : base::UnguessableToken(),
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));
  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));
  session->AddHandler(base::WrapUnique(new protocol::TargetHandler(
      session->client()->MayAttachToBrowser()
          ? protocol::TargetHandler::AccessMode::kRegular
          : protocol::TargetHandler::AccessMode::kAutoAttachOnly,
      GetId(), GetRendererChannel(), session->GetRootSession())));
  session->AddHandler(base::WrapUnique(new protocol::PageHandler(
      emulation_handler, session->client()->MayAffectLocalFiles())));
  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));
  if (!frame_tree_node_ || !frame_tree_node_->parent()) {
    session->AddHandler(base::WrapUnique(
        new protocol::TracingHandler(frame_tree_node_, GetIOContext())));
  }

  if (sessions().empty()) {
    bool use_video_capture_api = true;
#ifdef OS_ANDROID
    if (!CompositorImpl::IsInitialized())
      use_video_capture_api = false;
#endif
    if (!use_video_capture_api)
      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());
    GrantPolicy();
#if defined(OS_ANDROID)
    GetWakeLock()->RequestWakeLock();
#endif
  }
  return true;
}
","  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
"
"bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,
                             const PermissionSet& required_permissions,
                             const PermissionSet& optional_permissions,
                             bool allow_file_access,
                             UnpackPermissionSetResult* result,
                             std::string* error) {
  int user_script_schemes = UserScript::ValidUserScriptSchemes();
  int explicit_schemes = Extension::kValidHostPermissionSchemes;
  if (!allow_file_access) {
    user_script_schemes &= ~URLPattern::SCHEME_FILE;
     explicit_schemes &= ~URLPattern::SCHEME_FILE;
   }
 
   for (const auto& origin_str : origins_input) {
     URLPattern explicit_origin(explicit_schemes);
     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);
    if (URLPattern::ParseResult::kSuccess != parse_result) {
      *error = ErrorUtils::FormatErrorMessage(
          kInvalidOrigin, origin_str,
          URLPattern::GetParseResultString(parse_result));
       return false;
     }
 
     bool used_origin = false;
     if (required_permissions.explicit_hosts().ContainsPattern(
             explicit_origin)) {
      used_origin = true;
      result->required_explicit_hosts.AddPattern(explicit_origin);
    } else if (optional_permissions.explicit_hosts().ContainsPattern(
                   explicit_origin)) {
      used_origin = true;
      result->optional_explicit_hosts.AddPattern(explicit_origin);
    }
 
     URLPattern scriptable_origin(user_script_schemes);
     if (scriptable_origin.Parse(origin_str) ==
            URLPattern::ParseResult::kSuccess &&
        required_permissions.scriptable_hosts().ContainsPattern(
            scriptable_origin)) {
      used_origin = true;
      result->required_scriptable_hosts.AddPattern(scriptable_origin);
     }
 
     if (!used_origin)
      result->unlisted_hosts.AddPattern(explicit_origin);
  }

  return true;
}
","            URLPattern::ParseResult::kSuccess &&
        required_permissions.scriptable_hosts().ContainsPattern(
            scriptable_origin)) {
      used_origin = true;
      result->required_scriptable_hosts.AddPattern(scriptable_origin);
"
" void ChromeContentBrowserClient::OpenURL(
    content::BrowserContext* browser_context,
     const content::OpenURLParams& params,
    const base::Callback<void(content::WebContents*)>& callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
 
 #if defined(OS_ANDROID)
   ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,
                                               callback);
#else
  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),
                            params.url, params.transition);
  nav_params.FillNavigateParamsFromOpenURLParams(params);
  nav_params.user_gesture = params.user_gesture;

  Navigate(&nav_params);
  callback.Run(nav_params.navigated_or_inserted_contents);
#endif
}
","    content::BrowserContext* browser_context,
    const base::Callback<void(content::WebContents*)>& callback) {
"
" void WebGL2RenderingContextBase::bindSampler(GLuint unit,
                                              WebGLSampler* sampler) {
  if (isContextLost())
    return;
   bool deleted;
   if (!CheckObjectToBeBound(""bindSampler"", sampler, deleted))
     return;
  if (deleted) {
    SynthesizeGLError(GL_INVALID_OPERATION, ""bindSampler"",
                      ""attempted to bind a deleted sampler"");
    return;
  }

  if (unit >= sampler_units_.size()) {
    SynthesizeGLError(GL_INVALID_VALUE, ""bindSampler"",
                      ""texture unit out of range"");
    return;
  }

  sampler_units_[unit] = sampler;

  ContextGL()->BindSampler(unit, ObjectOrZero(sampler));
}
","  if (isContextLost())
    return;
"
" void WebGL2RenderingContextBase::bindVertexArray(
     WebGLVertexArrayObject* vertex_array) {
  if (isContextLost())
     return;
  if (vertex_array &&
      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {
     SynthesizeGLError(GL_INVALID_OPERATION, ""bindVertexArray"",
                      ""invalid vertexArray"");
     return;
   }
 
  if (vertex_array && !vertex_array->IsDefaultObject() &&
      vertex_array->Object()) {
    ContextGL()->BindVertexArrayOES(ObjectOrZero(vertex_array));

    vertex_array->SetHasEverBeenBound();
    SetBoundVertexArrayObject(vertex_array);
  } else {
    ContextGL()->BindVertexArrayOES(0);
    SetBoundVertexArrayObject(nullptr);
  }
}
","  if (isContextLost())
  if (vertex_array &&
      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {
                      ""invalid vertexArray"");
"
" void WebGL2RenderingContextBase::deleteVertexArray(
     WebGLVertexArrayObject* vertex_array) {
  if (isContextLost() || !vertex_array)
     return;
 
   if (!vertex_array->IsDefaultObject() &&
      vertex_array == bound_vertex_array_object_)
    SetBoundVertexArrayObject(nullptr);

  vertex_array->DeleteObject(ContextGL());
}
","  if (isContextLost() || !vertex_array)
"
"void WebGL2RenderingContextBase::framebufferTextureLayer(GLenum target,
                                                         GLenum attachment,
                                                         WebGLTexture* texture,
                                                         GLint level,
                                                         GLint layer) {
  if (isContextLost() || !ValidateFramebufferFuncParameters(
                              ""framebufferTextureLayer"", target, attachment))
     return;
   if (texture && !texture->Validate(ContextGroup(), this)) {
    SynthesizeGLError(GL_INVALID_VALUE, ""framebufferTextureLayer"",
                      ""no texture or texture not from this context"");
     return;
   }
   GLenum textarget = texture ? texture->GetTarget() : 0;
  if (texture) {
    if (textarget != GL_TEXTURE_3D && textarget != GL_TEXTURE_2D_ARRAY) {
      SynthesizeGLError(GL_INVALID_OPERATION, ""framebufferTextureLayer"",
                        ""invalid texture type"");
      return;
    }
    if (!ValidateTexFuncLayer(""framebufferTextureLayer"", textarget, layer))
      return;
    if (!ValidateTexFuncLevel(""framebufferTextureLayer"", textarget, level))
      return;
  }

  WebGLFramebuffer* framebuffer_binding = GetFramebufferBinding(target);
  if (!framebuffer_binding || !framebuffer_binding->Object()) {
    SynthesizeGLError(GL_INVALID_OPERATION, ""framebufferTextureLayer"",
                      ""no framebuffer bound"");
    return;
  }
  if (framebuffer_binding && framebuffer_binding->Opaque()) {
    SynthesizeGLError(GL_INVALID_OPERATION, ""framebufferTextureLayer"",
                      ""opaque framebuffer bound"");
    return;
  }
  framebuffer_binding->SetAttachmentForBoundFramebuffer(
      target, attachment, textarget, texture, level, layer);
  ApplyStencilTest();
}
","    SynthesizeGLError(GL_INVALID_VALUE, ""framebufferTextureLayer"",
                      ""no texture or texture not from this context"");
"
" GLboolean WebGL2RenderingContextBase::isTransformFeedback(
     WebGLTransformFeedback* feedback) {
  if (isContextLost() || !feedback)
     return 0;
 
   if (!feedback->HasEverBeenBound())
    return 0;

  return ContextGL()->IsTransformFeedback(feedback->Object());
}
","  if (isContextLost() || !feedback)
"
" GLboolean WebGL2RenderingContextBase::isVertexArray(
     WebGLVertexArrayObject* vertex_array) {
  if (isContextLost() || !vertex_array)
     return 0;
 
   if (!vertex_array->HasEverBeenBound())
    return 0;

  return ContextGL()->IsVertexArrayOES(vertex_array->Object());
}
","  if (isContextLost() || !vertex_array)
"
" GLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer) {
  if (!buffer || isContextLost())
     return 0;
 
   if (!buffer->HasEverBeenBound())
    return 0;
  if (buffer->IsDeleted())
    return 0;

  return ContextGL()->IsBuffer(buffer->Object());
}
","  if (!buffer || isContextLost())
"
" GLboolean WebGLRenderingContextBase::isFramebuffer(
     WebGLFramebuffer* framebuffer) {
  if (!framebuffer || isContextLost())
     return 0;
 
   if (!framebuffer->HasEverBeenBound())
    return 0;
  if (framebuffer->IsDeleted())
    return 0;

  return ContextGL()->IsFramebuffer(framebuffer->Object());
 }
","  if (!framebuffer || isContextLost())
"
" GLboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program) {
  if (!program || isContextLost())
     return 0;
 
   return ContextGL()->IsProgram(program->Object());
 }
","  if (!program || isContextLost())
"
" GLboolean WebGLRenderingContextBase::isRenderbuffer(
     WebGLRenderbuffer* renderbuffer) {
  if (!renderbuffer || isContextLost())
     return 0;
 
   if (!renderbuffer->HasEverBeenBound())
    return 0;
  if (renderbuffer->IsDeleted())
    return 0;

  return ContextGL()->IsRenderbuffer(renderbuffer->Object());
 }
","  if (!renderbuffer || isContextLost())
"
" GLboolean WebGLRenderingContextBase::isShader(WebGLShader* shader) {
  if (!shader || isContextLost())
     return 0;
 
   return ContextGL()->IsShader(shader->Object());
 }
","  if (!shader || isContextLost())
"
" GLboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture) {
  if (!texture || isContextLost())
     return 0;
 
   if (!texture->HasEverBeenBound())
    return 0;
  if (texture->IsDeleted())
    return 0;

  return ContextGL()->IsTexture(texture->Object());
}
","  if (!texture || isContextLost())
"
" void GCInfoTable::EnsureGCInfoIndex(const GCInfo* gc_info,
                                     size_t* gc_info_index_slot) {
   DCHECK(gc_info);
   DCHECK(gc_info_index_slot);
  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());
  MutexLocker locker(mutex);
 
   if (*gc_info_index_slot)
     return;
 
  int index = ++gc_info_index_;
   size_t gc_info_index = static_cast<size_t>(index);
   CHECK(gc_info_index < GCInfoTable::kMaxIndex);
  if (gc_info_index >= gc_info_table_size_)
     Resize();
 
  g_gc_info_table[gc_info_index] = gc_info;
   ReleaseStore(reinterpret_cast<int*>(gc_info_index_slot), index);
 }
","  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());
  MutexLocker locker(mutex);
  int index = ++gc_info_index_;
  if (gc_info_index >= gc_info_table_size_)
  g_gc_info_table[gc_info_index] = gc_info;
"
"void GCInfoTable::Init() {
  CHECK(!g_gc_info_table);
   Resize();
 }
","  CHECK(!g_gc_info_table);
"
" void GCInfoTable::Resize() {
  static const int kGcInfoZapValue = 0x33;
  const size_t kInitialSize = 512;
  size_t new_size =
      gc_info_table_size_ ? 2 * gc_info_table_size_ : kInitialSize;
  DCHECK(new_size < GCInfoTable::kMaxIndex);
  g_gc_info_table =
      reinterpret_cast<GCInfo const**>(WTF::Partitions::FastRealloc(
          g_gc_info_table, new_size * sizeof(GCInfo), ""GCInfo""));
  DCHECK(g_gc_info_table);
  memset(reinterpret_cast<uint8_t*>(g_gc_info_table) +
             gc_info_table_size_ * sizeof(GCInfo),
         kGcInfoZapValue, (new_size - gc_info_table_size_) * sizeof(GCInfo));
  gc_info_table_size_ = new_size;
 }
","  static const int kGcInfoZapValue = 0x33;
  const size_t kInitialSize = 512;
  size_t new_size =
      gc_info_table_size_ ? 2 * gc_info_table_size_ : kInitialSize;
  DCHECK(new_size < GCInfoTable::kMaxIndex);
  g_gc_info_table =
      reinterpret_cast<GCInfo const**>(WTF::Partitions::FastRealloc(
          g_gc_info_table, new_size * sizeof(GCInfo), ""GCInfo""));
  DCHECK(g_gc_info_table);
  memset(reinterpret_cast<uint8_t*>(g_gc_info_table) +
             gc_info_table_size_ * sizeof(GCInfo),
         kGcInfoZapValue, (new_size - gc_info_table_size_) * sizeof(GCInfo));
  gc_info_table_size_ = new_size;
"
"void ThreadHeap::WriteBarrier(void* value) {
  DCHECK(thread_state_->IsIncrementalMarking());
  DCHECK(value);
  DCHECK_NE(value, reinterpret_cast<void*>(-1));

  BasePage* const page = PageFromObject(value);
  HeapObjectHeader* const header =
      page->IsLargeObjectPage()
          ? static_cast<LargeObjectPage*>(page)->GetHeapObjectHeader()
          : static_cast<NormalPage*>(page)->FindHeaderFromAddress(
                reinterpret_cast<Address>(const_cast<void*>(value)));
  if (header->IsMarked())
    return;

   header->Mark();
   marking_worklist_->Push(
       WorklistTaskId::MainThread,
      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});
 }
","      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});
"
" void HeapObjectHeader::Finalize(Address object, size_t object_size) {
   HeapAllocHooks::FreeHookIfEnabled(object);
  const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());
   if (gc_info->HasFinalizer())
     gc_info->finalize_(object);
 
  ASAN_RETIRE_CONTAINER_ANNOTATION(object, object_size);
}
","  const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());
"
"  void ProcessBackingStore(HeapObjectHeader* header) {
     EXPECT_TRUE(header->IsValid());
     EXPECT_TRUE(header->IsMarked());
     header->Unmark();
    ThreadHeap::GcInfo(header->GcInfoIndex())->trace_(this, header->Payload());
   }
","    ThreadHeap::GcInfo(header->GcInfoIndex())->trace_(this, header->Payload());
"
" void MarkingVisitor::ConservativelyMarkHeader(HeapObjectHeader* header) {
  const GCInfo* gc_info = ThreadHeap::GcInfo(header->GcInfoIndex());
   if (gc_info->HasVTable() && !VTableInitialized(header->Payload())) {
    MarkHeaderNoTracing(header);
#if DCHECK_IS_ON()
    DCHECK(IsUninitializedMemory(header->Payload(), header->PayloadSize()));
#endif
  } else {
    MarkHeader(header, gc_info->trace_);
  }
}
","  const GCInfo* gc_info = ThreadHeap::GcInfo(header->GcInfoIndex());
"
"void ProcessHeap::Init() {
  total_allocated_space_ = 0;
   total_allocated_object_size_ = 0;
   total_marked_object_size_ = 0;
 
  GCInfoTable::Init();
   base::SamplingHeapProfiler::SetHooksInstallCallback([]() {
     HeapAllocHooks::SetAllocationHook(&BlinkGCAllocHook);
     HeapAllocHooks::SetFreeHook(&BlinkGCFreeHook);
  });
}
","  GCInfoTable::Init();
"
"bool Performance::PassesTimingAllowCheck(
    const ResourceResponse& response,
     const SecurityOrigin& initiator_security_origin,
     const AtomicString& original_timing_allow_origin,
     ExecutionContext* context) {
   scoped_refptr<const SecurityOrigin> resource_origin =
      SecurityOrigin::Create(response.Url());
   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))
     return true;
 
  const AtomicString& timing_allow_origin_string =
      original_timing_allow_origin.IsEmpty()
          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)
          : original_timing_allow_origin;
  if (timing_allow_origin_string.IsEmpty() ||
      EqualIgnoringASCIICase(timing_allow_origin_string, ""null""))
    return false;

  if (timing_allow_origin_string == ""*"") {
    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);
    return true;
  }

  const String& security_origin = initiator_security_origin.ToString();
  Vector<String> timing_allow_origins;
  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);
  if (timing_allow_origins.size() > 1) {
    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);
  } else if (timing_allow_origins.size() == 1 &&
             timing_allow_origin_string != ""*"") {
    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);
  }
  for (const String& allow_origin : timing_allow_origins) {
    const String allow_origin_stripped = allow_origin.StripWhiteSpace();
    if (allow_origin_stripped == security_origin ||
        allow_origin_stripped == ""*"") {
      return true;
    }
  }

  return false;
}
","      SecurityOrigin::Create(response.Url());
"
"MediaElementAudioSourceHandler::MediaElementAudioSourceHandler(
    AudioNode& node,
    HTMLMediaElement& media_element)
    : AudioHandler(kNodeTypeMediaElementAudioSource,
                   node,
                   node.context()->sampleRate()),
       media_element_(media_element),
       source_number_of_channels_(0),
       source_sample_rate_(0),
      passes_current_src_cors_access_check_(
          PassesCurrentSrcCORSAccessCheck(media_element.currentSrc())),
      maybe_print_cors_message_(!passes_current_src_cors_access_check_),
      current_src_string_(media_element.currentSrc().GetString()) {
   DCHECK(IsMainThread());
  AddOutput(2);

  if (Context()->GetExecutionContext()) {
    task_runner_ = Context()->GetExecutionContext()->GetTaskRunner(
        TaskType::kMediaElementEvent);
  }

  Initialize();
}
","      passes_current_src_cors_access_check_(
          PassesCurrentSrcCORSAccessCheck(media_element.currentSrc())),
      maybe_print_cors_message_(!passes_current_src_cors_access_check_),
      current_src_string_(media_element.currentSrc().GetString()) {
"
"void MediaElementAudioSourceHandler::OnCurrentSrcChanged(
    const KURL& current_src) {
  DCHECK(IsMainThread());
  Locker<MediaElementAudioSourceHandler> locker(*this);
 
  passes_current_src_cors_access_check_ =
      PassesCurrentSrcCORSAccessCheck(current_src);
 
  maybe_print_cors_message_ = !passes_current_src_cors_access_check_;
  current_src_string_ = current_src.GetString();
}
","    const KURL& current_src) {
  DCHECK(IsMainThread());
  Locker<MediaElementAudioSourceHandler> locker(*this);
  passes_current_src_cors_access_check_ =
      PassesCurrentSrcCORSAccessCheck(current_src);
  maybe_print_cors_message_ = !passes_current_src_cors_access_check_;
  current_src_string_ = current_src.GetString();
}
"
"void MediaElementAudioSourceNode::OnCurrentSrcChanged(const KURL& current_src) {
  GetMediaElementAudioSourceHandler().OnCurrentSrcChanged(current_src);
}
","  GetMediaElementAudioSourceHandler().OnCurrentSrcChanged(current_src);
}
"
"bool MediaElementAudioSourceHandler::PassesCORSAccessCheck() {
  DCHECK(MediaElement());
  return (MediaElement()->GetWebMediaPlayer() &&
          MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||
         passes_current_src_cors_access_check_;
}
","  DCHECK(MediaElement());
  return (MediaElement()->GetWebMediaPlayer() &&
          MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||
         passes_current_src_cors_access_check_;
}
"
"bool MediaElementAudioSourceHandler::PassesCurrentSrcCORSAccessCheck(
    const KURL& current_src) {
  DCHECK(IsMainThread());
  return Context()->GetSecurityOrigin() &&
         Context()->GetSecurityOrigin()->CanRequest(current_src);
 }
","    const KURL& current_src) {
  DCHECK(IsMainThread());
  return Context()->GetSecurityOrigin() &&
         Context()->GetSecurityOrigin()->CanRequest(current_src);
"
"void MediaElementAudioSourceHandler::Process(size_t number_of_frames) {
  AudioBus* output_bus = Output(0).Bus();

  MutexTryLocker try_locker(process_lock_);
  if (try_locker.Locked()) {
    if (!MediaElement() || !source_sample_rate_) {
      output_bus->Zero();
      return;
    }

    if (source_number_of_channels_ != output_bus->NumberOfChannels()) {
      output_bus->Zero();
      return;
    }

    AudioSourceProvider& provider = MediaElement()->GetAudioSourceProvider();
    if (multi_channel_resampler_.get()) {
      DCHECK_NE(source_sample_rate_, Context()->sampleRate());
      multi_channel_resampler_->Process(&provider, output_bus,
                                        number_of_frames);
    } else {
      DCHECK_EQ(source_sample_rate_, Context()->sampleRate());
       provider.ProvideInput(output_bus, number_of_frames);
     }
    if (!PassesCORSAccessCheck()) {
      if (maybe_print_cors_message_) {
        maybe_print_cors_message_ = false;
        PostCrossThreadTask(
            *task_runner_, FROM_HERE,
            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,
                            WrapRefCounted(this), current_src_string_));
      }
       output_bus->Zero();
     }
   } else {
    output_bus->Zero();
  }
}
","    if (!PassesCORSAccessCheck()) {
      if (maybe_print_cors_message_) {
        maybe_print_cors_message_ = false;
        PostCrossThreadTask(
            *task_runner_, FROM_HERE,
            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,
                            WrapRefCounted(this), current_src_string_));
      }
"
"ExtensionInstallDialogView::ExtensionInstallDialogView(
    Profile* profile,
    content::PageNavigator* navigator,
    const ExtensionInstallPrompt::DoneCallback& done_callback,
    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)
    : profile_(profile),
      navigator_(navigator),
      done_callback_(done_callback),
       prompt_(std::move(prompt)),
       container_(NULL),
       scroll_view_(NULL),
      handled_result_(false) {
   InitView();
 }
","      handled_result_(false) {
"
" ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {
   DCHECK_CURRENTLY_ON(work_thread_id());
 
  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
 
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
 
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
   if (!socket)
     return RespondNow(Error(kSocketNotFoundError));
 
  socket->Send(io_buffer_,
               io_buffer_size_,
               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),
               base::Bind(&BluetoothSocketSendFunction::OnError, this));
  return did_respond() ? AlreadyResponded() : RespondLater();
}
","  auto params = bluetooth_socket::Send::Params::Create(*args_);
  EXTENSION_FUNCTION_VALIDATE(params.get());
  io_buffer_size_ = params->data.size();
  io_buffer_ = new net::WrappedIOBuffer(params->data.data());
  BluetoothApiSocket* socket = GetSocket(params->socket_id);
"
" void HTMLMediaElement::ChangeNetworkStateFromLoadingToIdle() {
   progress_event_timer_.Stop();
 
  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress())
    ScheduleEvent(EventTypeNames::progress);
  ScheduleEvent(EventTypeNames::suspend);
  SetNetworkState(kNetworkIdle);
 }
","  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress())
    ScheduleEvent(EventTypeNames::progress);
  ScheduleEvent(EventTypeNames::suspend);
  SetNetworkState(kNetworkIdle);
"
" void HTMLMediaElement::MediaLoadingFailed(WebMediaPlayer::NetworkState error,
                                          const String& message) {
   BLINK_MEDIA_LOG << ""MediaLoadingFailed("" << (void*)this << "", ""
                  << static_cast<int>(error) << "", message='"" << message
                   << ""')"";
 
   StopPeriodicTimers();
 
  if (ready_state_ < kHaveMetadata &&
      load_state_ == kLoadingFromSourceElement) {
    if (current_source_node_) {
      current_source_node_->ScheduleErrorEvent();
    } else {
      BLINK_MEDIA_LOG << ""mediaLoadingFailed("" << (void*)this
                      << "") - error event not sent, <source> was removed"";
    }


    ForgetResourceSpecificTracks();

    if (HavePotentialSourceChild()) {
      BLINK_MEDIA_LOG << ""mediaLoadingFailed("" << (void*)this
                      << "") - scheduling next <source>"";
      ScheduleNextSourceChild();
    } else {
      BLINK_MEDIA_LOG << ""mediaLoadingFailed("" << (void*)this
                      << "") - no more <source> elements, waiting"";
      WaitForSourceChange();
    }

    return;
  }

  if (error == WebMediaPlayer::kNetworkStateNetworkError &&
      ready_state_ >= kHaveMetadata) {
    MediaEngineError(MediaError::Create(MediaError::kMediaErrNetwork, message));
  } else if (error == WebMediaPlayer::kNetworkStateDecodeError) {
    MediaEngineError(MediaError::Create(MediaError::kMediaErrDecode, message));
  } else if ((error == WebMediaPlayer::kNetworkStateFormatError ||
              error == WebMediaPlayer::kNetworkStateNetworkError) &&
             load_state_ == kLoadingFromSrcAttr) {
    if (message.IsEmpty()) {
      NoneSupported(BuildElementErrorMessage(
          error == WebMediaPlayer::kNetworkStateFormatError ? ""Format error""
                                                            : ""Network error""));
    } else {
      NoneSupported(message);
    }
  }

  UpdateDisplayState();
}
","                                          const String& message) {
                  << static_cast<int>(error) << "", message='"" << message
"
"void HTMLMediaElement::NoneSupported(const String& message) {
  BLINK_MEDIA_LOG << ""NoneSupported("" << (void*)this << "", message='"" << message
                  << ""')"";
 
   StopPeriodicTimers();
   load_state_ = kWaitingForSource;
   current_source_node_ = nullptr;
 
 
  error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);

  ForgetResourceSpecificTracks();

  SetNetworkState(kNetworkNoSource);

  UpdateDisplayState();

  ScheduleEvent(EventTypeNames::error);

  ScheduleRejectPlayPromises(kNotSupportedError);

  CloseMediaSource();

  SetShouldDelayLoadEvent(false);

  if (GetLayoutObject())
    GetLayoutObject()->UpdateFromElement();
}
","  BLINK_MEDIA_LOG << ""NoneSupported("" << (void*)this << "", message='"" << message
                  << ""')"";
"
"gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {
  if (ShouldApplyDisplayCentering())
    return CalculatePaddingForDisplayCentering();
 
   const int icons_size = shelf_view_->GetSizeOfAppIcons(
       shelf_view_->number_of_visible_apps(), false);
  gfx::Insets padding_insets(
      /*vertical= */ 0,
      /*horizontal= */ ShelfConfig::Get()->app_icon_group_margin());
 
   const int available_size_for_app_icons =
       (GetShelf()->IsHorizontalAlignment() ? width() : height()) -
      2 * ShelfConfig::Get()->app_icon_group_margin();

  int gap =
      layout_strategy_ == kNotShowArrowButtons
           ? available_size_for_app_icons - icons_size  // shelf centering
           : CalculateOverflowPadding(available_size_for_app_icons);  // overflow
 
  padding_insets.set_left(padding_insets.left() + gap / 2);
  padding_insets.set_right(padding_insets.right() +
                           (gap % 2 ? gap / 2 + 1 : gap / 2));
 
   return padding_insets;
 }
","  gfx::Insets padding_insets(
      /*vertical= */ 0,
      /*horizontal= */ ShelfConfig::Get()->app_icon_group_margin());
  padding_insets.set_left(padding_insets.left() + gap / 2);
  padding_insets.set_right(padding_insets.right() +
                           (gap % 2 ? gap / 2 + 1 : gap / 2));
"
"gfx::Insets ScrollableShelfView::CalculatePaddingForDisplayCentering() const {
  const int icons_size = shelf_view_->GetSizeOfAppIcons(
      shelf_view_->number_of_visible_apps(), false);
  const gfx::Rect display_bounds =
      screen_util::GetDisplayBoundsWithShelf(GetWidget()->GetNativeWindow());
  const int display_size_primary = GetShelf()->PrimaryAxisValue(
      display_bounds.width(), display_bounds.height());
  const int gap = (display_size_primary - icons_size) / 2;
 
   const gfx::Rect screen_bounds = GetBoundsInScreen();
  const int left_padding = gap - GetShelf()->PrimaryAxisValue(
                                     screen_bounds.x() - display_bounds.x(),
                                     screen_bounds.y() - display_bounds.y());
  const int right_padding =
       gap - GetShelf()->PrimaryAxisValue(
                 display_bounds.right() - screen_bounds.right(),
                 display_bounds.bottom() - screen_bounds.bottom());
 
  return gfx::Insets(0, left_padding, 0, right_padding);
 }
","  const int left_padding = gap - GetShelf()->PrimaryAxisValue(
                                     screen_bounds.x() - display_bounds.x(),
                                     screen_bounds.y() - display_bounds.y());
  const int right_padding =
  return gfx::Insets(0, left_padding, 0, right_padding);
"
" float ScrollableShelfView::CalculatePageScrollingOffset(bool forward) const {
  float offset = space_for_icons_ - kArrowButtonGroupWidth -
                  ShelfConfig::Get()->button_size() - GetAppIconEndPadding();
   if (layout_strategy_ == kShowRightArrowButton)
     offset -= (kArrowButtonGroupWidth - GetAppIconEndPadding());
  DCHECK_GT(offset, 0);

  if (!forward)
    offset = -offset;

  return offset;
}
","  float offset = space_for_icons_ - kArrowButtonGroupWidth -
"
"int ScrollableShelfView::CalculateScrollUpperBound() const {
  if (layout_strategy_ == kNotShowArrowButtons)
     return 0;
 
  int available_length = space_for_icons_ - 2 * GetAppIconEndPadding();
 
   const gfx::Size shelf_preferred_size(
      shelf_container_view_->GetPreferredSize());
  const int preferred_length =
      (GetShelf()->IsHorizontalAlignment() ? shelf_preferred_size.width()
                                           : shelf_preferred_size.height());

  return std::max(0, preferred_length - available_length);
}
","  int available_length = space_for_icons_ - 2 * GetAppIconEndPadding();
"
"   explicit RemoveDownloadsTester(TestingProfile* testing_profile)
      : download_manager_(new content::MockDownloadManager()),
        chrome_download_manager_delegate_(testing_profile) {
     content::BrowserContext::SetDownloadManagerForTesting(
         testing_profile, base::WrapUnique(download_manager_));
    EXPECT_EQ(download_manager_,
              content::BrowserContext::GetDownloadManager(testing_profile));
    EXPECT_CALL(*download_manager_, GetDelegate())
        .WillOnce(Return(&chrome_download_manager_delegate_));
     EXPECT_CALL(*download_manager_, Shutdown());
   }
","      : download_manager_(new content::MockDownloadManager()),
        chrome_download_manager_delegate_(testing_profile) {
    EXPECT_EQ(download_manager_,
              content::BrowserContext::GetDownloadManager(testing_profile));
    EXPECT_CALL(*download_manager_, GetDelegate())
        .WillOnce(Return(&chrome_download_manager_delegate_));
"
" DownloadCoreServiceImpl::GetDownloadManagerDelegate() {
   DownloadManager* manager = BrowserContext::GetDownloadManager(profile_);
  if (download_manager_created_) {
    DCHECK(static_cast<DownloadManagerDelegate*>(manager_delegate_.get()) ==
           manager->GetDelegate());
     return manager_delegate_.get();
  }
   download_manager_created_ = true;
 
  if (!manager_delegate_.get())
    manager_delegate_.reset(new ChromeDownloadManagerDelegate(profile_));

  manager_delegate_->SetDownloadManager(manager);

#if BUILDFLAG(ENABLE_EXTENSIONS)
  extension_event_router_.reset(
      new extensions::ExtensionDownloadsEventRouter(profile_, manager));
#endif

  if (!profile_->IsOffTheRecord()) {
    history::HistoryService* history = HistoryServiceFactory::GetForProfile(
        profile_, ServiceAccessType::EXPLICIT_ACCESS);
    history->GetNextDownloadId(
        manager_delegate_->GetDownloadIdReceiverCallback());
    download_history_.reset(new DownloadHistory(
        manager, std::unique_ptr<DownloadHistory::HistoryAdapter>(
                     new DownloadHistory::HistoryAdapter(history))));
  }

  download_ui_.reset(new DownloadUIController(
      manager, std::unique_ptr<DownloadUIController::Delegate>()));
 
   g_browser_process->download_status_updater()->AddManager(manager);
 
   return manager_delegate_.get();
}
","  if (download_manager_created_) {
    DCHECK(static_cast<DownloadManagerDelegate*>(manager_delegate_.get()) ==
           manager->GetDelegate());
  }
"
"void DownloadCoreServiceImpl::SetDownloadManagerDelegateForTesting(
    std::unique_ptr<ChromeDownloadManagerDelegate> new_delegate) {
   manager_delegate_.swap(new_delegate);
   DownloadManager* dm = BrowserContext::GetDownloadManager(profile_);
   dm->SetDelegate(manager_delegate_.get());
  manager_delegate_->SetDownloadManager(dm);
   if (new_delegate)
     new_delegate->Shutdown();
 }
","  manager_delegate_->SetDownloadManager(dm);
"
"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
    uint32_t download_id,
    const content::DownloadTargetCallback& callback,
    const base::FilePath& suggested_path) {
  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
 
   callback.Run(suggested_path,
                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
                suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
                content::DOWNLOAD_INTERRUPT_REASON_NONE);
 }
","               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
"
"void HTMLStyleElement::DidNotifySubtreeInsertionsToDocument() {
  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==
      StyleElement::kProcessingFatalError)
    NotifyLoadedSheetAndAllCriticalSubresources(
        kErrorOccurredLoadingSubresource);
}
","  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==
      StyleElement::kProcessingFatalError)
    NotifyLoadedSheetAndAllCriticalSubresources(
        kErrorOccurredLoadingSubresource);
}
"
" Node::InsertionNotificationRequest HTMLStyleElement::InsertedInto(
     ContainerNode* insertion_point) {
   HTMLElement::InsertedInto(insertion_point);
  return kInsertionShouldCallDidNotifySubtreeInsertions;
 }
","  return kInsertionShouldCallDidNotifySubtreeInsertions;
"
"void SVGStyleElement::DidNotifySubtreeInsertionsToDocument() {
  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==
      StyleElement::kProcessingFatalError)
    NotifyLoadedSheetAndAllCriticalSubresources(
        kErrorOccurredLoadingSubresource);
 }
","  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==
      StyleElement::kProcessingFatalError)
    NotifyLoadedSheetAndAllCriticalSubresources(
        kErrorOccurredLoadingSubresource);
"
" Node::InsertionNotificationRequest SVGStyleElement::InsertedInto(
     ContainerNode* insertion_point) {
   SVGElement::InsertedInto(insertion_point);
  return kInsertionShouldCallDidNotifySubtreeInsertions;
}
","  return kInsertionShouldCallDidNotifySubtreeInsertions;
}
"
"DataPipeConsumerDispatcher::Deserialize(const void* data,
                                        size_t num_bytes,
                                        const ports::PortName* ports,
                                        size_t num_ports,
                                        PlatformHandle* handles,
                                        size_t num_handles) {
  if (num_ports != 1 || num_handles != 1 ||
      num_bytes != sizeof(SerializedState)) {
    return nullptr;
  }
 
   const SerializedState* state = static_cast<const SerializedState*>(data);
   if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||
      state->options.capacity_num_bytes < state->options.element_num_bytes) {
     return nullptr;
   }
 
  NodeController* node_controller = Core::Get()->GetNodeController();
  ports::PortRef port;
  if (node_controller->node()->GetPort(ports[0], &port) != ports::OK)
    return nullptr;

  auto region_handle = CreateSharedMemoryRegionHandleFromPlatformHandles(
      std::move(handles[0]), PlatformHandle());
  auto region = base::subtle::PlatformSharedMemoryRegion::Take(
      std::move(region_handle),
      base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe,
      state->options.capacity_num_bytes,
      base::UnguessableToken::Deserialize(state->buffer_guid_high,
                                          state->buffer_guid_low));
  auto ring_buffer =
      base::UnsafeSharedMemoryRegion::Deserialize(std::move(region));
  if (!ring_buffer.IsValid()) {
    DLOG(ERROR) << ""Failed to deserialize shared buffer handle."";
    return nullptr;
  }

  scoped_refptr<DataPipeConsumerDispatcher> dispatcher =
      new DataPipeConsumerDispatcher(node_controller, port,
                                     std::move(ring_buffer), state->options,
                                     state->pipe_id);

  {
    base::AutoLock lock(dispatcher->lock_);
    dispatcher->read_offset_ = state->read_offset;
    dispatcher->bytes_available_ = state->bytes_available;
    dispatcher->new_data_available_ = state->bytes_available > 0;
     dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;
     if (!dispatcher->InitializeNoLock())
       return nullptr;
     dispatcher->UpdateSignalsStateNoLock();
   }
 
  return dispatcher;
}
","      state->options.capacity_num_bytes < state->options.element_num_bytes) {
"
"DataPipeProducerDispatcher::Deserialize(const void* data,
                                        size_t num_bytes,
                                        const ports::PortName* ports,
                                        size_t num_ports,
                                        PlatformHandle* handles,
                                        size_t num_handles) {
  if (num_ports != 1 || num_handles != 1 ||
      num_bytes != sizeof(SerializedState)) {
    return nullptr;
  }
 
   const SerializedState* state = static_cast<const SerializedState*>(data);
   if (!state->options.capacity_num_bytes || !state->options.element_num_bytes ||
      state->options.capacity_num_bytes < state->options.element_num_bytes) {
     return nullptr;
   }
 
  NodeController* node_controller = Core::Get()->GetNodeController();
  ports::PortRef port;
  if (node_controller->node()->GetPort(ports[0], &port) != ports::OK)
    return nullptr;

  auto region_handle = CreateSharedMemoryRegionHandleFromPlatformHandles(
      std::move(handles[0]), PlatformHandle());
  auto region = base::subtle::PlatformSharedMemoryRegion::Take(
      std::move(region_handle),
      base::subtle::PlatformSharedMemoryRegion::Mode::kUnsafe,
      state->options.capacity_num_bytes,
      base::UnguessableToken::Deserialize(state->buffer_guid_high,
                                          state->buffer_guid_low));
  auto ring_buffer =
      base::UnsafeSharedMemoryRegion::Deserialize(std::move(region));
  if (!ring_buffer.IsValid()) {
    DLOG(ERROR) << ""Failed to deserialize shared buffer handle."";
    return nullptr;
  }

  scoped_refptr<DataPipeProducerDispatcher> dispatcher =
      new DataPipeProducerDispatcher(node_controller, port,
                                     std::move(ring_buffer), state->options,
                                     state->pipe_id);

  {
    base::AutoLock lock(dispatcher->lock_);
    dispatcher->write_offset_ = state->write_offset;
    dispatcher->available_capacity_ = state->available_capacity;
     dispatcher->peer_closed_ = state->flags & kFlagPeerClosed;
     if (!dispatcher->InitializeNoLock())
       return nullptr;
     dispatcher->UpdateSignalsStateNoLock();
   }
 
  return dispatcher;
}
","      state->options.capacity_num_bytes < state->options.element_num_bytes) {
"
" bool RenderFrameHostManager::CanSubframeSwapProcess(
     const GURL& dest_url,
     SiteInstance* source_instance,
    SiteInstance* dest_instance,
    bool was_server_redirect) {
  DCHECK(!source_instance || !dest_instance);

  GURL resolved_url = dest_url;
  if (url::Origin::Create(resolved_url).unique()) {
    if (source_instance) {
      resolved_url = source_instance->GetSiteURL();
    } else if (dest_instance) {
       resolved_url = dest_instance->GetSiteURL();
     } else {
      if (!was_server_redirect)
         return false;
     }
   }
 
  if (!IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                             resolved_url)) {
    DCHECK(!dest_instance ||
           dest_instance == render_frame_host_->GetSiteInstance());
    return false;
  }

  return true;
}
","    SiteInstance* dest_instance,
    bool was_server_redirect) {
      if (!was_server_redirect)
"
"RenderFrameHostManager::GetSiteInstanceForNavigationRequest(
    const NavigationRequest& request) {
  SiteInstance* current_site_instance = render_frame_host_->GetSiteInstance();
  bool no_renderer_swap_allowed = false;
  bool was_server_redirect = request.navigation_handle() &&
                             request.navigation_handle()->WasServerRedirect();

  if (frame_tree_node_->IsMainFrame()) {
    bool can_renderer_initiate_transfer =
        (request.state() == NavigationRequest::FAILED &&
         SiteIsolationPolicy::IsErrorPageIsolationEnabled(
             true /* in_main_frame */)) ||
        (render_frame_host_->IsRenderFrameLive() &&
         IsURLHandledByNetworkStack(request.common_params().url) &&
         IsRendererTransferNeededForNavigation(render_frame_host_.get(),
                                               request.common_params().url));
    no_renderer_swap_allowed |=
        request.from_begin_navigation() && !can_renderer_initiate_transfer;
  } else {
     no_renderer_swap_allowed |= !CanSubframeSwapProcess(
         request.common_params().url, request.source_site_instance(),
        request.dest_site_instance(), was_server_redirect);
   }
 
   if (no_renderer_swap_allowed)
    return scoped_refptr<SiteInstance>(current_site_instance);

  SiteInstance* candidate_site_instance =
      speculative_render_frame_host_
          ? speculative_render_frame_host_->GetSiteInstance()
          : nullptr;

  scoped_refptr<SiteInstance> dest_site_instance = GetSiteInstanceForNavigation(
      request.common_params().url, request.source_site_instance(),
      request.dest_site_instance(), candidate_site_instance,
      request.common_params().transition,
      request.state() == NavigationRequest::FAILED,
      request.restore_type() != RestoreType::NONE, request.is_view_source(),
      was_server_redirect);

  return dest_site_instance;
}
","        request.dest_site_instance(), was_server_redirect);
"
"GURL SiteInstance::GetSiteForURL(BrowserContext* browser_context,
                                 const GURL& real_url) {
  if (real_url.SchemeIs(kGuestScheme))
    return real_url;

  GURL url = SiteInstanceImpl::GetEffectiveURL(browser_context, real_url);
  url::Origin origin = url::Origin::Create(url);

  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  url::Origin isolated_origin;
  if (policy->GetMatchingIsolatedOrigin(origin, &isolated_origin))
    return isolated_origin.GetURL();

  if (!origin.host().empty() && origin.scheme() != url::kFileScheme) {
    std::string domain = net::registry_controlled_domains::GetDomainAndRegistry(
        origin.host(),
        net::registry_controlled_domains::INCLUDE_PRIVATE_REGISTRIES);
    std::string site = origin.scheme();
    site += url::kStandardSchemeSeparator;
    site += domain.empty() ? origin.host() : domain;
    return GURL(site);
  }

  if (!origin.unique()) {
    DCHECK(!origin.scheme().empty());
     return GURL(origin.scheme() + "":"");
   } else if (url.has_scheme()) {
    if (url.SchemeIsBlob()) {
       if (url.has_ref()) {
         GURL::Replacements replacements;
         replacements.ClearRef();
        url = url.ReplaceComponents(replacements);
      }
      return url;
    }

    DCHECK(!url.scheme().empty());
    return GURL(url.scheme() + "":"");
  }

  DCHECK(!url.is_valid()) << url;
  return GURL();
}
","    if (url.SchemeIsBlob()) {
"
"bool CSSStyleSheetResource::CanUseSheet(const CSSParserContext* parser_context,
                                        MIMETypeCheck mime_type_check) const {
  if (ErrorOccurred())
    return false;

  KURL sheet_url = GetResponse().Url();
  if (sheet_url.IsLocalFile()) {
    if (parser_context) {
      parser_context->Count(WebFeature::kLocalCSSFile);
    }
    String extension;
    int last_dot = sheet_url.LastPathComponent().ReverseFind('.');
    if (last_dot != -1)
      extension = sheet_url.LastPathComponent().Substring(last_dot + 1);
    if (!EqualIgnoringASCIICase(
            MIMETypeRegistry::GetMIMETypeForExtension(extension), ""text/css"")) {
      if (parser_context) {
         parser_context->CountDeprecation(
             WebFeature::kLocalCSSFileExtensionRejected);
       }
      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {
        return false;
      }
     }
   }
 
  if (mime_type_check == MIMETypeCheck::kLax)
    return true;
  AtomicString content_type = HttpContentType();
  return content_type.IsEmpty() ||
         DeprecatedEqualIgnoringCase(content_type, ""text/css"") ||
         DeprecatedEqualIgnoringCase(content_type,
                                     ""application/x-unknown-content-type"");
}
","      if (RuntimeEnabledFeatures::RequireCSSExtensionForFileEnabled()) {
        return false;
      }
"
"void WebRuntimeFeatures::EnableRequireCSSExtensionForFile(bool enable) {
  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);
}
","  RuntimeEnabledFeatures::SetRequireCSSExtensionForFileEnabled(enable);
}
"
"void DownloadRequestLimiter::TabDownloadState::DidFinishNavigation(
    content::NavigationHandle* navigation_handle) {
  if (!navigation_handle->IsInMainFrame())
    return;

   if (status_ == ALLOW_ONE_DOWNLOAD ||
       (status_ == PROMPT_BEFORE_DOWNLOAD &&
       !navigation_handle->IsRendererInitiated())) {
    NotifyCallbacks(false);
    host_->Remove(this, web_contents());
  }
}
","       !navigation_handle->IsRendererInitiated())) {
"
"void DownloadRequestLimiter::TabDownloadState::DidStartNavigation(
    content::NavigationHandle* navigation_handle) {
  if (!navigation_handle->IsInMainFrame())
    return;

   download_seen_ = false;
   ui_status_ = DOWNLOAD_UI_DEFAULT;
 
  if (navigation_handle->IsRendererInitiated() &&
      (status_ == PROMPT_BEFORE_DOWNLOAD || status_ == DOWNLOADS_NOT_ALLOWED)) {
    return;
   }
 
   if (status_ == DownloadRequestLimiter::ALLOW_ALL_DOWNLOADS ||
      status_ == DownloadRequestLimiter::DOWNLOADS_NOT_ALLOWED) {
    if (!initial_page_host_.empty() &&
        navigation_handle->GetURL().host_piece() == initial_page_host_) {
      return;
    }
  }

  NotifyCallbacks(false);
  host_->Remove(this, web_contents());
}
","  if (navigation_handle->IsRendererInitiated() &&
      (status_ == PROMPT_BEFORE_DOWNLOAD || status_ == DOWNLOADS_NOT_ALLOWED)) {
    return;
"
"static NavigationPolicy NavigationPolicyForRequest(
    const FrameLoadRequest& request) {
   NavigationPolicy policy = kNavigationPolicyCurrentTab;
  Event* event = request.TriggeringEvent();
  if (!event)
    return policy;
  if (request.Form() && event->UnderlyingEvent())
    event = event->UnderlyingEvent();
   if (event->IsMouseEvent()) {
     MouseEvent* mouse_event = ToMouseEvent(event);
     NavigationPolicyFromMouseEvent(
        mouse_event->button(), mouse_event->ctrlKey(), mouse_event->shiftKey(),
        mouse_event->altKey(), mouse_event->metaKey(), &policy);
  } else if (event->IsKeyboardEvent()) {
    KeyboardEvent* key_event = ToKeyboardEvent(event);
    NavigationPolicyFromMouseEvent(0, key_event->ctrlKey(),
                                   key_event->shiftKey(), key_event->altKey(),
                                   key_event->metaKey(), &policy);
  } else if (event->IsGestureEvent()) {
    GestureEvent* gesture_event = ToGestureEvent(event);
    NavigationPolicyFromMouseEvent(
        0, gesture_event->ctrlKey(), gesture_event->shiftKey(),
        gesture_event->altKey(), gesture_event->metaKey(), &policy);
  }
   return policy;
 }
","    const FrameLoadRequest& request) {
  Event* event = request.TriggeringEvent();
  if (!event)
    return policy;
  if (request.Form() && event->UnderlyingEvent())
    event = event->UnderlyingEvent();
"
"NavigationPolicy EffectiveNavigationPolicy(NavigationPolicy policy,
                                           const WebInputEvent* current_event,
                                           const WebWindowFeatures& features) {
  if (policy == kNavigationPolicyIgnore)
    return GetNavigationPolicy(current_event, features);
   if (policy == kNavigationPolicyNewBackgroundTab &&
      GetNavigationPolicy(current_event, features) !=
          kNavigationPolicyNewBackgroundTab &&
       !UIEventWithKeyState::NewTabModifierSetFromIsolatedWorld()) {
     return kNavigationPolicyNewForegroundTab;
   }
   return policy;
 }
","                                           const WebInputEvent* current_event,
                                           const WebWindowFeatures& features) {
  if (policy == kNavigationPolicyIgnore)
    return GetNavigationPolicy(current_event, features);
      GetNavigationPolicy(current_event, features) !=
          kNavigationPolicyNewBackgroundTab &&
"
"NavigationPolicy GetNavigationPolicy(const WebInputEvent* current_event,
                                     const WebWindowFeatures& features) {
//// Check that the desired NavigationPolicy |policy| is compatible with the
//// observed input event |current_event|.
   bool as_popup = !features.tool_bar_visible || !features.status_bar_visible ||
                   !features.scrollbars_visible || !features.menu_bar_visible ||
                   !features.resizable;
  NavigationPolicy policy =
       as_popup ? kNavigationPolicyNewPopup : kNavigationPolicyNewForegroundTab;
  UpdatePolicyForEvent(current_event, &policy);
  return policy;
}
","                                     const WebWindowFeatures& features) {
  NavigationPolicy policy =
  UpdatePolicyForEvent(current_event, &policy);
  return policy;
}
"
"void UpdatePolicyForEvent(const WebInputEvent* input_event,
                          NavigationPolicy* policy) {
  if (!input_event)
    return;

  unsigned short button_number = 0;
  if (input_event->GetType() == WebInputEvent::kMouseUp) {
    const WebMouseEvent* mouse_event =
        static_cast<const WebMouseEvent*>(input_event);

    switch (mouse_event->button) {
      case WebMouseEvent::Button::kLeft:
        button_number = 0;
        break;
      case WebMouseEvent::Button::kMiddle:
        button_number = 1;
        break;
      case WebMouseEvent::Button::kRight:
        button_number = 2;
        break;
      default:
        return;
    }
  } else if ((WebInputEvent::IsKeyboardEventType(input_event->GetType()) &&
              static_cast<const WebKeyboardEvent*>(input_event)
                      ->windows_key_code == VKEY_RETURN) ||
             WebInputEvent::IsGestureEventType(input_event->GetType())) {
    button_number = 0;
  } else {
    return;
  }

  bool ctrl = input_event->GetModifiers() & WebInputEvent::kControlKey;
  bool shift = input_event->GetModifiers() & WebInputEvent::kShiftKey;
  bool alt = input_event->GetModifiers() & WebInputEvent::kAltKey;
  bool meta = input_event->GetModifiers() & WebInputEvent::kMetaKey;

  NavigationPolicy user_policy = *policy;
   NavigationPolicyFromMouseEvent(button_number, ctrl, shift, alt, meta,
                                  &user_policy);
 
  if (user_policy == kNavigationPolicyDownload &&
      *policy != kNavigationPolicyIgnore)
    return;
   if (user_policy == kNavigationPolicyNewWindow &&
      *policy == kNavigationPolicyNewPopup)
    return;
   *policy = user_policy;
 }
","  if (user_policy == kNavigationPolicyDownload &&
      *policy != kNavigationPolicyIgnore)
    return;
"
"void DocumentLoader::CommitNavigation(const AtomicString& mime_type,
                                      const KURL& overriding_url) {
  if (state_ != kProvisional)
    return;

  if (!GetFrameLoader().StateMachine()->CreatingInitialEmptyDocument()) {
    SetHistoryItemStateForCommit(
        GetFrameLoader().GetDocumentLoader()->GetHistoryItem(), load_type_,
        HistoryNavigationType::kDifferentDocument);
  }

  DCHECK_EQ(state_, kProvisional);
  GetFrameLoader().CommitProvisionalLoad();
  if (!frame_)
    return;

  const AtomicString& encoding = GetResponse().TextEncodingName();

  Document* owner_document = nullptr;
  if (Document::ShouldInheritSecurityOriginFromOwner(Url())) {
    Frame* owner_frame = frame_->Tree().Parent();
    if (!owner_frame)
      owner_frame = frame_->Loader().Opener();
    if (owner_frame && owner_frame->IsLocalFrame())
      owner_document = ToLocalFrame(owner_frame)->GetDocument();
  }
  DCHECK(frame_->GetPage());

  ParserSynchronizationPolicy parsing_policy = kAllowAsynchronousParsing;
   if (!Document::ThreadedParsingEnabledForTesting())
     parsing_policy = kForceSynchronousParsing;
 
  InstallNewDocument(Url(), owner_document,
                     frame_->ShouldReuseDefaultView(Url())
                         ? WebGlobalObjectReusePolicy::kUseExisting
                         : WebGlobalObjectReusePolicy::kCreateNew,
                     mime_type, encoding, InstallNewDocumentReason::kNavigation,
                     parsing_policy, overriding_url);
   parser_->SetDocumentWasLoadedAsPartOfNavigation();
   if (request_.WasDiscarded())
     frame_->GetDocument()->SetWasDiscarded(true);
  frame_->GetDocument()->MaybeHandleHttpRefresh(
      response_.HttpHeaderField(HTTPNames::Refresh),
      Document::kHttpRefreshFromHeader);
}
","  InstallNewDocument(Url(), owner_document,
                     frame_->ShouldReuseDefaultView(Url())
                         ? WebGlobalObjectReusePolicy::kUseExisting
                         : WebGlobalObjectReusePolicy::kCreateNew,
                     mime_type, encoding, InstallNewDocumentReason::kNavigation,
                     parsing_policy, overriding_url);
"
"void FrameLoader::ReplaceDocumentWhileExecutingJavaScriptURL(
    const String& source,
    Document* owner_document) {
  Document* document = frame_->GetDocument();
  if (!document_loader_ ||
      document->PageDismissalEventBeingDispatched() != Document::kNoDismissal)
    return;

  UseCounter::Count(*document, WebFeature::kReplaceDocumentViaJavaScriptURL);

  const KURL& url = document->Url();
 
   WebGlobalObjectReusePolicy global_object_reuse_policy =
      frame_->ShouldReuseDefaultView(url)
           ? WebGlobalObjectReusePolicy::kUseExisting
           : WebGlobalObjectReusePolicy::kCreateNew;
 
  StopAllLoaders();
  SubframeLoadingDisabler disabler(document);
  frame_->DetachChildren();

  if (!frame_->IsAttached() || document != frame_->GetDocument())
    return;

  frame_->GetDocument()->Shutdown();
  Client()->TransitionToCommittedForNewPage();
  document_loader_->ReplaceDocumentWhileExecutingJavaScriptURL(
      url, owner_document, global_object_reuse_policy, source);
}
","      frame_->ShouldReuseDefaultView(url)
"
"void AutofillManager::OnQueryFormFieldAutofillImpl(
    int query_id,
    const FormData& form,
    const FormFieldData& field,
    const gfx::RectF& transformed_box,
    bool autoselect_first_suggestion) {
  external_delegate_->OnQuery(query_id, form, field, transformed_box);

  std::vector<Suggestion> suggestions;
  SuggestionsContext context;
  GetAvailableSuggestions(form, field, &suggestions, &context);

  if (context.is_autofill_available) {
    switch (context.suppress_reason) {
      case SuppressReason::kNotSuppressed:
        break;

      case SuppressReason::kCreditCardsAblation:
        enable_ablation_logging_ = true;
        autocomplete_history_manager_->CancelPendingQuery();
        external_delegate_->OnSuggestionsReturned(query_id, suggestions,
                                                  autoselect_first_suggestion);
        return;

      case SuppressReason::kAutocompleteOff:
        return;
    }

    if (!suggestions.empty()) {
      if (context.is_filling_credit_card) {
        AutofillMetrics::LogIsQueriedCreditCardFormSecure(
            context.is_context_secure);
      }

      if (!has_logged_address_suggestions_count_ &&
          !context.section_has_autofilled_field) {
         AutofillMetrics::LogAddressSuggestionsCount(suggestions.size());
         has_logged_address_suggestions_count_ = true;
       }
    }
  }

  if (suggestions.empty() && !ShouldShowCreditCardSigninPromo(form, field) &&
      field.should_autocomplete &&
      !(context.focused_field &&
        (IsCreditCardExpirationType(
             context.focused_field->Type().GetStorableType()) ||
         context.focused_field->Type().html_type() == HTML_TYPE_UNRECOGNIZED ||
         context.focused_field->Type().GetStorableType() ==
             CREDIT_CARD_NUMBER ||
         context.focused_field->Type().GetStorableType() ==
             CREDIT_CARD_VERIFICATION_CODE))) {
    autocomplete_history_manager_->OnGetAutocompleteSuggestions(
        query_id, field.name, field.value, field.form_control_type);
    return;
  }

  autocomplete_history_manager_->CancelPendingQuery();
  external_delegate_->OnSuggestionsReturned(query_id, suggestions,
                                            autoselect_first_suggestion,
                                            context.is_all_server_suggestions);
}
","      if (!has_logged_address_suggestions_count_ &&
          !context.section_has_autofilled_field) {
"
"bool SectionHasAutofilledField(const FormStructure& form_structure,
                               const FormData& form,
                               const std::string& section) {
  DCHECK_EQ(form_structure.field_count(), form.fields.size());
  for (size_t i = 0; i < form_structure.field_count(); ++i) {
    if (form_structure.field(i)->section == section &&
        form.fields[i].is_autofilled) {
      return true;
    }
  }
  return false;
}
","                               const FormData& form,
                               const std::string& section) {
  DCHECK_EQ(form_structure.field_count(), form.fields.size());
  for (size_t i = 0; i < form_structure.field_count(); ++i) {
    if (form_structure.field(i)->section == section &&
        form.fields[i].is_autofilled) {
      return true;
    }
  }
  return false;
}
"
"WindowOpenDisposition BrowserView::GetDispositionForPopupBounds(
    const gfx::Rect& bounds) {
  return WindowOpenDisposition::NEW_POPUP;
}
","    const gfx::Rect& bounds) {
  return WindowOpenDisposition::NEW_POPUP;
}
"
"WindowOpenDisposition TestBrowserWindow::GetDispositionForPopupBounds(
    const gfx::Rect& bounds) {
  return WindowOpenDisposition::NEW_POPUP;
}
","    const gfx::Rect& bounds) {
  return WindowOpenDisposition::NEW_POPUP;
}
"
"bool PlatformFontSkia::InitDefaultFont() {
  if (g_default_font.Get())
    return true;
 
   bool success = false;
   std::string family = kFallbackFontFamilyName;
  int size_pixels = 12;
   int style = Font::NORMAL;
   Font::Weight weight = Font::Weight::NORMAL;
   FontRenderParams params;

  const SkiaFontDelegate* delegate = SkiaFontDelegate::instance();
  if (delegate) {
    delegate->GetDefaultFontDescription(&family, &size_pixels, &style, &weight,
                                        &params);
  } else if (default_font_description_) {
#if defined(OS_CHROMEOS)
    FontRenderParamsQuery query;
    CHECK(FontList::ParseDescription(*default_font_description_,
                                     &query.families, &query.style,
                                     &query.pixel_size, &query.weight))
        << ""Failed to parse font description "" << *default_font_description_;
    params = gfx::GetFontRenderParams(query, &family);
    size_pixels = query.pixel_size;
    style = query.style;
    weight = query.weight;
#else
    NOTREACHED();
#endif
  }

  sk_sp<SkTypeface> typeface =
      CreateSkTypeface(style & Font::ITALIC, weight, &family, &success);
  if (!success)
    return false;
  g_default_font.Get() = new PlatformFontSkia(
      std::move(typeface), family, size_pixels, style, weight, params);
  return true;
}
","  int size_pixels = 12;
"
"bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
    const GURL& document_url,
    std::string* error) {
  if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
    if (error)
      *error = errors::kCannotScriptGallery;
     return true;
   }
 
  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
     if (error)
       *error = errors::kCannotScriptNtp;
     return true;
  }

  return false;
}
","  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
"
" CoordinatorImpl::CoordinatorImpl(service_manager::Connector* connector)
     : next_dump_id_(0),
      client_process_timeout_(base::TimeDelta::FromSeconds(15)) {
   process_map_ = std::make_unique<ProcessMap>(connector);
   DCHECK(!g_coordinator_impl);
   g_coordinator_impl = this;
  base::trace_event::MemoryDumpManager::GetInstance()->set_tracing_process_id(
      mojom::kServiceTracingProcessId);

  tracing_observer_ = std::make_unique<TracingObserver>(
      base::trace_event::TraceLog::GetInstance(), nullptr);
}
","      client_process_timeout_(base::TimeDelta::FromSeconds(15)) {
"
"void CoordinatorImpl::FinalizeGlobalMemoryDumpIfAllManagersReplied() {
  TRACE_EVENT0(base::trace_event::MemoryDumpManager::kTraceCategory,
               ""GlobalMemoryDump.Computation"");
  DCHECK(!queued_memory_dump_requests_.empty());

  QueuedRequest* request = &queued_memory_dump_requests_.front();
  if (!request->dump_in_progress || request->pending_responses.size() > 0 ||
      request->heap_dump_in_progress) {
    return;
  }

  QueuedRequestDispatcher::Finalize(request, tracing_observer_.get());

  queued_memory_dump_requests_.pop_front();
  request = nullptr;

  if (!queued_memory_dump_requests_.empty()) {
     base::SequencedTaskRunnerHandle::Get()->PostTask(
         FROM_HERE,
         base::BindOnce(&CoordinatorImpl::PerformNextQueuedGlobalMemoryDump,
                       base::Unretained(this)));
   }
 }
","                       base::Unretained(this)));
"
"void CoordinatorImpl::GetVmRegionsForHeapProfiler(
    const std::vector<base::ProcessId>& pids,
    GetVmRegionsForHeapProfilerCallback callback) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  uint64_t dump_guid = ++next_dump_id_;
  std::unique_ptr<QueuedVmRegionRequest> request =
      std::make_unique<QueuedVmRegionRequest>(dump_guid, std::move(callback));
  in_progress_vm_region_requests_[dump_guid] = std::move(request);

  std::vector<QueuedRequestDispatcher::ClientInfo> clients;
  for (const auto& kv : clients_) {
    auto client_identity = kv.second->identity;
    const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);
    clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);
  }

  QueuedVmRegionRequest* request_ptr =
       in_progress_vm_region_requests_[dump_guid].get();
   auto os_callback =
       base::BindRepeating(&CoordinatorImpl::OnOSMemoryDumpForVMRegions,
                          base::Unretained(this), dump_guid);
   QueuedRequestDispatcher::SetUpAndDispatchVmRegionRequest(request_ptr, clients,
                                                            pids, os_callback);
   FinalizeVmRegionDumpIfAllManagersReplied(dump_guid);
}
","                          base::Unretained(this), dump_guid);
"
"void CoordinatorImpl::PerformNextQueuedGlobalMemoryDump() {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
  QueuedRequest* request = GetCurrentRequest();

  if (request == nullptr)
    return;

  std::vector<QueuedRequestDispatcher::ClientInfo> clients;
  for (const auto& kv : clients_) {
    auto client_identity = kv.second->identity;
    const base::ProcessId pid = GetProcessIdForClientIdentity(client_identity);
    if (pid == base::kNullProcessId) {
      VLOG(1) << ""Couldn't find a PID for client \"""" << client_identity.name()
              << ""."" << client_identity.instance() << ""\"""";
      continue;
    }
     clients.emplace_back(kv.second->client.get(), pid, kv.second->process_type);
   }
 
  auto chrome_callback = base::Bind(
      &CoordinatorImpl::OnChromeMemoryDumpResponse, base::Unretained(this));
  auto os_callback = base::Bind(&CoordinatorImpl::OnOSMemoryDumpResponse,
                                base::Unretained(this), request->dump_guid);
   QueuedRequestDispatcher::SetUpAndDispatch(request, clients, chrome_callback,
                                             os_callback);
 
   base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
       FROM_HERE,
       base::BindOnce(&CoordinatorImpl::OnQueuedRequestTimedOut,
                     base::Unretained(this), request->dump_guid),
       client_process_timeout_);
 
   if (request->args.add_to_trace && heap_profiler_) {
    request->heap_dump_in_progress = true;

    bool strip_path_from_mapped_files =
        base::trace_event::TraceLog::GetInstance()
            ->GetCurrentTraceConfig()
             .IsArgumentFilterEnabled();
     heap_profiler_->DumpProcessesForTracing(
         strip_path_from_mapped_files,
            base::BindRepeating(&CoordinatorImpl::OnDumpProcessesForTracing,
                           base::Unretained(this), request->dump_guid));
 
     base::SequencedTaskRunnerHandle::Get()->PostDelayedTask(
         FROM_HERE,
         base::BindOnce(&CoordinatorImpl::OnHeapDumpTimeOut,
                       base::Unretained(this), request->dump_guid),
         kHeapDumpTimeout);
   }
 
  FinalizeGlobalMemoryDumpIfAllManagersReplied();
}
","  auto chrome_callback = base::Bind(
      &CoordinatorImpl::OnChromeMemoryDumpResponse, base::Unretained(this));
  auto os_callback = base::Bind(&CoordinatorImpl::OnOSMemoryDumpResponse,
                                base::Unretained(this), request->dump_guid);
                     base::Unretained(this), request->dump_guid),
            base::BindRepeating(&CoordinatorImpl::OnDumpProcessesForTracing,
                           base::Unretained(this), request->dump_guid));
                       base::Unretained(this), request->dump_guid),
"
"void CoordinatorImpl::RegisterClientProcess(
    mojom::ClientProcessPtr client_process_ptr,
    mojom::ProcessType process_type) {
  DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   mojom::ClientProcess* client_process = client_process_ptr.get();
   client_process_ptr.set_connection_error_handler(
       base::BindOnce(&CoordinatorImpl::UnregisterClientProcess,
                     base::Unretained(this), client_process));
   auto identity = GetClientIdentityForCurrentRequest();
   auto client_info = std::make_unique<ClientInfo>(
       std::move(identity), std::move(client_process_ptr), process_type);
  auto iterator_and_inserted =
      clients_.emplace(client_process, std::move(client_info));
  DCHECK(iterator_and_inserted.second);
}
","                     base::Unretained(this), client_process));
"
"void CoordinatorImpl::UnregisterClientProcess(
    mojom::ClientProcess* client_process) {
  QueuedRequest* request = GetCurrentRequest();
  if (request != nullptr) {
    auto it = request->pending_responses.begin();
    while (it != request->pending_responses.end()) {
      std::set<QueuedRequest::PendingResponse>::iterator current = it++;
      if (current->client != client_process)
        continue;
      RemovePendingResponse(client_process, current->type);
      request->failed_memory_dump_count++;
    }
    FinalizeGlobalMemoryDumpIfAllManagersReplied();
  }

  for (auto& pair : in_progress_vm_region_requests_) {
    QueuedVmRegionRequest* request = pair.second.get();
    auto it = request->pending_responses.begin();
    while (it != request->pending_responses.end()) {
      auto current = it++;
      if (*current == client_process) {
        request->pending_responses.erase(current);
      }
    }
  }

  for (auto& pair : in_progress_vm_region_requests_) {
    base::SequencedTaskRunnerHandle::Get()->PostTask(
         FROM_HERE,
         base::BindOnce(
             &CoordinatorImpl::FinalizeVmRegionDumpIfAllManagersReplied,
            base::Unretained(this), pair.second->dump_guid));
   }
 
   size_t num_deleted = clients_.erase(client_process);
  DCHECK(num_deleted == 1);
}
","            base::Unretained(this), pair.second->dump_guid));
"
"FileReaderLoader::FileReaderLoader(ReadType read_type,
                                   FileReaderLoaderClient* client)
    : read_type_(read_type),
      client_(client),
       handle_watcher_(FROM_HERE, mojo::SimpleWatcher::ArmingPolicy::AUTOMATIC),
      binding_(this) {}
","      binding_(this) {}
"
"static int _hid_class_request(struct hid_device_priv* dev, HANDLE hid_handle, int request_type,
							  int request, int value, int _index, void *data, struct windows_transfer_priv *tp,
							  size_t *size, OVERLAPPED* overlapped)
{
	int report_type = (value >> 8) & 0xFF;
	int report_id = value & 0xFF;
	if ( (LIBUSB_REQ_RECIPIENT(request_type) != LIBUSB_RECIPIENT_INTERFACE)
	  && (LIBUSB_REQ_RECIPIENT(request_type) != LIBUSB_RECIPIENT_DEVICE) )
		return LIBUSB_ERROR_INVALID_PARAM;
	if (LIBUSB_REQ_OUT(request_type) && request == HID_REQ_SET_REPORT)
		return _hid_set_report(dev, hid_handle, report_id, data, tp, size, overlapped, report_type);
	if (LIBUSB_REQ_IN(request_type) && request == HID_REQ_GET_REPORT)
		return _hid_get_report(dev, hid_handle, report_id, data, tp, size, overlapped, report_type);
	return LIBUSB_ERROR_INVALID_PARAM;
}
","							  int request, int value, int _index, void *data, struct windows_transfer_priv *tp,
							  size_t *size, OVERLAPPED* overlapped)
{
	int report_type = (value >> 8) & 0xFF;
	int report_id = value & 0xFF;
	if ( (LIBUSB_REQ_RECIPIENT(request_type) != LIBUSB_RECIPIENT_INTERFACE)
	  && (LIBUSB_REQ_RECIPIENT(request_type) != LIBUSB_RECIPIENT_DEVICE) )
		return LIBUSB_ERROR_INVALID_PARAM;
	if (LIBUSB_REQ_OUT(request_type) && request == HID_REQ_SET_REPORT)
		return _hid_set_report(dev, hid_handle, report_id, data, tp, size, overlapped, report_type);
	if (LIBUSB_REQ_IN(request_type) && request == HID_REQ_GET_REPORT)
		return _hid_get_report(dev, hid_handle, report_id, data, tp, size, overlapped, report_type);
	return LIBUSB_ERROR_INVALID_PARAM;
}
"
"static int _hid_get_descriptor(struct hid_device_priv* dev, HANDLE hid_handle, int recipient,
							   int type, int _index, void *data, size_t *size)
{
	switch(type) {
	case LIBUSB_DT_DEVICE:
		usbi_dbg(""LIBUSB_DT_DEVICE"");
		return _hid_get_device_descriptor(dev, data, size);
	case LIBUSB_DT_CONFIG:
		usbi_dbg(""LIBUSB_DT_CONFIG"");
		if (!_index)
			return _hid_get_config_descriptor(dev, data, size);
		return LIBUSB_ERROR_INVALID_PARAM;
	case LIBUSB_DT_STRING:
		usbi_dbg(""LIBUSB_DT_STRING"");
		return _hid_get_string_descriptor(dev, _index, data, size);
	case LIBUSB_DT_HID:
		usbi_dbg(""LIBUSB_DT_HID"");
		if (!_index)
			return _hid_get_hid_descriptor(dev, data, size);
		return LIBUSB_ERROR_INVALID_PARAM;
	case LIBUSB_DT_REPORT:
		usbi_dbg(""LIBUSB_DT_REPORT"");
		if (!_index)
			return _hid_get_report_descriptor(dev, data, size);
		return LIBUSB_ERROR_INVALID_PARAM;
	case LIBUSB_DT_PHYSICAL:
		usbi_dbg(""LIBUSB_DT_PHYSICAL"");
		if (HidD_GetPhysicalDescriptor(hid_handle, data, (ULONG)*size))
			return LIBUSB_COMPLETED;
		return LIBUSB_ERROR_OTHER;
	}
	usbi_dbg(""unsupported"");
	return LIBUSB_ERROR_INVALID_PARAM;
}
","							   int type, int _index, void *data, size_t *size)
{
	switch(type) {
	case LIBUSB_DT_DEVICE:
		usbi_dbg(""LIBUSB_DT_DEVICE"");
		return _hid_get_device_descriptor(dev, data, size);
	case LIBUSB_DT_CONFIG:
		usbi_dbg(""LIBUSB_DT_CONFIG"");
		if (!_index)
			return _hid_get_config_descriptor(dev, data, size);
		return LIBUSB_ERROR_INVALID_PARAM;
	case LIBUSB_DT_STRING:
		usbi_dbg(""LIBUSB_DT_STRING"");
		return _hid_get_string_descriptor(dev, _index, data, size);
	case LIBUSB_DT_HID:
		usbi_dbg(""LIBUSB_DT_HID"");
		if (!_index)
			return _hid_get_hid_descriptor(dev, data, size);
		return LIBUSB_ERROR_INVALID_PARAM;
	case LIBUSB_DT_REPORT:
		usbi_dbg(""LIBUSB_DT_REPORT"");
		if (!_index)
			return _hid_get_report_descriptor(dev, data, size);
		return LIBUSB_ERROR_INVALID_PARAM;
	case LIBUSB_DT_PHYSICAL:
		usbi_dbg(""LIBUSB_DT_PHYSICAL"");
		if (HidD_GetPhysicalDescriptor(hid_handle, data, (ULONG)*size))
			return LIBUSB_COMPLETED;
		return LIBUSB_ERROR_OTHER;
	}
	usbi_dbg(""unsupported"");
	return LIBUSB_ERROR_INVALID_PARAM;
}
"
"static int _hid_get_device_descriptor(struct hid_device_priv* dev, void *data, size_t *size)
{
	struct libusb_device_descriptor d;
	d.bLength = LIBUSB_DT_DEVICE_SIZE;
	d.bDescriptorType = LIBUSB_DT_DEVICE;
	d.bcdUSB = 0x0200; /* 2.00 */
	d.bDeviceClass = 0;
	d.bDeviceSubClass = 0;
	d.bDeviceProtocol = 0;
	d.bMaxPacketSize0 = 64; /* fix this! */
	d.idVendor = (uint16_t)dev->vid;
	d.idProduct = (uint16_t)dev->pid;
	d.bcdDevice = 0x0100;
	d.iManufacturer = dev->string_index[0];
	d.iProduct = dev->string_index[1];
	d.iSerialNumber = dev->string_index[2];
	d.bNumConfigurations = 1;
	if (*size > LIBUSB_DT_DEVICE_SIZE)
		*size = LIBUSB_DT_DEVICE_SIZE;
	memcpy(data, &d, *size);
	return LIBUSB_COMPLETED;
}
","{
	struct libusb_device_descriptor d;
	d.bLength = LIBUSB_DT_DEVICE_SIZE;
	d.bDescriptorType = LIBUSB_DT_DEVICE;
	d.bcdUSB = 0x0200; /* 2.00 */
	d.bDeviceClass = 0;
	d.bDeviceSubClass = 0;
	d.bDeviceProtocol = 0;
	d.bMaxPacketSize0 = 64; /* fix this! */
	d.idVendor = (uint16_t)dev->vid;
	d.idProduct = (uint16_t)dev->pid;
	d.bcdDevice = 0x0100;
	d.iManufacturer = dev->string_index[0];
	d.iProduct = dev->string_index[1];
	d.iSerialNumber = dev->string_index[2];
	d.bNumConfigurations = 1;
	if (*size > LIBUSB_DT_DEVICE_SIZE)
		*size = LIBUSB_DT_DEVICE_SIZE;
	memcpy(data, &d, *size);
	return LIBUSB_COMPLETED;
}
"
"static int _hid_get_hid_descriptor(struct hid_device_priv* dev, void *data, size_t *size)
{
	struct libusb_hid_descriptor d;
	uint8_t tmp[MAX_HID_DESCRIPTOR_SIZE];
	size_t report_len = MAX_HID_DESCRIPTOR_SIZE;
	_hid_get_report_descriptor(dev, tmp, &report_len);
	d.bLength = LIBUSB_DT_HID_SIZE;
	d.bDescriptorType = LIBUSB_DT_HID;
	d.bcdHID = 0x0110; /* 1.10 */
	d.bCountryCode = 0;
	d.bNumDescriptors = 1;
	d.bClassDescriptorType = LIBUSB_DT_REPORT;
	d.wClassDescriptorLength = (uint16_t)report_len;
	if (*size > LIBUSB_DT_HID_SIZE)
		*size = LIBUSB_DT_HID_SIZE;
	memcpy(data, &d, *size);
	return LIBUSB_COMPLETED;
}
","{
	struct libusb_hid_descriptor d;
	uint8_t tmp[MAX_HID_DESCRIPTOR_SIZE];
	size_t report_len = MAX_HID_DESCRIPTOR_SIZE;
	_hid_get_report_descriptor(dev, tmp, &report_len);
	d.bLength = LIBUSB_DT_HID_SIZE;
	d.bDescriptorType = LIBUSB_DT_HID;
	d.bcdHID = 0x0110; /* 1.10 */
	d.bCountryCode = 0;
	d.bNumDescriptors = 1;
	d.bClassDescriptorType = LIBUSB_DT_REPORT;
	d.wClassDescriptorLength = (uint16_t)report_len;
	if (*size > LIBUSB_DT_HID_SIZE)
		*size = LIBUSB_DT_HID_SIZE;
	memcpy(data, &d, *size);
	return LIBUSB_COMPLETED;
}
"
"static int _hid_get_string_descriptor(struct hid_device_priv* dev, int _index,
									  void *data, size_t *size)
{
	void *tmp = NULL;
	size_t tmp_size = 0;
	int i;
	/* language ID, EN-US */
	char string_langid[] = {
		0x09,
		0x04
	};
	if ((*size < 2) || (*size > 255)) {
		return LIBUSB_ERROR_OVERFLOW;
	}
	if (_index == 0) {
		tmp = string_langid;
		tmp_size = sizeof(string_langid)+2;
	} else {
		for (i=0; i<3; i++) {
			if (_index == (dev->string_index[i])) {
				tmp = dev->string[i];
				tmp_size = (_hid_wcslen(dev->string[i])+1) * sizeof(WCHAR);
				break;
			}
		}
		if (i == 3) {	// not found
			return LIBUSB_ERROR_INVALID_PARAM;
		}
	}
	if(!tmp_size) {
		return LIBUSB_ERROR_INVALID_PARAM;
	}
	if (tmp_size < *size) {
		*size = tmp_size;
	}
	((uint8_t*)data)[0] = (uint8_t)*size;
	((uint8_t*)data)[1] = LIBUSB_DT_STRING;
	memcpy((uint8_t*)data+2, tmp, *size-2);
	return LIBUSB_COMPLETED;
}
","									  void *data, size_t *size)
{
	void *tmp = NULL;
	size_t tmp_size = 0;
	int i;
	/* language ID, EN-US */
	char string_langid[] = {
		0x09,
		0x04
	};
	if ((*size < 2) || (*size > 255)) {
		return LIBUSB_ERROR_OVERFLOW;
	}
	if (_index == 0) {
		tmp = string_langid;
		tmp_size = sizeof(string_langid)+2;
	} else {
		for (i=0; i<3; i++) {
			if (_index == (dev->string_index[i])) {
				tmp = dev->string[i];
				tmp_size = (_hid_wcslen(dev->string[i])+1) * sizeof(WCHAR);
				break;
			}
		}
		if (i == 3) {	// not found
			return LIBUSB_ERROR_INVALID_PARAM;
		}
	}
	if(!tmp_size) {
		return LIBUSB_ERROR_INVALID_PARAM;
	}
	if (tmp_size < *size) {
		*size = tmp_size;
	}
	((uint8_t*)data)[0] = (uint8_t)*size;
	((uint8_t*)data)[1] = LIBUSB_DT_STRING;
	memcpy((uint8_t*)data+2, tmp, *size-2);
	return LIBUSB_COMPLETED;
}
"
"static int _hid_wcslen(WCHAR *str)
{
	int i = 0;
	while (str[i] && (str[i] != 0x409)) {
		i++;
	}
	return i;
}
","{
	int i = 0;
	while (str[i] && (str[i] != 0x409)) {
		i++;
	}
	return i;
}
"
"static int auto_claim(struct libusb_transfer *transfer, int *interface_number, int api_type)
{
	struct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(
		transfer->dev_handle);
	struct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);
	int current_interface = *interface_number;
	int r = LIBUSB_SUCCESS;
 
 	switch(api_type) {
 	case USB_API_WINUSBX:
	case USB_API_HID:
 		break;
 	default:
 		return LIBUSB_ERROR_INVALID_PARAM;
	}

	usbi_mutex_lock(&autoclaim_lock);
	if (current_interface < 0)	// No serviceable interface was found
	{
		for (current_interface=0; current_interface<USB_MAXINTERFACES; current_interface++) {
			if ( (priv->usb_interface[current_interface].apib->id == api_type)
			  && (libusb_claim_interface(transfer->dev_handle, current_interface) == LIBUSB_SUCCESS) ) {
				usbi_dbg(""auto-claimed interface %d for control request"", current_interface);
				if (handle_priv->autoclaim_count[current_interface] != 0) {
					usbi_warn(ctx, ""program assertion failed - autoclaim_count was nonzero"");
				}
				handle_priv->autoclaim_count[current_interface]++;
				break;
			}
		}
		if (current_interface == USB_MAXINTERFACES) {
			usbi_err(ctx, ""could not auto-claim any interface"");
			r = LIBUSB_ERROR_NOT_FOUND;
		}
	} else {
		if (handle_priv->autoclaim_count[current_interface] != 0) {
			handle_priv->autoclaim_count[current_interface]++;
		}
	}
	usbi_mutex_unlock(&autoclaim_lock);

	*interface_number = current_interface;
	return r;

}
","	case USB_API_HID:
"
"static void composite_close(int sub_api, struct libusb_device_handle *dev_handle)
{
 	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
 	uint8_t i;
 	bool available[SUB_API_MAX];
	bool has_hid = false;
 
 	for (i = 0; i<SUB_API_MAX; i++) {
 		available[i] = false;
	}

	for (i=0; i<USB_MAXINTERFACES; i++) {
 		if ( (priv->usb_interface[i].apib->id == USB_API_WINUSBX)
 		  && (priv->usb_interface[i].sub_api != SUB_API_NOTSET) ) {
 			available[priv->usb_interface[i].sub_api] = true;
		} else if (priv->usb_interface[i].apib->id == USB_API_HID) {
			has_hid = true;
 		}
 	}
 
	for (i=0; i<SUB_API_MAX; i++) {
		if (available[i]) {
 			usb_api_backend[USB_API_WINUSBX].close(i, dev_handle);
 		}
 	}
	if (has_hid) {
		usb_api_backend[USB_API_HID].close(sub_api, dev_handle);
	}
 }
","	bool has_hid = false;
		} else if (priv->usb_interface[i].apib->id == USB_API_HID) {
			has_hid = true;
	if (has_hid) {
		usb_api_backend[USB_API_HID].close(sub_api, dev_handle);
	}
"
"static int composite_open(int sub_api, struct libusb_device_handle *dev_handle)
{
 	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
 	int r = LIBUSB_ERROR_NOT_FOUND;
 	uint8_t i;
	bool available[SUB_API_MAX+1] = {0};
 
 	for (i=0; i<USB_MAXINTERFACES; i++) {
 		switch (priv->usb_interface[i].apib->id) {
 		case USB_API_WINUSBX:
 			if (priv->usb_interface[i].sub_api != SUB_API_NOTSET)
 				available[priv->usb_interface[i].sub_api] = true;
 			break;
		case USB_API_HID:
			available[SUB_API_MAX] = true;
			break;
 		default:
 			break;
 		}
	}

	for (i=0; i<SUB_API_MAX; i++) {	// WinUSB-like drivers
		if (available[i]) {
			r = usb_api_backend[USB_API_WINUSBX].open(i, dev_handle);
			if (r != LIBUSB_SUCCESS) {
				return r;
 			}
 		}
 	}
	if (available[SUB_API_MAX]) {	// HID driver
		r = hid_open(SUB_API_NOTSET, dev_handle);
	}
 	return r;
 }
","	bool available[SUB_API_MAX+1] = {0};
		case USB_API_HID:
			available[SUB_API_MAX] = true;
			break;
	if (available[SUB_API_MAX]) {	// HID driver
		r = hid_open(SUB_API_NOTSET, dev_handle);
	}
"
"static int get_valid_interface(struct libusb_device_handle *dev_handle, int api_id)
{
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
 	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
 	int i;
 
	if ((api_id < USB_API_WINUSBX) || (api_id > USB_API_HID)) {
 		usbi_dbg(""unsupported API ID"");
 		return -1;
 	}

	for (i=0; i<USB_MAXINTERFACES; i++) {
		if ( (handle_priv->interface_handle[i].dev_handle != 0)
		  && (handle_priv->interface_handle[i].dev_handle != INVALID_HANDLE_VALUE)
		  && (handle_priv->interface_handle[i].api_handle != 0)
		  && (handle_priv->interface_handle[i].api_handle != INVALID_HANDLE_VALUE)
		  && (priv->usb_interface[i].apib->id == api_id) ) {
			return i;
		}
	}
	return -1;
}
","	if ((api_id < USB_API_WINUSBX) || (api_id > USB_API_HID)) {
"
"static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)
{
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = transfer_priv->interface_number;
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	CancelIo(hid_handle);
	return LIBUSB_SUCCESS;
}
","{
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = transfer_priv->interface_number;
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	CancelIo(hid_handle);
	return LIBUSB_SUCCESS;
}
"
"static int hid_claim_interface(int sub_api, struct libusb_device_handle *dev_handle, int iface)
{
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	CHECK_HID_AVAILABLE;
	if (priv->usb_interface[iface].path == NULL) {
		return LIBUSB_ERROR_NOT_FOUND;	// invalid iface
	}
	if (handle_priv->interface_handle[iface].dev_handle == INTERFACE_CLAIMED) {
		return LIBUSB_ERROR_BUSY;	// already claimed
	}
	handle_priv->interface_handle[iface].dev_handle = INTERFACE_CLAIMED;
	usbi_dbg(""claimed interface %d"", iface);
	handle_priv->active_interface = iface;
	return LIBUSB_SUCCESS;
}
","{
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	CHECK_HID_AVAILABLE;
	if (priv->usb_interface[iface].path == NULL) {
		return LIBUSB_ERROR_NOT_FOUND;	// invalid iface
	}
	if (handle_priv->interface_handle[iface].dev_handle == INTERFACE_CLAIMED) {
		return LIBUSB_ERROR_BUSY;	// already claimed
	}
	handle_priv->interface_handle[iface].dev_handle = INTERFACE_CLAIMED;
	usbi_dbg(""claimed interface %d"", iface);
	handle_priv->active_interface = iface;
	return LIBUSB_SUCCESS;
}
"
"static int hid_clear_halt(int sub_api, struct libusb_device_handle *dev_handle, unsigned char endpoint)
{
	struct libusb_context *ctx = DEVICE_CTX(dev_handle->dev);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = interface_by_endpoint(priv, handle_priv, endpoint);
	if (current_interface < 0) {
		usbi_err(ctx, ""unable to match endpoint to an open interface - cannot clear"");
		return LIBUSB_ERROR_NOT_FOUND;
	}
	usbi_dbg(""matched endpoint %02X with interface %d"", endpoint, current_interface);
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	if (!HidD_FlushQueue(hid_handle)) {
		usbi_err(ctx, ""Flushing of HID queue failed: %s"", windows_error_str(0));
		return LIBUSB_ERROR_NO_DEVICE;
	}
	return LIBUSB_SUCCESS;
}
","{
	struct libusb_context *ctx = DEVICE_CTX(dev_handle->dev);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = interface_by_endpoint(priv, handle_priv, endpoint);
	if (current_interface < 0) {
		usbi_err(ctx, ""unable to match endpoint to an open interface - cannot clear"");
		return LIBUSB_ERROR_NOT_FOUND;
	}
	usbi_dbg(""matched endpoint %02X with interface %d"", endpoint, current_interface);
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	if (!HidD_FlushQueue(hid_handle)) {
		usbi_err(ctx, ""Flushing of HID queue failed: %s"", windows_error_str(0));
		return LIBUSB_ERROR_NO_DEVICE;
	}
	return LIBUSB_SUCCESS;
}
"
"static void hid_close(int sub_api, struct libusb_device_handle *dev_handle)
{
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	HANDLE file_handle;
	int i;
	if (!api_hid_available)
		return;
	for (i = 0; i < USB_MAXINTERFACES; i++) {
		if (priv->usb_interface[i].apib->id == USB_API_HID) {
			file_handle = handle_priv->interface_handle[i].api_handle;
			if ( (file_handle != 0) && (file_handle != INVALID_HANDLE_VALUE)) {
				CloseHandle(file_handle);
			}
		}
	}
}
","{
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	HANDLE file_handle;
	int i;
	if (!api_hid_available)
		return;
	for (i = 0; i < USB_MAXINTERFACES; i++) {
		if (priv->usb_interface[i].apib->id == USB_API_HID) {
			file_handle = handle_priv->interface_handle[i].api_handle;
			if ( (file_handle != 0) && (file_handle != INVALID_HANDLE_VALUE)) {
				CloseHandle(file_handle);
			}
		}
	}
}
"
"static int hid_copy_transfer_data(int sub_api, struct usbi_transfer *itransfer, uint32_t io_size) {
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);
	struct windows_transfer_priv *transfer_priv = usbi_transfer_get_os_priv(itransfer);
	int r = LIBUSB_TRANSFER_COMPLETED;
	uint32_t corrected_size = io_size;
	if (transfer_priv->hid_buffer != NULL) {
		if (transfer_priv->hid_dest != NULL) {	// Data readout
			if (corrected_size > transfer_priv->hid_expected_size) {
				usbi_err(ctx, ""OVERFLOW!"");
				corrected_size = (uint32_t)transfer_priv->hid_expected_size;
				r = LIBUSB_TRANSFER_OVERFLOW;
			}
			if (transfer_priv->hid_buffer[0] == 0) {
				corrected_size--;
				memcpy(transfer_priv->hid_dest, transfer_priv->hid_buffer+1, corrected_size);
			} else {
				memcpy(transfer_priv->hid_dest, transfer_priv->hid_buffer, corrected_size);
			}
			transfer_priv->hid_dest = NULL;
		}
		safe_free(transfer_priv->hid_buffer);
	}
	itransfer->transferred += corrected_size;
	return r;
}
","	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);
	struct windows_transfer_priv *transfer_priv = usbi_transfer_get_os_priv(itransfer);
	int r = LIBUSB_TRANSFER_COMPLETED;
	uint32_t corrected_size = io_size;
	if (transfer_priv->hid_buffer != NULL) {
		if (transfer_priv->hid_dest != NULL) {	// Data readout
			if (corrected_size > transfer_priv->hid_expected_size) {
				usbi_err(ctx, ""OVERFLOW!"");
				corrected_size = (uint32_t)transfer_priv->hid_expected_size;
				r = LIBUSB_TRANSFER_OVERFLOW;
			}
			if (transfer_priv->hid_buffer[0] == 0) {
				corrected_size--;
				memcpy(transfer_priv->hid_dest, transfer_priv->hid_buffer+1, corrected_size);
			} else {
				memcpy(transfer_priv->hid_dest, transfer_priv->hid_buffer, corrected_size);
			}
			transfer_priv->hid_dest = NULL;
		}
		safe_free(transfer_priv->hid_buffer);
	}
	itransfer->transferred += corrected_size;
	return r;
}
"
"static int hid_exit(int sub_api)
{
	return LIBUSB_SUCCESS;
}
","{
	return LIBUSB_SUCCESS;
}
"
"static int hid_init(int sub_api, struct libusb_context *ctx)
{
	DLL_LOAD(hid.dll, HidD_GetAttributes, TRUE);
	DLL_LOAD(hid.dll, HidD_GetHidGuid, TRUE);
	DLL_LOAD(hid.dll, HidD_GetPreparsedData, TRUE);
	DLL_LOAD(hid.dll, HidD_FreePreparsedData, TRUE);
	DLL_LOAD(hid.dll, HidD_GetManufacturerString, TRUE);
	DLL_LOAD(hid.dll, HidD_GetProductString, TRUE);
	DLL_LOAD(hid.dll, HidD_GetSerialNumberString, TRUE);
	DLL_LOAD(hid.dll, HidP_GetCaps, TRUE);
	DLL_LOAD(hid.dll, HidD_SetNumInputBuffers, TRUE);
	DLL_LOAD(hid.dll, HidD_SetFeature, TRUE);
	DLL_LOAD(hid.dll, HidD_GetFeature, TRUE);
	DLL_LOAD(hid.dll, HidD_GetPhysicalDescriptor, TRUE);
	DLL_LOAD(hid.dll, HidD_GetInputReport, FALSE);
	DLL_LOAD(hid.dll, HidD_SetOutputReport, FALSE);
	DLL_LOAD(hid.dll, HidD_FlushQueue, TRUE);
	DLL_LOAD(hid.dll, HidP_GetValueCaps, TRUE);
	api_hid_available = true;
	return LIBUSB_SUCCESS;
}
","{
	DLL_LOAD(hid.dll, HidD_GetAttributes, TRUE);
	DLL_LOAD(hid.dll, HidD_GetHidGuid, TRUE);
	DLL_LOAD(hid.dll, HidD_GetPreparsedData, TRUE);
	DLL_LOAD(hid.dll, HidD_FreePreparsedData, TRUE);
	DLL_LOAD(hid.dll, HidD_GetManufacturerString, TRUE);
	DLL_LOAD(hid.dll, HidD_GetProductString, TRUE);
	DLL_LOAD(hid.dll, HidD_GetSerialNumberString, TRUE);
	DLL_LOAD(hid.dll, HidP_GetCaps, TRUE);
	DLL_LOAD(hid.dll, HidD_SetNumInputBuffers, TRUE);
	DLL_LOAD(hid.dll, HidD_SetFeature, TRUE);
	DLL_LOAD(hid.dll, HidD_GetFeature, TRUE);
	DLL_LOAD(hid.dll, HidD_GetPhysicalDescriptor, TRUE);
	DLL_LOAD(hid.dll, HidD_GetInputReport, FALSE);
	DLL_LOAD(hid.dll, HidD_SetOutputReport, FALSE);
	DLL_LOAD(hid.dll, HidD_FlushQueue, TRUE);
	DLL_LOAD(hid.dll, HidP_GetValueCaps, TRUE);
	api_hid_available = true;
	return LIBUSB_SUCCESS;
}
"
"static int hid_release_interface(int sub_api, struct libusb_device_handle *dev_handle, int iface)
{
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	CHECK_HID_AVAILABLE;
	if (priv->usb_interface[iface].path == NULL) {
		return LIBUSB_ERROR_NOT_FOUND;	// invalid iface
	}
	if (handle_priv->interface_handle[iface].dev_handle != INTERFACE_CLAIMED) {
		return LIBUSB_ERROR_NOT_FOUND;	// invalid iface
	}
	handle_priv->interface_handle[iface].dev_handle = INVALID_HANDLE_VALUE;
	return LIBUSB_SUCCESS;
}
","{
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	struct windows_device_priv *priv = _device_priv(dev_handle->dev);
	CHECK_HID_AVAILABLE;
	if (priv->usb_interface[iface].path == NULL) {
		return LIBUSB_ERROR_NOT_FOUND;	// invalid iface
	}
	if (handle_priv->interface_handle[iface].dev_handle != INTERFACE_CLAIMED) {
		return LIBUSB_ERROR_NOT_FOUND;	// invalid iface
	}
	handle_priv->interface_handle[iface].dev_handle = INVALID_HANDLE_VALUE;
	return LIBUSB_SUCCESS;
}
"
"static int hid_reset_device(int sub_api, struct libusb_device_handle *dev_handle)
{
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	for (current_interface = 0; current_interface < USB_MAXINTERFACES; current_interface++) {
		hid_handle = handle_priv->interface_handle[current_interface].api_handle;
		if ((hid_handle != 0) && (hid_handle != INVALID_HANDLE_VALUE)) {
			HidD_FlushQueue(hid_handle);
		}
	}
	return LIBUSB_SUCCESS;
}
","{
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	for (current_interface = 0; current_interface < USB_MAXINTERFACES; current_interface++) {
		hid_handle = handle_priv->interface_handle[current_interface].api_handle;
		if ((hid_handle != 0) && (hid_handle != INVALID_HANDLE_VALUE)) {
			HidD_FlushQueue(hid_handle);
		}
	}
	return LIBUSB_SUCCESS;
}
"
"static int hid_set_interface_altsetting(int sub_api, struct libusb_device_handle *dev_handle, int iface, int altsetting)
{
	struct libusb_context *ctx = DEVICE_CTX(dev_handle->dev);
	CHECK_HID_AVAILABLE;
	if (altsetting > 255) {
		return LIBUSB_ERROR_INVALID_PARAM;
	}
	if (altsetting != 0) {
		usbi_err(ctx, ""set interface altsetting not supported for altsetting >0"");
		return LIBUSB_ERROR_NOT_SUPPORTED;
	}
	return LIBUSB_SUCCESS;
}
","{
	struct libusb_context *ctx = DEVICE_CTX(dev_handle->dev);
	CHECK_HID_AVAILABLE;
	if (altsetting > 255) {
		return LIBUSB_ERROR_INVALID_PARAM;
	}
	if (altsetting != 0) {
		usbi_err(ctx, ""set interface altsetting not supported for altsetting >0"");
		return LIBUSB_ERROR_NOT_SUPPORTED;
	}
	return LIBUSB_SUCCESS;
}
"
"static int set_composite_interface(struct libusb_context* ctx, struct libusb_device* dev,
							char* dev_interface_path, char* device_id, int api, int sub_api)
{
	unsigned i;
	struct windows_device_priv *priv = _device_priv(dev);
	int interface_number;

	if (priv->apib->id != USB_API_COMPOSITE) {
		usbi_err(ctx, ""program assertion failed: '%s' is not composite"", device_id);
		return LIBUSB_ERROR_NO_DEVICE;
	}

	interface_number = 0;
	for (i=0; device_id[i] != 0; ) {
		if ( (device_id[i++] == 'M') && (device_id[i++] == 'I')
		  && (device_id[i++] == '_') ) {
			interface_number = (device_id[i++] - '0')*10;
			interface_number += device_id[i] - '0';
			break;
		}
	}

	if (device_id[i] == 0) {
		usbi_warn(ctx, ""failure to read interface number for %s. Using default value %d"",
			device_id, interface_number);
 	}
 
 	if (priv->usb_interface[interface_number].path != NULL) {
		if (api == USB_API_HID) {
			usbi_dbg(""interface[%d] already set - ignoring HID collection: %s"",
				interface_number, device_id);
			return LIBUSB_ERROR_ACCESS;
		}
 	}
 
 	usbi_dbg(""interface[%d] = %s"", interface_number, dev_interface_path);
 	priv->usb_interface[interface_number].path = dev_interface_path;
 	priv->usb_interface[interface_number].apib = &usb_api_backend[api];
 	priv->usb_interface[interface_number].sub_api = sub_api;
	if ((api == USB_API_HID) && (priv->hid == NULL)) {
		priv->hid = (struct hid_device_priv*) calloc(1, sizeof(struct hid_device_priv));
		if (priv->hid == NULL)
			return LIBUSB_ERROR_NO_MEM;
	}
	return LIBUSB_SUCCESS;
}
","		if (api == USB_API_HID) {
			usbi_dbg(""interface[%d] already set - ignoring HID collection: %s"",
				interface_number, device_id);
			return LIBUSB_ERROR_ACCESS;
		}
	if ((api == USB_API_HID) && (priv->hid == NULL)) {
		priv->hid = (struct hid_device_priv*) calloc(1, sizeof(struct hid_device_priv));
		if (priv->hid == NULL)
			return LIBUSB_ERROR_NO_MEM;
	}
	return LIBUSB_SUCCESS;
}
"
"static int set_hid_interface(struct libusb_context* ctx, struct libusb_device* dev,
							char* dev_interface_path)
{
	int i;
	struct windows_device_priv *priv = _device_priv(dev);
	if (priv->hid == NULL) {
		usbi_err(ctx, ""program assertion failed: parent is not HID"");
		return LIBUSB_ERROR_NO_DEVICE;
	}
	if (priv->hid->nb_interfaces == USB_MAXINTERFACES) {
		usbi_err(ctx, ""program assertion failed: max USB interfaces reached for HID device"");
		return LIBUSB_ERROR_NO_DEVICE;
	}
	for (i=0; i<priv->hid->nb_interfaces; i++) {
		if (safe_strcmp(priv->usb_interface[i].path, dev_interface_path) == 0) {
			usbi_dbg(""interface[%d] already set to %s"", i, dev_interface_path);
			return LIBUSB_SUCCESS;
		}
	}
 
	priv->usb_interface[priv->hid->nb_interfaces].path = dev_interface_path;
	priv->usb_interface[priv->hid->nb_interfaces].apib = &usb_api_backend[USB_API_HID];
	usbi_dbg(""interface[%d] = %s"", priv->hid->nb_interfaces, dev_interface_path);
	priv->hid->nb_interfaces++;
 	return LIBUSB_SUCCESS;
 }
","							char* dev_interface_path)
{
	int i;
	struct windows_device_priv *priv = _device_priv(dev);
	if (priv->hid == NULL) {
		usbi_err(ctx, ""program assertion failed: parent is not HID"");
		return LIBUSB_ERROR_NO_DEVICE;
	}
	if (priv->hid->nb_interfaces == USB_MAXINTERFACES) {
		usbi_err(ctx, ""program assertion failed: max USB interfaces reached for HID device"");
		return LIBUSB_ERROR_NO_DEVICE;
	}
	for (i=0; i<priv->hid->nb_interfaces; i++) {
		if (safe_strcmp(priv->usb_interface[i].path, dev_interface_path) == 0) {
			usbi_dbg(""interface[%d] already set to %s"", i, dev_interface_path);
			return LIBUSB_SUCCESS;
		}
	}
	priv->usb_interface[priv->hid->nb_interfaces].path = dev_interface_path;
	priv->usb_interface[priv->hid->nb_interfaces].apib = &usb_api_backend[USB_API_HID];
	usbi_dbg(""interface[%d] = %s"", priv->hid->nb_interfaces, dev_interface_path);
	priv->hid->nb_interfaces++;
"
"static void windows_clear_transfer_priv(struct usbi_transfer *itransfer)
{
 	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
 
 	usbi_free_fd(&transfer_priv->pollable_fd);
	safe_free(transfer_priv->hid_buffer);
 	auto_release(itransfer);
 }
","	safe_free(transfer_priv->hid_buffer);
"
"void IndexedDBTransaction::Abort(const IndexedDBDatabaseError& error) {
  IDB_TRACE1(""IndexedDBTransaction::Abort"", ""txn.id"", id());
  DCHECK(!processing_event_queue_);
  if (state_ == FINISHED)
    return;

  UMA_HISTOGRAM_ENUMERATION(""WebCore.IndexedDB.TransactionAbortReason"",
                            ExceptionCodeToUmaEnum(error.code()),
                            UmaIDBExceptionExclusiveMaxValue);

  timeout_timer_.Stop();

  state_ = FINISHED;
  should_process_queue_ = false;

  if (backing_store_transaction_begun_)
    transaction_->Rollback();

  while (!abort_task_stack_.empty())
    abort_task_stack_.pop().Run();

  preemptive_task_queue_.clear();
  pending_preemptive_events_ = 0;
  task_queue_.clear();

  CloseOpenCursors();
  transaction_->Reset();

  database_->transaction_coordinator().DidFinishTransaction(this);
#ifndef NDEBUG
  DCHECK(!database_->transaction_coordinator().IsActive(this));
#endif

  if (callbacks_.get())
    callbacks_->OnAbort(*this, error);

   database_->TransactionFinished(this, false);
 
  connection_->RemoveTransaction(id_);
 }
","  connection_->RemoveTransaction(id_);
"
"IndexedDBTransaction::IndexedDBTransaction(
    int64_t id,
    IndexedDBConnection* connection,
    const std::set<int64_t>& object_store_ids,
    blink::WebIDBTransactionMode mode,
    IndexedDBBackingStore::Transaction* backing_store_transaction)
     : id_(id),
       object_store_ids_(object_store_ids),
       mode_(mode),
      connection_(connection),
       transaction_(backing_store_transaction),
       ptr_factory_(this) {
   IDB_ASYNC_TRACE_BEGIN(""IndexedDBTransaction::lifetime"", this);
  callbacks_ = connection_->callbacks();
  database_ = connection_->database();

  diagnostics_.tasks_scheduled = 0;
  diagnostics_.tasks_completed = 0;
  diagnostics_.creation_time = base::Time::Now();
}
","      connection_(connection),
"
" bool IDNSpoofChecker::SimilarToTopDomains(base::StringPiece16 hostname) {
   size_t hostname_length = hostname.length() - (hostname.back() == '.' ? 1 : 0);
  icu::UnicodeString ustr_host(FALSE, hostname.data(), hostname_length);
  if (lgc_letters_n_ascii_.span(ustr_host, 0, USET_SPAN_CONTAINED) ==
      ustr_host.length())
    diacritic_remover_.get()->transliterate(ustr_host);
  extra_confusable_mapper_.get()->transliterate(ustr_host);
 
   UErrorCode status = U_ZERO_ERROR;
  icu::UnicodeString ustr_skeleton;
  uspoof_getSkeletonUnicodeString(checker_, 0, ustr_host, ustr_skeleton,
                                  &status);
  if (U_FAILURE(status))
    return false;
  std::string skeleton;
  return LookupMatchInTopDomains(ustr_skeleton.toUTF8String(skeleton));
 }
","  icu::UnicodeString ustr_host(FALSE, hostname.data(), hostname_length);
  if (lgc_letters_n_ascii_.span(ustr_host, 0, USET_SPAN_CONTAINED) ==
      ustr_host.length())
    diacritic_remover_.get()->transliterate(ustr_host);
  extra_confusable_mapper_.get()->transliterate(ustr_host);
  icu::UnicodeString ustr_skeleton;
  uspoof_getSkeletonUnicodeString(checker_, 0, ustr_host, ustr_skeleton,
                                  &status);
  if (U_FAILURE(status))
    return false;
  std::string skeleton;
  return LookupMatchInTopDomains(ustr_skeleton.toUTF8String(skeleton));
"
"PerformanceNavigationTiming::PerformanceNavigationTiming(
    LocalFrame* frame,
     ResourceTimingInfo* info,
     TimeTicks time_origin,
     const WebVector<WebServerTimingInfo>& server_timing)
    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : """",
                                ""navigation"",
                                time_origin,
                                server_timing),
       ContextClient(frame),
       resource_timing_info_(info) {
   DCHECK(frame);
  DCHECK(info);
}
","    : PerformanceResourceTiming(info ? info->InitialURL().GetString() : """",
                                ""navigation"",
                                time_origin,
                                server_timing),
"
"void RenderWidgetHostImpl::WasShown(const ui::LatencyInfo& latency_info) {
  if (!is_hidden_)
    return;

  TRACE_EVENT0(""renderer_host"", ""RenderWidgetHostImpl::WasShown"");
  is_hidden_ = false;
 
  if (new_content_rendering_timeout_ &&
      new_content_rendering_timeout_->IsRunning()) {
    new_content_rendering_timeout_->Stop();
    ClearDisplayedGraphics();
  }
 
   SendScreenRects();
   RestartHangMonitorTimeoutIfNecessary();

  bool needs_repainting = true;
  needs_repainting_on_restore_ = false;
  Send(new ViewMsg_WasShown(routing_id_, needs_repainting, latency_info));

  process_->WidgetRestored();

  bool is_visible = true;
  NotificationService::current()->Notify(
      NOTIFICATION_RENDER_WIDGET_VISIBILITY_CHANGED,
      Source<RenderWidgetHost>(this),
      Details<bool>(&is_visible));

  WasResized();
}
","  if (new_content_rendering_timeout_ &&
      new_content_rendering_timeout_->IsRunning()) {
    new_content_rendering_timeout_->Stop();
    ClearDisplayedGraphics();
  }
"
" scoped_refptr<Image> CSSPaintValue::GetImage(
     const ImageResourceObserver& client,
     const Document& document,
    const ComputedStyle&,
     const FloatSize& target_size) {
   if (!generator_) {
     generator_ = CSSPaintImageGenerator::Create(
         GetName(), document, paint_image_generator_observer_);
  }

  if (!ParseInputArguments(document))
    return nullptr;

  return generator_->Paint(client, RoundedIntSize(target_size),
                           parsed_input_arguments_);
}
","    const ComputedStyle&,
"
"  bool IsAllowed(const scoped_refptr<const Extension>& extension,
                 const GURL& url,
                 PermittedFeature feature,
                 int tab_id) {
    const PermissionsData* permissions_data = extension->permissions_data();
    bool script = permissions_data->CanAccessPage(extension.get(), url, tab_id,
                                                   nullptr) &&
                   permissions_data->CanRunContentScriptOnPage(
                       extension.get(), url, tab_id, nullptr);
    bool capture = HasTabsPermission(extension, tab_id) &&
                   permissions_data->CanCaptureVisiblePage(tab_id, NULL);
     switch (feature) {
       case PERMITTED_SCRIPT_ONLY:
         return script && !capture;
      case PERMITTED_CAPTURE_ONLY:
        return capture && !script;
      case PERMITTED_BOTH:
        return script && capture;
      case PERMITTED_NONE:
        return !script && !capture;
    }
    NOTREACHED();
    return false;
  }
","    bool capture = HasTabsPermission(extension, tab_id) &&
                   permissions_data->CanCaptureVisiblePage(tab_id, NULL);
"
"  ExtensionScriptAndCaptureVisibleTest()
      : http_url(""http://www.google.com""),
        http_url_with_path(""http://www.google.com/index.html""),
        https_url(""https://www.google.com""),
        example_com(""https://example.com""),
        test_example_com(""https://test.example.com""),
        sample_example_com(""https://sample.example.com""),
        file_url(""file:///foo/bar""),
        favicon_url(""chrome://favicon/http://www.google.com""),
        extension_url(""chrome-extension://"" +
                       crx_file::id_util::GenerateIdForPath(
                           base::FilePath(FILE_PATH_LITERAL(""foo"")))),
         settings_url(""chrome://settings""),
        about_url(""about:flags"") {
     urls_.insert(http_url);
     urls_.insert(http_url_with_path);
     urls_.insert(https_url);
    urls_.insert(example_com);
    urls_.insert(test_example_com);
    urls_.insert(sample_example_com);
    urls_.insert(file_url);
     urls_.insert(favicon_url);
     urls_.insert(extension_url);
     urls_.insert(settings_url);
    urls_.insert(about_url);
     PermissionsData::SetPolicyDelegate(NULL);
   }
","        about_url(""about:flags"") {
    urls_.insert(about_url);
"
"  AccessType GetExtensionAccess(const Extension* extension,
                                 const GURL& url,
                                 int tab_id) {
     bool allowed_script = IsAllowedScript(extension, url, tab_id);
    bool allowed_capture =
        extension->permissions_data()->CanCaptureVisiblePage(tab_id, nullptr);
 
     if (allowed_script && allowed_capture)
       return ALLOWED_SCRIPT_AND_CAPTURE;
    if (allowed_script)
      return ALLOWED_SCRIPT_ONLY;
    if (allowed_capture)
      return ALLOWED_CAPTURE_ONLY;
    return DISALLOWED;
  }
","    bool allowed_capture =
        extension->permissions_data()->CanCaptureVisiblePage(tab_id, nullptr);
"
"  testing::AssertionResult ScriptAllowedExclusivelyOnTab(
      const Extension* extension,
      const std::set<GURL>& allowed_urls,
       int tab_id) {
     std::vector<std::string> errors;
     for (const GURL& url : urls_) {
      bool allowed = IsAllowedScript(extension, url, tab_id);
      if (allowed && !allowed_urls.count(url))
        errors.push_back(""Script unexpectedly disallowed on "" + url.spec());
      else if (!allowed && allowed_urls.count(url))
        errors.push_back(""Script unexpectedly allowed on "" + url.spec());
     }
 
     if (!errors.empty())
      return testing::AssertionFailure() << base::JoinString(errors, ""\n"");
    return testing::AssertionSuccess();
  }
","      bool allowed = IsAllowedScript(extension, url, tab_id);
      if (allowed && !allowed_urls.count(url))
        errors.push_back(""Script unexpectedly disallowed on "" + url.spec());
      else if (!allowed && allowed_urls.count(url))
        errors.push_back(""Script unexpectedly allowed on "" + url.spec());
"
"bool PermissionsData::CanCaptureVisiblePage(int tab_id,
                                             std::string* error) const {
   const URLPattern all_urls(URLPattern::SCHEME_ALL,
                             URLPattern::kAllUrlsPattern);
 
   base::AutoLock auto_lock(runtime_lock_);
   if (active_permissions_unsafe_->explicit_hosts().ContainsPattern(all_urls))
     return true;
 
  if (tab_id >= 0) {
    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
    if (tab_permissions &&
        tab_permissions->HasAPIPermission(APIPermission::kTab)) {
      return true;
    }
    if (error)
      *error = manifest_errors::kActiveTabPermissionNotGranted;
    return false;
   }
 
   if (error)
    *error = manifest_errors::kAllURLOrActiveTabNeeded;
  return false;
}
","  if (tab_id >= 0) {
    const PermissionSet* tab_permissions = GetTabSpecificPermissions(tab_id);
    if (tab_permissions &&
        tab_permissions->HasAPIPermission(APIPermission::kTab)) {
      return true;
    }
    if (error)
      *error = manifest_errors::kActiveTabPermissionNotGranted;
    return false;
"
"bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {
  if (session->restricted() && !IsFrameHostAllowedForRestrictedSessions())
    return false;
  session->SetRenderer(frame_host_ ? frame_host_->GetProcess()->GetID()
                                   : ChildProcessHost::kInvalidUniqueID,
                       frame_host_);

  protocol::EmulationHandler* emulation_handler =
      new protocol::EmulationHandler();
  session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));
  session->AddHandler(base::WrapUnique(emulation_handler));
  session->AddHandler(base::WrapUnique(new protocol::InputHandler()));
  session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
  session->AddHandler(base::WrapUnique(new protocol::IOHandler(
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));
   session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
   session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));
   session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));
  session->AddHandler(
      base::WrapUnique(new protocol::TargetHandler(false /* browser_only */)));
   session->AddHandler(base::WrapUnique(new protocol::TracingHandler(
       protocol::TracingHandler::Renderer,
       frame_tree_node_ ? frame_tree_node_->frame_tree_node_id() : 0,
      GetIOContext())));
  session->AddHandler(
      base::WrapUnique(new protocol::PageHandler(emulation_handler)));
  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));

  if (EnsureAgent())
    session->AttachToAgent(agent_ptr_);

  if (sessions().size() == 1) {
    if (!base::FeatureList::IsEnabled(features::kVizDisplayCompositor) &&
        !base::FeatureList::IsEnabled(
            features::kUseVideoCaptureApiForDevToolsSnapshots)) {
      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());
    }
    GrantPolicy();
#if defined(OS_ANDROID)
    GetWakeLock()->RequestWakeLock();
#endif
  }
  return true;
}
","  session->AddHandler(
      base::WrapUnique(new protocol::TargetHandler(false /* browser_only */)));
"
"ExtensionDevToolsClientHost::ExtensionDevToolsClientHost(
    Profile* profile,
    DevToolsAgentHost* agent_host,
    const std::string& extension_id,
    const std::string& extension_name,
    const Debuggee& debuggee)
     : profile_(profile),
       agent_host_(agent_host),
       extension_id_(extension_id),
       last_request_id_(0),
       infobar_(nullptr),
       detach_reason_(api::debugger::DETACH_REASON_TARGET_CLOSED),
      extension_registry_observer_(this) {
  CopyDebuggee(&debuggee_, debuggee);

  g_attached_client_hosts.Get().insert(this);

  extension_registry_observer_.Add(ExtensionRegistry::Get(profile_));

   registrar_.Add(this, chrome::NOTIFICATION_APP_TERMINATING,
                  content::NotificationService::AllSources());
 
  agent_host_->AttachClient(this);
 
   if (base::CommandLine::ForCurrentProcess()->HasSwitch(
           ::switches::kSilentDebuggerExtensionAPI)) {
    return;
   }
 
   const Extension* extension =
      ExtensionRegistry::Get(profile)->enabled_extensions().GetByID(
          extension_id);
   if (extension && Manifest::IsPolicyLocation(extension->location()))
    return;
 
   infobar_ = ExtensionDevToolsInfoBar::Create(
      extension_id, extension_name, this,
       base::Bind(&ExtensionDevToolsClientHost::InfoBarDismissed,
                  base::Unretained(this)));
 }
","  agent_host_->AttachClient(this);
    return;
      ExtensionRegistry::Get(profile)->enabled_extensions().GetByID(
          extension_id);
    return;
      extension_id, extension_name, this,
"
"bool DebuggerAttachFunction::RunAsync() {
  std::unique_ptr<Attach::Params> params(Attach::Params::Create(*args_));
  EXTENSION_FUNCTION_VALIDATE(params.get());

  CopyDebuggee(&debuggee_, params->target);
  if (!InitAgentHost())
    return false;

  if (!DevToolsAgentHost::IsSupportedProtocolVersion(
          params->required_version)) {
    error_ = ErrorUtils::FormatErrorMessage(
        keys::kProtocolVersionNotSupportedError,
        params->required_version);
    return false;
  }

  if (FindClientHost()) {
    FormatErrorMessage(keys::kAlreadyAttachedError);
     return false;
   }
 
  new ExtensionDevToolsClientHost(GetProfile(), agent_host_.get(),
                                  extension()->id(), extension()->name(),
                                  debuggee_);
   SendResponse(true);
   return true;
 }
","  new ExtensionDevToolsClientHost(GetProfile(), agent_host_.get(),
                                  extension()->id(), extension()->name(),
                                  debuggee_);
"
"void BrowserDevToolsAgentHost::AttachSession(DevToolsSession* session) {
   session->SetBrowserOnly(true);
   session->AddHandler(
       base::WrapUnique(new protocol::TargetHandler(true /* browser_only */)));
   if (only_discovery_)
    return;
 
   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));
   session->AddHandler(base::WrapUnique(new protocol::IOHandler(
      GetIOContext())));
  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));
  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));
  session->AddHandler(base::WrapUnique(new protocol::SystemInfoHandler()));
  session->AddHandler(base::WrapUnique(new protocol::TetheringHandler(
      socket_callback_, tethering_task_runner_)));
  session->AddHandler(base::WrapUnique(new protocol::TracingHandler(
       protocol::TracingHandler::Browser,
       FrameTreeNode::kFrameTreeNodeInvalidId,
       GetIOContext())));
 }
","    return;
"
" void DevToolsAgentHostImpl::AttachClient(DevToolsAgentHostClient* client) {
   if (SessionByClient(client))
     return;
  InnerAttachClient(client);
 }
","  InnerAttachClient(client);
"
"void DevToolsAgentHost::DetachAllClients() {
  if (!g_devtools_instances.IsCreated())
    return;

   DevToolsMap copy = g_devtools_instances.Get();
   for (DevToolsMap::iterator it(copy.begin()); it != copy.end(); ++it) {
     DevToolsAgentHostImpl* agent_host = it->second;
    agent_host->ForceDetachAllClients();
   }
 }
","    agent_host->ForceDetachAllClients();
"
" void DevToolsAgentHostImpl::ForceAttachClient(DevToolsAgentHostClient* client) {
   if (SessionByClient(client))
     return;
   scoped_refptr<DevToolsAgentHostImpl> protect(this);
   if (!sessions_.empty())
    ForceDetachAllClients();
   DCHECK(sessions_.empty());
  InnerAttachClient(client);
 }
","    ForceDetachAllClients();
  InnerAttachClient(client);
"
"void DevToolsAgentHostImpl::ForceDetachAllClients() {
   scoped_refptr<DevToolsAgentHostImpl> protect(this);
  while (!session_by_client_.empty()) {
    DevToolsAgentHostClient* client = session_by_client_.begin()->first;
    InnerDetachClient(client);
     client->AgentHostClosed(this);
   }
 }
","  while (!session_by_client_.empty()) {
    DevToolsAgentHostClient* client = session_by_client_.begin()->first;
    InnerDetachClient(client);
"
"void DevToolsAgentHostImpl::InnerAttachClient(DevToolsAgentHostClient* client) {
   scoped_refptr<DevToolsAgentHostImpl> protect(this);
  DevToolsSession* session = new DevToolsSession(this, client);
   sessions_.insert(session);
   session_by_client_[client].reset(session);
  AttachSession(session);
   if (sessions_.size() == 1)
     NotifyAttached();
   DevToolsManager* manager = DevToolsManager::GetInstance();
   if (manager->delegate())
     manager->delegate()->ClientAttached(this, client);
 }
","  DevToolsSession* session = new DevToolsSession(this, client);
  AttachSession(session);
"
" DevToolsSession::DevToolsSession(DevToolsAgentHostImpl* agent_host,
                                 DevToolsAgentHostClient* client)
     : binding_(this),
       agent_host_(agent_host),
       client_(client),
       process_host_id_(ChildProcessHost::kInvalidUniqueID),
       host_(nullptr),
       dispatcher_(new protocol::UberDispatcher(this)),
      weak_factory_(this) {
  dispatcher_->setFallThroughForNotFound(true);
}
","                                 DevToolsAgentHostClient* client)
"
"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
   scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
   if (IsAttached())
     RevokePolicy();
  ForceDetachAllClients();
   frame_host_ = nullptr;
   agent_ptr_.reset();
   SetFrameTreeNode(nullptr);
  Release();
}
","  ForceDetachAllClients();
"
"void CredentialManagerImpl::OnProvisionalSaveComplete() {
  DCHECK(form_manager_);
  DCHECK(client_->IsSavingAndFillingEnabledForCurrentPage());
  const autofill::PasswordForm& form = form_manager_->pending_credentials();

  if (form_manager_->IsPendingCredentialsPublicSuffixMatch()) {
    form_manager_->Save();
    return;
  }

  if (!form.federation_origin.unique()) {
    for (auto* match : form_manager_->form_fetcher()->GetFederatedMatches()) {
      if (match->username_value == form.username_value &&
          match->federation_origin.IsSameOriginWith(form.federation_origin)) {
        form_manager_->Update(*match);
        return;
      }
    }
  } else if (!form_manager_->IsNewLogin()) {
    form_manager_->Update(*form_manager_->preferred_match());
     return;
   }
 
  client_->PromptUserToSaveOrUpdatePassword(std::move(form_manager_), false);
}
","    form_manager_->Update(*form_manager_->preferred_match());
"
"static bool TokenExitsSVG(const CompactHTMLToken& token) {
  return DeprecatedEqualIgnoringCase(token.Data(),
                                     SVGNames::foreignObjectTag.LocalName());
}
","  return DeprecatedEqualIgnoringCase(token.Data(),
                                     SVGNames::foreignObjectTag.LocalName());
}
"
"int MemBackendImpl::DoomEntriesBetween(Time initial_time,
                                       Time end_time,
                                       const CompletionCallback& callback) {
  if (end_time.is_null())
    end_time = Time::Max();
  DCHECK_GE(end_time, initial_time);

  base::LinkNode<MemEntryImpl>* node = lru_list_.head();
  while (node != lru_list_.end() && node->value()->GetLastUsed() < initial_time)
     node = node->next();
   while (node != lru_list_.end() && node->value()->GetLastUsed() < end_time) {
     MemEntryImpl* to_doom = node->value();
    node = node->next();
     to_doom->Doom();
   }
 
  return net::OK;
}
","    node = node->next();
"
"void MemBackendImpl::EvictIfNeeded() {
  if (current_size_ <= max_size_)
    return;

  int target_size = std::max(0, max_size_ - kDefaultEvictionSize);

   base::LinkNode<MemEntryImpl>* entry = lru_list_.head();
   while (current_size_ > target_size && entry != lru_list_.end()) {
     MemEntryImpl* to_doom = entry->value();
    do {
      entry = entry->next();
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);
 
     if (!to_doom->InUse())
       to_doom->Doom();
  }
}
","    do {
      entry = entry->next();
    } while (entry != lru_list_.end() && entry->value()->parent() == to_doom);
"
"void ChunkedUploadDataStream::AppendData(
    const char* data, int data_len, bool is_done) {
  DCHECK(!all_data_appended_);
  DCHECK(data_len > 0 || is_done);
   if (data_len > 0) {
     DCHECK(data);
     upload_data_.push_back(
        base::MakeUnique<std::vector<char>>(data, data + data_len));
   }
   all_data_appended_ = is_done;
 
  if (!read_buffer_.get())
    return;

  int result = ReadChunk(read_buffer_.get(), read_buffer_len_);
  DCHECK_GE(result, 0);
  read_buffer_ = NULL;
  read_buffer_len_ = 0;
  OnReadCompleted(result);
}
","        base::MakeUnique<std::vector<char>>(data, data + data_len));
"
"void ElementsUploadDataStreamTest::FileChangedHelper(
    const base::FilePath& file_path,
    const base::Time& time,
    bool error_expected) {
   std::vector<std::unique_ptr<UploadElementReader>> element_readers;
  element_readers.push_back(base::MakeUnique<UploadFileElementReader>(
       base::ThreadTaskRunnerHandle::Get().get(), file_path, 1, 2, time));
 
   TestCompletionCallback init_callback;
  std::unique_ptr<UploadDataStream> stream(
      new ElementsUploadDataStream(std::move(element_readers), 0));
  ASSERT_THAT(stream->Init(init_callback.callback(), NetLogWithSource()),
              IsError(ERR_IO_PENDING));
  int error_code = init_callback.WaitForResult();
  if (error_expected)
    ASSERT_THAT(error_code, IsError(ERR_UPLOAD_FILE_CHANGED));
  else
    ASSERT_THAT(error_code, IsOk());
}
","  element_readers.push_back(base::MakeUnique<UploadFileElementReader>(
"
" FileStream::FileStream(const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(task_runner)) {}
","    : context_(base::MakeUnique<Context>(task_runner)) {}
"
" FileStream::FileStream(base::File file,
                        const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}
","    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}
"
"NetworkChangeNotifierMac::NetworkChangeNotifierMac()
    : NetworkChangeNotifier(NetworkChangeCalculatorParamsMac()),
      connection_type_(CONNECTION_UNKNOWN),
       connection_type_initialized_(false),
       initial_connection_type_cv_(&connection_type_lock_),
       forwarder_(this),
      dns_config_service_thread_(base::MakeUnique<DnsConfigServiceThread>()) {
  config_watcher_ = base::MakeUnique<NetworkConfigWatcherMac>(&forwarder_);
   dns_config_service_thread_->StartWithOptions(
       base::Thread::Options(base::MessageLoop::TYPE_IO, 0));
 }
","      dns_config_service_thread_(base::MakeUnique<DnsConfigServiceThread>()) {
  config_watcher_ = base::MakeUnique<NetworkConfigWatcherMac>(&forwarder_);
"
"bool GetNetworkList(NetworkInterfaceList* networks, int policy) {
  if (networks == NULL)
    return false;

  base::ThreadRestrictions::AssertIOAllowed();

  ifaddrs* interfaces;
  if (getifaddrs(&interfaces) < 0) {
    PLOG(ERROR) << ""getifaddrs"";
    return false;
  }

   std::unique_ptr<internal::IPAttributesGetter> ip_attributes_getter;
 
 #if defined(OS_MACOSX) && !defined(OS_IOS)
  ip_attributes_getter = base::MakeUnique<internal::IPAttributesGetterMac>();
 #endif
 
   bool result = internal::IfaddrsToNetworkInterfaceList(
      policy, interfaces, ip_attributes_getter.get(), networks);
  freeifaddrs(interfaces);
  return result;
}
","  ip_attributes_getter = base::MakeUnique<internal::IPAttributesGetterMac>();
"
"NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()
     : lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,
                                 kInitialMedianInMs),
       outstanding_recomputation_timer_(
          base::MakeUnique<base::Timer>(false /* retain_user_task */,
                                         false /* is_repeating */)),
       tick_clock_(new base::DefaultTickClock()),
       weak_ptr_factory_(this) {}
","          base::MakeUnique<base::Timer>(false /* retain_user_task */,
"
"void NetworkThrottleManagerImpl::SetTickClockForTesting(
     std::unique_ptr<base::TickClock> tick_clock) {
   tick_clock_ = std::move(tick_clock);
   DCHECK(!outstanding_recomputation_timer_->IsRunning());
  outstanding_recomputation_timer_ = base::MakeUnique<base::Timer>(
       false /* retain_user_task */, false /* is_repeating */,
       tick_clock_.get());
 }
","  outstanding_recomputation_timer_ = base::MakeUnique<base::Timer>(
"
"v8::Local<v8::Value> ModuleSystem::RequireForJsInner(
    v8::Local<v8::String> module_name) {
  v8::EscapableHandleScope handle_scope(GetIsolate());
  v8::Local<v8::Context> v8_context = context()->v8_context();
  v8::Context::Scope context_scope(v8_context);

  v8::Local<v8::Object> global(context()->v8_context()->Global());

  v8::Local<v8::Value> modules_value;
  if (!GetPrivate(global, kModulesField, &modules_value) ||
      modules_value->IsUndefined()) {
    Warn(GetIsolate(), ""Extension view no longer exists"");
    return v8::Undefined(GetIsolate());
  }
 
   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));
   v8::Local<v8::Value> exports;
  if (!GetProperty(v8_context, modules, module_name, &exports) ||
       !exports->IsUndefined())
     return handle_scope.Escape(exports);
 
   exports = LoadModule(*v8::String::Utf8Value(module_name));
  SetProperty(v8_context, modules, module_name, exports);
   return handle_scope.Escape(exports);
 }
","  if (!GetProperty(v8_context, modules, module_name, &exports) ||
  SetProperty(v8_context, modules, module_name, exports);
"
"CastStreamingNativeHandler::CastStreamingNativeHandler(ScriptContext* context)
     : ObjectBackedNativeHandler(context),
       last_transport_id_(1),
       weak_factory_(this) {
  RouteFunction(""CreateSession"",
                 base::Bind(&CastStreamingNativeHandler::CreateCastSession,
                            weak_factory_.GetWeakPtr()));
  RouteFunction(""DestroyCastRtpStream"",
                 base::Bind(&CastStreamingNativeHandler::DestroyCastRtpStream,
                            weak_factory_.GetWeakPtr()));
   RouteFunction(
      ""GetSupportedParamsCastRtpStream"",
       base::Bind(&CastStreamingNativeHandler::GetSupportedParamsCastRtpStream,
                  weak_factory_.GetWeakPtr()));
  RouteFunction(""StartCastRtpStream"",
                 base::Bind(&CastStreamingNativeHandler::StartCastRtpStream,
                            weak_factory_.GetWeakPtr()));
  RouteFunction(""StopCastRtpStream"",
                 base::Bind(&CastStreamingNativeHandler::StopCastRtpStream,
                            weak_factory_.GetWeakPtr()));
  RouteFunction(""DestroyCastUdpTransport"",
                 base::Bind(&CastStreamingNativeHandler::DestroyCastUdpTransport,
                            weak_factory_.GetWeakPtr()));
   RouteFunction(
      ""SetDestinationCastUdpTransport"",
       base::Bind(&CastStreamingNativeHandler::SetDestinationCastUdpTransport,
                  weak_factory_.GetWeakPtr()));
   RouteFunction(
      ""SetOptionsCastUdpTransport"",
       base::Bind(&CastStreamingNativeHandler::SetOptionsCastUdpTransport,
                  weak_factory_.GetWeakPtr()));
  RouteFunction(""ToggleLogging"",
                 base::Bind(&CastStreamingNativeHandler::ToggleLogging,
                            weak_factory_.GetWeakPtr()));
  RouteFunction(""GetRawEvents"",
                 base::Bind(&CastStreamingNativeHandler::GetRawEvents,
                            weak_factory_.GetWeakPtr()));
  RouteFunction(""GetStats"", base::Bind(&CastStreamingNativeHandler::GetStats,
                                       weak_factory_.GetWeakPtr()));
  RouteFunction(""StartCastRtpReceiver"",
                 base::Bind(&CastStreamingNativeHandler::StartCastRtpReceiver,
                            weak_factory_.GetWeakPtr()));
 }
","  RouteFunction(""CreateSession"",
  RouteFunction(""DestroyCastRtpStream"",
      ""GetSupportedParamsCastRtpStream"",
  RouteFunction(""StartCastRtpStream"",
  RouteFunction(""StopCastRtpStream"",
  RouteFunction(""DestroyCastUdpTransport"",
      ""SetDestinationCastUdpTransport"",
      ""SetOptionsCastUdpTransport"",
  RouteFunction(""ToggleLogging"",
  RouteFunction(""GetRawEvents"",
  RouteFunction(""GetStats"", base::Bind(&CastStreamingNativeHandler::GetStats,
                                       weak_factory_.GetWeakPtr()));
  RouteFunction(""StartCastRtpReceiver"",
"
"FileBrowserHandlerCustomBindings::FileBrowserHandlerCustomBindings(
     ScriptContext* context)
     : ObjectBackedNativeHandler(context) {
   RouteFunction(
      ""GetExternalFileEntry"",
      base::Bind(&FileBrowserHandlerCustomBindings::GetExternalFileEntry,
                 base::Unretained(this)));
  RouteFunction(""GetEntryURL"",
                base::Bind(&FileBrowserHandlerCustomBindings::GetEntryURL,
                           base::Unretained(this)));
 }
","      ""GetExternalFileEntry"",
      base::Bind(&FileBrowserHandlerCustomBindings::GetExternalFileEntry,
                 base::Unretained(this)));
  RouteFunction(""GetEntryURL"",
                base::Bind(&FileBrowserHandlerCustomBindings::GetEntryURL,
                           base::Unretained(this)));
"
"void FileBrowserHandlerCustomBindings::GetEntryURL(
     const v8::FunctionCallbackInfo<v8::Value>& args) {
  CHECK(args.Length() == 1);
  CHECK(args[0]->IsObject());
  const blink::WebURL& url =
      blink::WebDOMFileSystem::createFileSystemURL(args[0]);
  args.GetReturnValue().Set(v8_helpers::ToV8StringUnsafe(
      args.GetIsolate(), url.string().utf8().c_str()));
 }
","  CHECK(args.Length() == 1);
  CHECK(args[0]->IsObject());
  const blink::WebURL& url =
      blink::WebDOMFileSystem::createFileSystemURL(args[0]);
  args.GetReturnValue().Set(v8_helpers::ToV8StringUnsafe(
      args.GetIsolate(), url.string().utf8().c_str()));
"
" void FileBrowserHandlerCustomBindings::GetExternalFileEntry(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
//// TODO(zelidrag): Make this magic work on other platforms when file browser
//// matures enough on ChromeOS.
 #if defined(OS_CHROMEOS)
     CHECK(args.Length() == 1);
     CHECK(args[0]->IsObject());
    v8::Local<v8::Object> file_def = args[0]->ToObject();
    std::string file_system_name(
        *v8::String::Utf8Value(file_def->Get(
            v8::String::NewFromUtf8(args.GetIsolate(), ""fileSystemName""))));
    GURL file_system_root(
        *v8::String::Utf8Value(file_def->Get(
            v8::String::NewFromUtf8(args.GetIsolate(), ""fileSystemRoot""))));
    std::string file_full_path(
        *v8::String::Utf8Value(file_def->Get(
            v8::String::NewFromUtf8(args.GetIsolate(), ""fileFullPath""))));
    bool is_directory = file_def->Get(v8::String::NewFromUtf8(
        args.GetIsolate(), ""fileIsDirectory""))->ToBoolean()->Value();
    blink::WebDOMFileSystem::EntryType entry_type =
         is_directory ? blink::WebDOMFileSystem::EntryTypeDirectory
                      : blink::WebDOMFileSystem::EntryTypeFile;
     blink::WebLocalFrame* webframe =
        blink::WebLocalFrame::frameForContext(context()->v8_context());
     args.GetReturnValue().Set(
         blink::WebDOMFileSystem::create(
             webframe,
            blink::WebFileSystemTypeExternal,
            blink::WebString::fromUTF8(file_system_name),
            file_system_root)
            .createV8Entry(blink::WebString::fromUTF8(file_full_path),
                           entry_type,
                           args.Holder(),
                           args.GetIsolate()));
 #endif
 }
","    const v8::FunctionCallbackInfo<v8::Value>& args) {
        blink::WebLocalFrame::frameForContext(context()->v8_context());
"
" FileManagerPrivateCustomBindings::FileManagerPrivateCustomBindings(
     ScriptContext* context)
     : ObjectBackedNativeHandler(context) {
   RouteFunction(
      ""GetFileSystem"",
       base::Bind(&FileManagerPrivateCustomBindings::GetFileSystem,
                  base::Unretained(this)));
 }
","      ""GetFileSystem"",
       base::Bind(&FileManagerPrivateCustomBindings::GetFileSystem,
                  base::Unretained(this)));
"
"MediaGalleriesCustomBindings::MediaGalleriesCustomBindings(
     ScriptContext* context)
     : ObjectBackedNativeHandler(context) {
   RouteFunction(
      ""GetMediaFileSystemObject"",
       base::Bind(&MediaGalleriesCustomBindings::GetMediaFileSystemObject,
                  base::Unretained(this)));
 }
","      ""GetMediaFileSystemObject"",
"
" NotificationsNativeHandler::NotificationsNativeHandler(ScriptContext* context)
     : ObjectBackedNativeHandler(context) {
   RouteFunction(
      ""GetNotificationImageSizes"",
       base::Bind(&NotificationsNativeHandler::GetNotificationImageSizes,
                  base::Unretained(this)));
 }
","      ""GetNotificationImageSizes"",
"
" PageCaptureCustomBindings::PageCaptureCustomBindings(ScriptContext* context)
     : ObjectBackedNativeHandler(context) {
  RouteFunction(""CreateBlob"",
      base::Bind(&PageCaptureCustomBindings::CreateBlob,
                 base::Unretained(this)));
  RouteFunction(""SendResponseAck"",
      base::Bind(&PageCaptureCustomBindings::SendResponseAck,
                 base::Unretained(this)));
 }
","  RouteFunction(""CreateBlob"",
      base::Bind(&PageCaptureCustomBindings::CreateBlob,
                 base::Unretained(this)));
  RouteFunction(""SendResponseAck"",
      base::Bind(&PageCaptureCustomBindings::SendResponseAck,
                 base::Unretained(this)));
"
"std::string TestURLLoader::TestUntendedLoad() {
  pp::URLRequestInfo request(instance_);
  request.SetURL(""test_url_loader_data/hello.txt"");
  request.SetRecordDownloadProgress(true);
  TestCompletionCallback callback(instance_->pp_instance(), callback_type());

  pp::URLLoader loader(instance_);
  callback.WaitForResult(loader.Open(request, callback.GetCallback()));
  CHECK_CALLBACK_BEHAVIOR(callback);
  ASSERT_EQ(PP_OK, callback.result());

  int64_t bytes_received = 0;
  int64_t total_bytes_to_be_received = 0;
  while (true) {
     loader.GetDownloadProgress(&bytes_received, &total_bytes_to_be_received);
     if (total_bytes_to_be_received <= 0)
       return ReportError(""URLLoader::GetDownloadProgress total size"",
          total_bytes_to_be_received);
     if (bytes_received == total_bytes_to_be_received)
       break;
    if (pp::Module::Get()->core()->IsMainThread()) {
      NestedEvent event(instance_->pp_instance());
      event.PostSignal(10);
      event.Wait();
    }
  }
  std::string body;
  std::string error = ReadEntireResponseBody(&loader, &body);
  if (!error.empty())
    return error;
  if (body != ""hello\n"")
    return ReportError(""Couldn't read data"", callback.result());

  PASS();
}
","          total_bytes_to_be_received);
"
"bool SiteInstanceImpl::DoesSiteRequireDedicatedProcess(
    BrowserContext* browser_context,
    const GURL& url) {
   if (SiteIsolationPolicy::UseDedicatedProcessesForAllSites())
     return true;
 
  if (url.SchemeIs(kChromeErrorScheme))
     return true;
 
  GURL site_url = SiteInstance::GetSiteForURL(browser_context, url);
  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  if (policy->IsIsolatedOrigin(url::Origin::Create(site_url)))
     return true;
 
  if (GetContentClient()->browser()->DoesSiteRequireDedicatedProcess(
          browser_context, site_url)) {
    return true;
  }

  return false;
}
","  if (url.SchemeIs(kChromeErrorScheme))
  GURL site_url = SiteInstance::GetSiteForURL(browser_context, url);
  auto* policy = ChildProcessSecurityPolicyImpl::GetInstance();
  if (policy->IsIsolatedOrigin(url::Origin::Create(site_url)))
"
"bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,
                                          GURL site_url) {
  if (RenderProcessHost::run_renderer_in_process())
    return false;

  if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))
    return false;

   if (site_url.SchemeIs(content::kGuestScheme))
     return false;
 
  if (site_url.SchemeIs(content::kChromeUIScheme))
    return false;
  if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,
                                                         site_url)) {
    return false;
  }

  return true;
}
","  if (site_url.SchemeIs(content::kChromeUIScheme))
    return false;
"
"v8::Local<v8::Value> V8ValueConverterImpl::ToV8Array(
    v8::Isolate* isolate,
    v8::Local<v8::Object> creation_context,
     const base::ListValue* val) const {
   v8::Local<v8::Array> result(v8::Array::New(isolate, val->GetSize()));
 
   for (size_t i = 0; i < val->GetSize(); ++i) {
     const base::Value* child = NULL;
     CHECK(val->Get(i, &child));

    v8::Local<v8::Value> child_v8 =
         ToV8ValueImpl(isolate, creation_context, child);
     CHECK(!child_v8.IsEmpty());
 
    v8::TryCatch try_catch(isolate);
    result->Set(static_cast<uint32_t>(i), child_v8);
    if (try_catch.HasCaught())
      LOG(ERROR) << ""Setter for index "" << i << "" threw an exception."";
   }
 
   return result;
}
","    v8::TryCatch try_catch(isolate);
    result->Set(static_cast<uint32_t>(i), child_v8);
    if (try_catch.HasCaught())
      LOG(ERROR) << ""Setter for index "" << i << "" threw an exception."";
"
"v8::Local<v8::Value> V8ValueConverterImpl::ToV8Object(
    v8::Isolate* isolate,
    v8::Local<v8::Object> creation_context,
     const base::DictionaryValue* val) const {
   v8::Local<v8::Object> result(v8::Object::New(isolate));
 
   for (base::DictionaryValue::Iterator iter(*val);
        !iter.IsAtEnd(); iter.Advance()) {
     const std::string& key = iter.key();
     v8::Local<v8::Value> child_v8 =
         ToV8ValueImpl(isolate, creation_context, &iter.value());
     CHECK(!child_v8.IsEmpty());
 
    v8::TryCatch try_catch(isolate);
    result->Set(
        v8::String::NewFromUtf8(
            isolate, key.c_str(), v8::String::kNormalString, key.length()),
         child_v8);
    if (try_catch.HasCaught()) {
      LOG(ERROR) << ""Setter for property "" << key.c_str() << "" threw an ""
                 << ""exception."";
    }
   }
 
   return result;
}
","    v8::TryCatch try_catch(isolate);
    result->Set(
        v8::String::NewFromUtf8(
            isolate, key.c_str(), v8::String::kNormalString, key.length()),
    if (try_catch.HasCaught()) {
      LOG(ERROR) << ""Setter for property "" << key.c_str() << "" threw an ""
                 << ""exception."";
    }
"
" exsltCryptoPopString (xmlXPathParserContextPtr ctxt, int nargs,
		      xmlChar ** str) {

    int str_len = 0;

    if ((nargs < 1) || (nargs > 2)) {
	xmlXPathSetArityError (ctxt);
	return 0;
     }
 
     *str = xmlXPathPopString (ctxt);
    str_len = xmlUTF8Strlen (*str);
 
     if (str_len == 0) {
 	xmlXPathReturnEmptyString (ctxt);
	xmlFree (*str);
	return 0;
    }

    return str_len;
}
","    str_len = xmlUTF8Strlen (*str);
"
"_exsltDateTruncateDate (exsltDateValPtr dt, exsltDateType type)
{
    if (dt == NULL)
        return 1;

    if ((type & XS_TIME) != XS_TIME) {
        dt->value.date.hour = 0;
        dt->value.date.min  = 0;
        dt->value.date.sec  = 0.0;
     }
 
     if ((type & XS_GDAY) != XS_GDAY)
        dt->value.date.day = 0;
 
     if ((type & XS_GMONTH) != XS_GMONTH)
        dt->value.date.mon = 0;
 
     if ((type & XS_GYEAR) != XS_GYEAR)
         dt->value.date.year = 0;

    dt->type = type;

    return 0;
}
","        dt->value.date.day = 0;
        dt->value.date.mon = 0;
"
"exsltStrAlignFunction (xmlXPathParserContextPtr ctxt, int nargs) {
    xmlChar *str, *padding, *alignment, *ret;
    int str_l, padding_l;

    if ((nargs < 2) || (nargs > 3)) {
	xmlXPathSetArityError(ctxt);
	return;
    }

    if (nargs == 3)
	alignment = xmlXPathPopString(ctxt);
    else
	alignment = NULL;

    padding = xmlXPathPopString(ctxt);
    str = xmlXPathPopString(ctxt);

    str_l = xmlUTF8Strlen (str);
    padding_l = xmlUTF8Strlen (padding);

    if (str_l == padding_l) {
	xmlXPathReturnString (ctxt, str);
	xmlFree(padding);
	xmlFree(alignment);
	return;
    }

    if (str_l > padding_l) {
	ret = xmlUTF8Strndup (str, padding_l);
    } else {
	if (xmlStrEqual(alignment, (const xmlChar *) ""right"")) {
	    ret = xmlUTF8Strndup (padding, padding_l - str_l);
	    ret = xmlStrcat (ret, str);
	} else if (xmlStrEqual(alignment, (const xmlChar *) ""center"")) {
	    int left = (padding_l - str_l) / 2;
	    int right_start;

	    ret = xmlUTF8Strndup (padding, left);
	    ret = xmlStrcat (ret, str);

	    right_start = xmlUTF8Strsize (padding, left + str_l);
	    ret = xmlStrcat (ret, padding + right_start);
 	} else {
 	    int str_s;
 
	    str_s = xmlStrlen (str);
 	    ret = xmlStrdup (str);
 	    ret = xmlStrcat (ret, padding + str_s);
 	}
    }

    xmlXPathReturnString (ctxt, ret);

    xmlFree(str);
    xmlFree(padding);
    xmlFree(alignment);
}
","	    str_s = xmlStrlen (str);
"
" exsltStrPaddingFunction (xmlXPathParserContextPtr ctxt, int nargs) {
    int number, str_len = 0;
    xmlChar *str = NULL, *ret = NULL, *tmp;
 
     if ((nargs < 1) || (nargs > 2)) {
 	xmlXPathSetArityError(ctxt);
	return;
    }

     if (nargs == 2) {
 	str = xmlXPathPopString(ctxt);
 	str_len = xmlUTF8Strlen(str);
     }
     if (str_len == 0) {
 	if (str != NULL) xmlFree(str);
 	str = xmlStrdup((const xmlChar *) "" "");
 	str_len = 1;
     }
 
     number = (int) xmlXPathPopNumber(ctxt);

    if (number <= 0) {
	xmlXPathReturnEmptyString(ctxt);
	xmlFree(str);
	return;
     }
 
     while (number >= str_len) {
	ret = xmlStrncat(ret, str, str_len);
 	number -= str_len;
     }
    tmp = xmlUTF8Strndup (str, number);
    ret = xmlStrcat(ret, tmp);
    if (tmp != NULL)
	xmlFree (tmp);
 
     xmlXPathReturnString(ctxt, ret);
 
    if (str != NULL)
	xmlFree(str);
}
","    int number, str_len = 0;
    xmlChar *str = NULL, *ret = NULL, *tmp;
	ret = xmlStrncat(ret, str, str_len);
    tmp = xmlUTF8Strndup (str, number);
    ret = xmlStrcat(ret, tmp);
    if (tmp != NULL)
	xmlFree (tmp);
"
"exsltStrXpathCtxtRegister (xmlXPathContextPtr ctxt, const xmlChar *prefix)
{
    if (ctxt
        && prefix
        && !xmlXPathRegisterNs(ctxt,
                               prefix,
                               (const xmlChar *) EXSLT_STRINGS_NAMESPACE)
        && !xmlXPathRegisterFuncNS(ctxt,
                                   (const xmlChar *) ""encode-uri"",
                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,
                                   exsltStrEncodeUriFunction)
        && !xmlXPathRegisterFuncNS(ctxt,
                                   (const xmlChar *) ""decode-uri"",
                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,
                                   exsltStrDecodeUriFunction)
        && !xmlXPathRegisterFuncNS(ctxt,
                                   (const xmlChar *) ""padding"",
                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,
                                   exsltStrPaddingFunction)
        && !xmlXPathRegisterFuncNS(ctxt,
                                   (const xmlChar *) ""align"",
                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,
                                   exsltStrAlignFunction)
         && !xmlXPathRegisterFuncNS(ctxt,
                                    (const xmlChar *) ""concat"",
                                    (const xmlChar *) EXSLT_STRINGS_NAMESPACE,
                                   exsltStrConcatFunction)
        && !xmlXPathRegisterFuncNS(ctxt,
                                   (const xmlChar *) ""replace"",
                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,
                                   exsltStrReplaceFunction)) {
         return 0;
     }
     return -1;
}
","                                   exsltStrConcatFunction)
        && !xmlXPathRegisterFuncNS(ctxt,
                                   (const xmlChar *) ""replace"",
                                   (const xmlChar *) EXSLT_STRINGS_NAMESPACE,
                                   exsltStrReplaceFunction)) {
"
"xsltResolveSASCallback(xsltAttrElemPtr values, xsltStylesheetPtr style,
 	               const xmlChar *name, const xmlChar *ns,
		       ATTRIBUTE_UNUSED const xmlChar *ignored) {
     xsltAttrElemPtr tmp;
     xsltAttrElemPtr refs;
 
     tmp = values;
     while (tmp != NULL) {
 	if (tmp->set != NULL) {
 	    /*
	     * Check against cycles !
	     */
	    if ((xmlStrEqual(name, tmp->set)) && (xmlStrEqual(ns, tmp->ns))) {
		xsltGenericError(xsltGenericErrorContext,
     ""xsl:attribute-set : use-attribute-sets recursion detected on %s\n"",
                                 name);
	    } else {
#ifdef WITH_XSLT_DEBUG_ATTRIBUTES
		xsltGenericDebug(xsltGenericDebugContext,
			""Importing attribute list %s\n"", tmp->set);
#endif

		refs = xsltGetSAS(style, tmp->set, tmp->ns);
		if (refs == NULL) {
		    xsltGenericError(xsltGenericErrorContext,
     ""xsl:attribute-set : use-attribute-sets %s reference missing %s\n"",
				     name, tmp->set);
		} else {
 		    /*
 		     * recurse first for cleanup
 		     */
		    xsltResolveSASCallback(refs, style, name, ns, NULL);
 		    /*
 		     * Then merge
 		     */
		    xsltMergeAttrElemList(style, values, refs);
		    /*
		     * Then suppress the reference
		     */
		    tmp->set = NULL;
		    tmp->ns = NULL;
		}
	    }
	}
	tmp = tmp->next;
     }
 }
","		       ATTRIBUTE_UNUSED const xmlChar *ignored) {
		    xsltResolveSASCallback(refs, style, name, ns, NULL);
"
"xsltRegisterExtModuleElement(const xmlChar * name, const xmlChar * URI,
                              xsltPreComputeFunction precomp,
                              xsltTransformFunction transform)
 {
    int ret;
 
     xsltExtElementPtr ext;
 
    if ((name == NULL) || (URI == NULL) || (transform == NULL))
        return (-1);

    if (xsltElementsHash == NULL)
        xsltElementsHash = xmlHashCreate(10);
    if (xsltElementsHash == NULL)
        return (-1);

    xmlMutexLock(xsltExtMutex);

    ext = xsltNewExtElement(precomp, transform);
    if (ext == NULL) {
        ret = -1;
        goto done;
    }

    xmlHashUpdateEntry2(xsltElementsHash, name, URI, (void *) ext,
                        (xmlHashDeallocator) xsltFreeExtElement);

 done:
     xmlMutexUnlock(xsltExtMutex);
 
    return (0);
 }
","    int ret;
    return (0);
"
"xsltFindTemplate(xsltTransformContextPtr ctxt, const xmlChar *name,
	         const xmlChar *nameURI) {
    xsltTemplatePtr cur;
    xsltStylesheetPtr style;

    if ((ctxt == NULL) || (name == NULL))
 	return(NULL);
     style = ctxt->style;
     while (style != NULL) {
	cur = style->templates;
	while (cur != NULL) {
	    if (xmlStrEqual(name, cur->name)) {
		if (((nameURI == NULL) && (cur->nameURI == NULL)) ||
		    ((nameURI != NULL) && (cur->nameURI != NULL) &&
		     (xmlStrEqual(nameURI, cur->nameURI)))) {
		    return(cur);
		}
	    }
	    cur = cur->next;
	}
 
 	style = xsltNextImport(style);
     }
    return(NULL);
}
","	cur = style->templates;
	while (cur != NULL) {
	    if (xmlStrEqual(name, cur->name)) {
		if (((nameURI == NULL) && (cur->nameURI == NULL)) ||
		    ((nameURI != NULL) && (cur->nameURI != NULL) &&
		     (xmlStrEqual(nameURI, cur->nameURI)))) {
		    return(cur);
		}
	    }
	    cur = cur->next;
	}
"
"xsltNumberFormatAlpha(xmlBufferPtr buffer,
		      double number,
		      int is_upper)
{
    char temp_string[sizeof(double) * CHAR_BIT * sizeof(xmlChar) + 1];
    char *pointer;
    int i;
     char *alpha_list;
     double alpha_size = (double)(sizeof(alpha_upper_list) - 1);
 
     /* Build buffer from back */
     pointer = &temp_string[sizeof(temp_string)];
     *(--pointer) = 0;
    alpha_list = (is_upper) ? alpha_upper_list : alpha_lower_list;

    for (i = 1; i < (int)sizeof(temp_string); i++) {
 	number--;
 	*(--pointer) = alpha_list[((int)fmod(number, alpha_size))];
 	number /= alpha_size;
	if (fabs(number) < 1.0)
 	    break; /* for */
     }
     xmlBufferCCat(buffer, pointer);
}
","	if (fabs(number) < 1.0)
"
"xsltNumberFormatGetMultipleLevel(xsltTransformContextPtr context,
				 xmlNodePtr node,
 				 xsltCompMatchPtr countPat,
 				 xsltCompMatchPtr fromPat,
 				 double *array,
				 int max,
				 xmlDocPtr doc,
				 xmlNodePtr elem)
 {
     int amount = 0;
     int cnt;
    xmlNodePtr ancestor;
    xmlNodePtr preceding;
    xmlXPathParserContextPtr parser;

    context->xpathCtxt->node = node;
    parser = xmlXPathNewParserContext(NULL, context->xpathCtxt);
    if (parser) {
	/* ancestor-or-self::*[count] */
	for (ancestor = node;
	     (ancestor != NULL) && (ancestor->type != XML_DOCUMENT_NODE);
	     ancestor = xmlXPathNextAncestor(parser, ancestor)) {

	    if ((fromPat != NULL) &&
 		xsltTestCompMatchList(context, ancestor, fromPat))
 		break; /* for */
 
	    if ((countPat == NULL && node->type == ancestor->type &&
		xmlStrEqual(node->name, ancestor->name)) ||
		xsltTestCompMatchList(context, ancestor, countPat)) {
 		/* count(preceding-sibling::*) */
		cnt = 0;
		for (preceding = ancestor;
 		     preceding != NULL;
 		     preceding =
 		        xmlXPathNextPrecedingSibling(parser, preceding)) {
		    if (countPat == NULL) {
			if ((preceding->type == ancestor->type) &&
			    xmlStrEqual(preceding->name, ancestor->name)){
			    if ((preceding->ns == ancestor->ns) ||
			        ((preceding->ns != NULL) &&
				 (ancestor->ns != NULL) &&
			         (xmlStrEqual(preceding->ns->href,
			             ancestor->ns->href) )))
			        cnt++;
			}
		    } else {
			if (xsltTestCompMatchList(context, preceding,
				                  countPat))
			    cnt++;
		    }
 		}
 		array[amount++] = (double)cnt;
 		if (amount >= max)
		    break; /* for */
	    }
	}
	xmlXPathFreeParserContext(parser);
    }
    return amount;
}
","				 int max,
				 xmlDocPtr doc,
				 xmlNodePtr elem)
	    if ((countPat == NULL && node->type == ancestor->type &&
		xmlStrEqual(node->name, ancestor->name)) ||
		xsltTestCompMatchList(context, ancestor, countPat)) {
		cnt = 0;
		for (preceding = ancestor;
		    if (countPat == NULL) {
			if ((preceding->type == ancestor->type) &&
			    xmlStrEqual(preceding->name, ancestor->name)){
			    if ((preceding->ns == ancestor->ns) ||
			        ((preceding->ns != NULL) &&
				 (ancestor->ns != NULL) &&
			         (xmlStrEqual(preceding->ns->href,
			             ancestor->ns->href) )))
			        cnt++;
			}
		    } else {
			if (xsltTestCompMatchList(context, preceding,
				                  countPat))
			    cnt++;
		    }
"
"xsltGetQNameProperty(xsltStylesheetPtr style, xmlNodePtr inst,
		     const xmlChar *propName,
		     int mandatory,
		     int *hasProp, const xmlChar **nsName,
		     const xmlChar** localName)
{
    const xmlChar *prop;

    if (nsName)
	*nsName = NULL;
    if (localName)
	*localName = NULL;
    if (hasProp)
	*hasProp = 0;

    prop = xsltGetCNsProp(style, inst, propName, XSLT_NAMESPACE);
    if (prop == NULL) {
	if (mandatory) {
	    xsltTransformError(NULL, style, inst,
		""The attribute '%s' is missing.\n"", propName);
	    style->errors++;
	    return;
	}
    } else {
        const xmlChar *URI;

	if (xmlValidateQName(prop, 0)) {
	    xsltTransformError(NULL, style, inst,
		""The value '%s' of the attribute ""
		""'%s' is not a valid QName.\n"", prop, propName);
	    style->errors++;
	    return;
	} else {
	    /*
	    * @prop will be in the string dict afterwards, @URI not.
	    */
	    URI = xsltGetQNameURI2(style, inst, &prop);
 	    if (prop == NULL) {
 		style->errors++;
 	    } else {
		*localName = prop;
 		if (hasProp)
 		    *hasProp = 1;
 		if (URI != NULL) {
		    /*
		    * Fixes bug #308441: Put the ns-name in the dict
		    * in order to pointer compare names during XPath's
		    * variable lookup.
		    */
		    if (nsName)
			*nsName = xmlDictLookup(style->dict, URI, -1);
		    /* comp->has_ns = 1; */
		}
	    }
	}
    }
    return;
}
","		*localName = prop;
"
"PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
     : content::RenderFrameObserver(render_frame),
       logging_state_active_(false),
       was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
   Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
 }
","      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
"
"UsbChooserContext::UsbChooserContext(Profile* profile)
    : ChooserContextBase(profile,
                         CONTENT_SETTINGS_TYPE_USB_GUARD,
                          CONTENT_SETTINGS_TYPE_USB_CHOOSER_DATA),
       is_incognito_(profile->IsOffTheRecord()),
       client_binding_(this),
      weak_factory_(this) {}
","      weak_factory_(this) {}
"
"status_t SampleTable::setCompositionTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
    ALOGI(""There are reordered frames present."");

 if (mCompositionTimeDeltaEntries != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header))
 < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 size_t numEntries = U32_AT(&header[4]);

 if (data_size != (numEntries + 1) * 8) {
 return ERROR_MALFORMED;

     }
 
     mNumCompositionTimeDeltaEntries = numEntries;
    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }

    mCompositionTimeDeltaEntries = new uint32_t[2 * numEntries];

 if (mDataSource->readAt(
                data_offset + 8, mCompositionTimeDeltaEntries, numEntries * 8)
 < (ssize_t)numEntries * 8) {
 delete[] mCompositionTimeDeltaEntries;
        mCompositionTimeDeltaEntries = NULL;

 return ERROR_IO;
 }

 for (size_t i = 0; i < 2 * numEntries; ++i) {
        mCompositionTimeDeltaEntries[i] = ntohl(mCompositionTimeDeltaEntries[i]);
 }

    mCompositionDeltaLookup->setEntries(
            mCompositionTimeDeltaEntries, mNumCompositionTimeDeltaEntries);

 return OK;
}
","    uint64_t allocSize = numEntries * 2 * sizeof(uint32_t);
"
"status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {
 if (mSyncSampleOffset >= 0 || data_size < 8) {
 return ERROR_MALFORMED;
 }

    mSyncSampleOffset = data_offset;

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mNumSyncSamples = U32_AT(&header[4]);

 if (mNumSyncSamples < 2) {

         ALOGV(""Table of sync samples is empty or has only a single entry!"");
     }
 
    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }

    mSyncSamples = new uint32_t[mNumSyncSamples];
 size_t size = mNumSyncSamples * sizeof(uint32_t);
 if (mDataSource->readAt(mSyncSampleOffset + 8, mSyncSamples, size)
 != (ssize_t)size) {
 return ERROR_IO;
 }

 for (size_t i = 0; i < mNumSyncSamples; ++i) {
        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;
 }

 return OK;
}
","    uint64_t allocSize = mNumSyncSamples * sizeof(uint32_t);
"
"status_t SampleTable::setTimeToSampleParams(
 off64_t data_offset, size_t data_size) {
 if (mTimeToSample != NULL || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;

     }
 
     mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
     if (allocSize > SIZE_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
    mTimeToSample = new uint32_t[mTimeToSampleCount * 2];

 size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
 if (mDataSource->readAt(
                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
 return ERROR_IO;
 }

 for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
        mTimeToSample[i] = ntohl(mTimeToSample[i]);
 }

 return OK;
}
","    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
"
"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

 
     android::Parcel* p = android::parcelForJavaObject(env, parcel);
 
     SkRegion* region = new SkRegion;
    size_t size = p->readInt32();
    region->readFromMemory(p->readInplace(size), size);
 
     return reinterpret_cast<jlong>(region);
 }
","    size_t size = p->readInt32();
    region->readFromMemory(p->readInplace(size), size);
"
" int32_t DownmixLib_Create(const effect_uuid_t *uuid,
        int32_t sessionId,
        int32_t ioId,
         effect_handle_t *pHandle) {
     int ret;
     int i;
 downmix_module_t *module;
 const effect_descriptor_t *desc;

    ALOGV(""DownmixLib_Create()"");

#ifdef DOWNMIX_TEST_CHANNEL_INDEX
    ALOGI(""DOWNMIX_TEST_CHANNEL_INDEX: should work:"");
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                    AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_CENTER);
 Downmix_testIndexComputation(CHANNEL_MASK_QUAD_SIDE | CHANNEL_MASK_QUAD_BACK);
 Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_SIDE | AUDIO_CHANNEL_OUT_BACK_CENTER);
 Downmix_testIndexComputation(CHANNEL_MASK_5POINT1_BACK | AUDIO_CHANNEL_OUT_BACK_CENTER);
    ALOGI(""DOWNMIX_TEST_CHANNEL_INDEX: should NOT work:"");
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                        AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_BACK_LEFT);
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT | AUDIO_CHANNEL_OUT_FRONT_RIGHT |
                            AUDIO_CHANNEL_OUT_LOW_FREQUENCY | AUDIO_CHANNEL_OUT_SIDE_LEFT);
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |
                        AUDIO_CHANNEL_OUT_BACK_LEFT | AUDIO_CHANNEL_OUT_BACK_RIGHT);
 Downmix_testIndexComputation(AUDIO_CHANNEL_OUT_FRONT_LEFT |
                            AUDIO_CHANNEL_OUT_SIDE_LEFT | AUDIO_CHANNEL_OUT_SIDE_RIGHT);
#endif

 if (pHandle == NULL || uuid == NULL) {
 return -EINVAL;
 }

 for (i = 0 ; i < kNbEffects ; i++) {
        desc = gDescriptors[i];
 if (memcmp(uuid, &desc->uuid, sizeof(effect_uuid_t)) == 0) {
 break;
 }
 }

 if (i == kNbEffects) {
 return -ENOENT;
 }

    module = malloc(sizeof(downmix_module_t));

    module->itfe = &gDownmixInterface;

    module->context.state = DOWNMIX_STATE_UNINITIALIZED;

    ret = Downmix_Init(module);
 if (ret < 0) {
        ALOGW(""DownmixLib_Create() init failed"");
        free(module);
 return ret;
 }

 *pHandle = (effect_handle_t) module;

    ALOGV(""DownmixLib_Create() %p , size %zu"", module, sizeof(downmix_module_t));

 return 0;
}
","        int32_t sessionId,
        int32_t ioId,
"
" int LELib_Create(const effect_uuid_t *uuid,
                         int32_t sessionId,
                         int32_t ioId,
                          effect_handle_t *pHandle) {
     ALOGV(""LELib_Create()"");
     int ret;
 int i;

 if (pHandle == NULL || uuid == NULL) {
 return -EINVAL;
 }

 if (memcmp(uuid, &gLEDescriptor.uuid, sizeof(effect_uuid_t)) != 0) {
 return -EINVAL;
 }

 LoudnessEnhancerContext *pContext = new LoudnessEnhancerContext;

    pContext->mItfe = &gLEInterface;
    pContext->mState = LOUDNESS_ENHANCER_STATE_UNINITIALIZED;

    pContext->mCompressor = NULL;
    ret = LE_init(pContext);
 if (ret < 0) {
        ALOGW(""LELib_Create() init failed"");
 delete pContext;
 return ret;
 }

 *pHandle = (effect_handle_t)pContext;

    pContext->mState = LOUDNESS_ENHANCER_STATE_INITIALIZED;

    ALOGV(""  LELib_Create context is %p"", pContext);

 return 0;

}
","                         int32_t sessionId,
                         int32_t ioId,
"
"int NsGetParameter(preproc_effect_t  *effect,
                   void              *pParam,
                   uint32_t          *pValueSize,
                   void              *pValue)
 {
     int status = 0;
     return status;
 }
","                   void              *pParam,
                   uint32_t          *pValueSize,
                   void              *pValue)
"
"OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {
    return (OMX_BUFFERHEADERTYPE *)buffer;
}
","    return (OMX_BUFFERHEADERTYPE *)buffer;
}
"
"OMX::buffer_id OMXNodeInstance::findBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
    return (OMX::buffer_id)bufferHeader;
}
","    return (OMX::buffer_id)bufferHeader;
}
"
"void OMXNodeInstance::invalidateBufferID(OMX::buffer_id buffer __unused) {
}
","}
"
"OMX::buffer_id OMXNodeInstance::makeBufferID(OMX_BUFFERHEADERTYPE *bufferHeader) {
    return (OMX::buffer_id)bufferHeader;
}
","    return (OMX::buffer_id)bufferHeader;
}
"
" ssize_t MPEG4DataSource::readAt(off64_t offset, void *data, size_t size) {
     Mutex::Autolock autoLock(mLock);
 
    if (offset >= mCachedOffset
            && offset + size <= mCachedOffset + mCachedSize) {
         memcpy(data, &mCache[offset - mCachedOffset], size);
         return size;
     }

 return mSource->readAt(offset, data, size);
}
","    if (offset >= mCachedOffset
            && offset + size <= mCachedOffset + mCachedSize) {
"
" virtual ssize_t readAt(off64_t offset, void *buffer, size_t size) {
 Parcel data, reply;
        data.writeInterfaceToken(
 IMediaHTTPConnection::getInterfaceDescriptor());

        data.writeInt64(offset);
        data.writeInt32(size);

 status_t err = remote()->transact(READ_AT, data, &reply);
 if (err != OK) {
            ALOGE(""remote readAt failed"");
 return UNKNOWN_ERROR;
 }

 int32_t exceptionCode = reply.readExceptionCode();

 if (exceptionCode) {

             return UNKNOWN_ERROR;
         }
 
        int32_t len = reply.readInt32();
 
        if (len > 0) {
            memcpy(buffer, mMemory->pointer(), len);
         }
 
         return len;
     }
","        int32_t len = reply.readInt32();
        if (len > 0) {
            memcpy(buffer, mMemory->pointer(), len);
"
"status_t GraphicBuffer::unflatten(
 void const*& buffer, size_t& size, int const*& fds, size_t& count) {
 if (size < 8*sizeof(int)) return NO_MEMORY;

 int const* buf = static_cast<int const*>(buffer);
 if (buf[0] != 'GBFR') return BAD_TYPE;


     const size_t numFds  = buf[8];
     const size_t numInts = buf[9];
 
     const size_t sizeNeeded = (10 + numInts) * sizeof(int);
     if (size < sizeNeeded) return NO_MEMORY;
 
    size_t fdCountNeeded = 0;
     if (count < fdCountNeeded) return NO_MEMORY;
 
     if (handle) {
        free_handle();
 }

 if (numFds || numInts) {
        width  = buf[1];
        height = buf[2];
        stride = buf[3];

         format = buf[4];
         usage  = buf[5];
         native_handle* h = native_handle_create(numFds, numInts);
         memcpy(h->data,          fds,     numFds*sizeof(int));
         memcpy(h->data + numFds, &buf[10], numInts*sizeof(int));
         handle = h;
 } else {
        width = height = stride = format = usage = 0;
        handle = NULL;
 }

    mId = static_cast<uint64_t>(buf[6]) << 32;
    mId |= static_cast<uint32_t>(buf[7]);

    mOwner = ownHandle;

 if (handle != 0) {
 status_t err = mBufferMapper.registerBuffer(handle);
 if (err != NO_ERROR) {
            width = height = stride = format = usage = 0;
            handle = NULL;
            ALOGE(""unflatten: registerBuffer failed: %s (%d)"",
                    strerror(-err), err);
 return err;
 }
 }

    buffer = reinterpret_cast<void const*>(static_cast<int const*>(buffer) + sizeNeeded);
    size -= sizeNeeded;
    fds += numFds;
    count -= numFds;

 return NO_ERROR;
}
","    size_t fdCountNeeded = 0;
"
"static vpx_codec_err_t vp8_peek_si_internal(const uint8_t *data,
 unsigned int data_sz,
 vpx_codec_stream_info_t *si,
                                            vpx_decrypt_cb decrypt_cb,
 void *decrypt_state)
{
 vpx_codec_err_t res = VPX_CODEC_OK;

 if(data + data_sz <= data)
 {
        res = VPX_CODEC_INVALID_PARAM;
 }
 else
 {
 /* Parse uncompresssed part of key frame header.
         * 3 bytes:- including version, frame type and an offset
         * 3 bytes:- sync code (0x9d, 0x01, 0x2a)
         * 4 bytes:- including image width and height in the lowest 14 bits
         *           of each 2-byte value.
         */
 uint8_t clear_buffer[10];
 const uint8_t *clear = data;
 if (decrypt_cb)
 {
 int n = MIN(sizeof(clear_buffer), data_sz);
            decrypt_cb(decrypt_state, data, clear_buffer, n);
            clear = clear_buffer;
 }
        si->is_kf = 0;

 if (data_sz >= 10 && !(clear[0] & 0x01)) /* I-Frame */
 {
            si->is_kf = 1;

 /* vet via sync code */
 if (clear[3] != 0x9d || clear[4] != 0x01 || clear[5] != 0x2a)
 return VPX_CODEC_UNSUP_BITSTREAM;

            si->w = (clear[6] | (clear[7] << 8)) & 0x3fff;

             si->h = (clear[8] | (clear[9] << 8)) & 0x3fff;
 
             /*printf(""w=%d, h=%d\n"", si->w, si->h);*/
            if (!(si->h | si->w))
                res = VPX_CODEC_UNSUP_BITSTREAM;
         }
         else
         {
            res = VPX_CODEC_UNSUP_BITSTREAM;
 }
 }

 return res;
}
","            if (!(si->h | si->w))
                res = VPX_CODEC_UNSUP_BITSTREAM;
"
"status_t MediaHTTP::connect(
 const char *uri,
 const KeyedVector<String8, String8> *headers,
 off64_t /* offset */) {
 if (mInitCheck != OK) {
 return mInitCheck;
 }

 KeyedVector<String8, String8> extHeaders;
 if (headers != NULL) {
        extHeaders = *headers;
 }

 if (extHeaders.indexOfKey(String8(""User-Agent"")) < 0) {

         extHeaders.add(String8(""User-Agent""), String8(MakeUserAgent().c_str()));
     }
 
    bool success = mHTTPConnection->connect(uri, &extHeaders);
 
     mLastHeaders = extHeaders;
    mLastURI = uri;
 
     mCachedSizeValid = false;
 
     if (success) {
        AString sanitized = uriDebugString(uri);
         mName = String8::format(""MediaHTTP(%s)"", sanitized.c_str());
     }
 
 return success ? OK : UNKNOWN_ERROR;
}
","    bool success = mHTTPConnection->connect(uri, &extHeaders);
    mLastURI = uri;
        AString sanitized = uriDebugString(uri);
"
"void RilSapSocket::sendDisconnect() {
 size_t encoded_size = 0;
 uint32_t written_size;
 size_t buffer_size = 0;
 pb_ostream_t ostream;
 bool success = false;

    RIL_SIM_SAP_DISCONNECT_REQ disconnectReq;


    if ((success = pb_get_encoded_size(&encoded_size, RIL_SIM_SAP_DISCONNECT_REQ_fields,
         &disconnectReq)) && encoded_size <= INT32_MAX) {
         buffer_size = encoded_size + sizeof(uint32_t);
        uint8_t buffer[buffer_size];
         written_size = htonl((uint32_t) encoded_size);
         ostream = pb_ostream_from_buffer(buffer, buffer_size);
         pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
        success = pb_encode(&ostream, RIL_SIM_SAP_DISCONNECT_REQ_fields, buffer);

 if(success) {
 pb_bytes_array_t *payload = (pb_bytes_array_t *)calloc(1,
 sizeof(pb_bytes_array_t) + written_size);
 if (!payload) {
                RLOGE(""sendDisconnect: OOM"");
 return;
 }
            memcpy(payload->bytes, buffer, written_size);
            payload->size = written_size;
 MsgHeader *hdr = (MsgHeader *)malloc(sizeof(MsgHeader));
 if (!hdr) {
                RLOGE(""sendDisconnect: OOM"");
                free(payload);
 return;
 }
            hdr->payload = payload;
            hdr->type = MsgType_REQUEST;
            hdr->id = MsgId_RIL_SIM_SAP_DISCONNECT;
            hdr->error = Error_RIL_E_SUCCESS;
            dispatchDisconnect(hdr);
 }

         else {
             RLOGE(""Encode failed in send disconnect!"");
         }
     }
 }
","        uint8_t buffer[buffer_size];
"
"void RilSapSocket::sendResponse(MsgHeader* hdr) {
 size_t encoded_size = 0;
 uint32_t written_size;
 size_t buffer_size = 0;
 pb_ostream_t ostream;
 bool success = false;

    pthread_mutex_lock(&write_lock);


     if ((success = pb_get_encoded_size(&encoded_size, MsgHeader_fields,
         hdr)) && encoded_size <= INT32_MAX && commandFd != -1) {
         buffer_size = encoded_size + sizeof(uint32_t);
        uint8_t buffer[buffer_size];
         written_size = htonl((uint32_t) encoded_size);
         ostream = pb_ostream_from_buffer(buffer, buffer_size);
         pb_write(&ostream, (uint8_t *)&written_size, sizeof(written_size));
        success = pb_encode(&ostream, MsgHeader_fields, hdr);

 if (success) {
            RLOGD(""Size: %d (0x%x) Size as written: 0x%x"", encoded_size, encoded_size,
        written_size);
            log_hex(""onRequestComplete"", &buffer[sizeof(written_size)], encoded_size);
            RLOGI(""[%d] < SAP RESPONSE type: %d. id: %d. error: %d"",
        hdr->token, hdr->type, hdr->id,hdr->error );

 if ( 0 != blockingWrite_helper(commandFd, buffer, buffer_size)) {
                RLOGE(""Error %d while writing to fd"", errno);
 } else {
                RLOGD(""Write successful"");
 }
 } else {

             RLOGE(""Error while encoding response of type %d id %d buffer_size: %d: %s."",
             hdr->type, hdr->id, buffer_size, PB_GET_ERROR(&ostream));
         }
     } else {
     RLOGE(""Not sending response type %d: encoded_size: %u. commandFd: %d. encoded size result: %d"",
         hdr->type, encoded_size, commandFd, success);
 }

    pthread_mutex_unlock(&write_lock);
}
","        uint8_t buffer[buffer_size];
"
" bool FrameworkListener::onDataAvailable(SocketClient *c) {
 char buffer[CMD_BUF_SIZE];
 int len;

    len = TEMP_FAILURE_RETRY(read(c->getSocket(), buffer, sizeof(buffer)));

     if (len < 0) {
         SLOGE(""read() failed (%s)"", strerror(errno));
         return false;
    } else if (!len)
         return false;
   if(buffer[len-1] != '\0')
         SLOGW(""String is not zero-terminated"");
 
     int offset = 0;
     int i;


     for (i = 0; i < len; i++) {
         if (buffer[i] == '\0') {
             /* IMPORTANT: dispatchCommand() expects a zero-terminated string */
            dispatchCommand(c, buffer + offset);
             offset = i + 1;
         }
     }
 
     return true;
 }
","    } else if (!len)
   if(buffer[len-1] != '\0')
            dispatchCommand(c, buffer + offset);
"
"ID3::ID3(const uint8_t *data, size_t size, bool ignoreV1)
 : mIsValid(false),
      mData(NULL),
      mSize(0),

       mFirstFrameOffset(0),
       mVersion(ID3_UNKNOWN),
       mRawSize(0) {
    sp<MemorySource> source = new MemorySource(data, size);
 
     mIsValid = parseV2(source, 0);
 
 if (!mIsValid && !ignoreV1) {
        mIsValid = parseV1(source);
 }
}
","    sp<MemorySource> source = new MemorySource(data, size);
"
"size_t calculate_camera_metadata_entry_data_size(uint8_t type,
        size_t data_count) {
    if (type >= NUM_TYPES) return 0;
    size_t data_bytes = data_count *
            camera_metadata_type_size[type];
    return data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT);
}
","        size_t data_count) {
    if (type >= NUM_TYPES) return 0;
    size_t data_bytes = data_count *
            camera_metadata_type_size[type];
    return data_bytes <= 4 ? 0 : ALIGN_TO(data_bytes, DATA_ALIGNMENT);
}
"
"status_t SoundTriggerHwService::Module::startRecognition(sound_model_handle_t handle,
 const sp<IMemory>& dataMemory)
{
    ALOGV(""startRecognition() model handle %d"", handle);
 if (!captureHotwordAllowed()) {

         return PERMISSION_DENIED;
     }
 
    if (dataMemory != 0 && dataMemory->pointer() == NULL) {
        ALOGE(""startRecognition() dataMemory is non-0 but has NULL pointer()"");
         return BAD_VALUE;
 
     }
     AutoMutex lock(mLock);
     if (mServiceState == SOUND_TRIGGER_STATE_DISABLED) {
         return INVALID_OPERATION;
 }
    sp<Model> model = getModel(handle);

     if (model == 0) {
         return BAD_VALUE;
     }
    if ((dataMemory == 0) ||
            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {
        return BAD_VALUE;
    }
 
     if (model->mState == Model::STATE_ACTIVE) {
         return INVALID_OPERATION;
     }
 
    struct sound_trigger_recognition_config *config =
            (struct sound_trigger_recognition_config *)dataMemory->pointer();
 
     config->capture_handle = model->mCaptureIOHandle;
    config->capture_device = model->mCaptureDevice;
 status_t status = mHwDevice->start_recognition(mHwDevice, handle, config,
 SoundTriggerHwService::recognitionCallback,
 this);

 if (status == NO_ERROR) {
        model->mState = Model::STATE_ACTIVE;
        model->mConfig = *config;
 }

 return status;
}
","    if (dataMemory != 0 && dataMemory->pointer() == NULL) {
        ALOGE(""startRecognition() dataMemory is non-0 but has NULL pointer()"");
    if ((dataMemory == 0) ||
            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {
        return BAD_VALUE;
    }
    struct sound_trigger_recognition_config *config =
            (struct sound_trigger_recognition_config *)dataMemory->pointer();
"
"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

 {
     const char *perm = ""add"";
 
    if (uid >= AID_APP) {
         return 0; /* Don't allow apps to register services */
     }
 
 return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
","    if (uid >= AID_APP) {
"
"void close_all_sockets(atransport* t) {
    asocket* s;

 /* this is a little gross, but since s->close() *will* modify
    ** the list out from under you, your options are limited.
    */
    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);

 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close(s);
             goto restart;
         }
     }
}
","            local_socket_close(s);
"
"static void ptrace_siblings(pid_t pid, pid_t main_tid, std::set<pid_t>& tids) {
  char task_path[64];
//// Attach to a thread, and verify that it's still a member of the given process
 
  snprintf(task_path, sizeof(task_path), ""/proc/%d/task"", pid);
 
   std::unique_ptr<DIR, int (*)(DIR*)> d(opendir(task_path), closedir);
 
 if (!d) {
    ALOGE(""debuggerd: failed to open /proc/%d/task: %s"", pid, strerror(errno));
 return;
 }

 struct dirent* de;
 while ((de = readdir(d.get())) != NULL) {
 if (!strcmp(de->d_name, ""."") || !strcmp(de->d_name, "".."")) {
 continue;
 }

 char* end;
 pid_t tid = strtoul(de->d_name, &end, 10);
 if (*end) {
 continue;
 }

 if (tid == main_tid) {

       continue;
     }
 
    if (ptrace(PTRACE_ATTACH, tid, 0, 0) < 0) {
       ALOGE(""debuggerd: ptrace attach to %d failed: %s"", tid, strerror(errno));
       continue;
     }

    tids.insert(tid);
 }
}
","  char task_path[64];
  snprintf(task_path, sizeof(task_path), ""/proc/%d/task"", pid);
    if (ptrace(PTRACE_ATTACH, tid, 0, 0) < 0) {
"
"bool ASessionDescription::getDimensions(
 size_t index, unsigned long PT,
 int32_t *width, int32_t *height) const {

     *width = 0;
     *height = 0;
 
    char key[20];
    sprintf(key, ""a=framesize:%lu"", PT);
     AString value;
     if (!findAttribute(index, key, &value)) {
         return false;
 }

 const char *s = value.c_str();
 char *end;
 *width = strtoul(s, &end, 10);
    CHECK_GT(end, s);
    CHECK_EQ(*end, '-');

    s = end + 1;
 *height = strtoul(s, &end, 10);
    CHECK_GT(end, s);
    CHECK_EQ(*end, '\0');

 return true;
}
","    char key[20];
    sprintf(key, ""a=framesize:%lu"", PT);
"
"void ASessionDescription::getFormatType(
 size_t index, unsigned long *PT,
 AString *desc, AString *params) const {
 AString format;
    getFormat(index, &format);

 const char *lastSpacePos = strrchr(format.c_str(), ' ');
    CHECK(lastSpacePos != NULL);

 char *end;
 unsigned long x = strtoul(lastSpacePos + 1, &end, 10);
    CHECK_GT(end, lastSpacePos + 1);
    CHECK_EQ(*end, '\0');

 
     *PT = x;
 
    char key[20];
    sprintf(key, ""a=rtpmap:%lu"", x);
 
     CHECK(findAttribute(index, key, desc));
 
    sprintf(key, ""a=fmtp:%lu"", x);
     if (!findAttribute(index, key, params)) {
         params->clear();
     }
}
","    char key[20];
    sprintf(key, ""a=rtpmap:%lu"", x);
    sprintf(key, ""a=fmtp:%lu"", x);
"
"bool SoftVPX::outputBufferSafe(OMX_BUFFERHEADERTYPE *outHeader) {
 uint32_t width = outputBufferWidth();
 uint32_t height = outputBufferHeight();

     uint64_t nFilledLen = width;
     nFilledLen *= height;
     if (nFilledLen > UINT32_MAX / 3) {
        ALOGE(""b/29421675, nFilledLen overflow %llu w %u h %u"", nFilledLen, width, height);
         android_errorWriteLog(0x534e4554, ""29421675"");
         return false;
     } else if (outHeader->nAllocLen < outHeader->nFilledLen) {
        ALOGE(""b/27597103, buffer too small"");
        android_errorWriteLog(0x534e4554, ""27597103"");
 return false;
 }

 return true;
}
","        ALOGE(""b/29421675, nFilledLen overflow %llu w %u h %u"", nFilledLen, width, height);
"
"static char* allocFromUTF16(const char16_t* in, size_t len)

 {
     if (len == 0) return getEmptyString();
 
    const ssize_t bytes = utf16_to_utf8_length(in, len);
    if (bytes < 0) {
         return getEmptyString();
     }
 
    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
     ALOG_ASSERT(buf, ""Unable to allocate shared buffer"");
     if (!buf) {
         return getEmptyString();
     }
 
    char* str = (char*)buf->data();
    utf16_to_utf8(in, len, str);
    return str;
 }
","    const ssize_t bytes = utf16_to_utf8_length(in, len);
    if (bytes < 0) {
    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
    char* str = (char*)buf->data();
    utf16_to_utf8(in, len, str);
    return str;
"
" static char* allocFromUTF32(const char32_t* in, size_t len)
{
 if (len == 0) {

         return getEmptyString();
     }
 
    const ssize_t bytes = utf32_to_utf8_length(in, len);
    if (bytes < 0) {
         return getEmptyString();
     }
 
    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
     ALOG_ASSERT(buf, ""Unable to allocate shared buffer"");
     if (!buf) {
         return getEmptyString();
     }
 
    char* str = (char*) buf->data();
    utf32_to_utf8(in, len, str);
 
    return str;
 }
","    const ssize_t bytes = utf32_to_utf8_length(in, len);
    if (bytes < 0) {
    SharedBuffer* buf = SharedBuffer::alloc(bytes+1);
    char* str = (char*) buf->data();
    utf32_to_utf8(in, len, str);
    return str;
"
"ssize_t utf16_to_utf8_length(const char16_t *src, size_t src_len)
{
 if (src == NULL || src_len == 0) {
 return -1;
 }

 size_t ret = 0;

     const char16_t* const end = src + src_len;
     while (src < end) {
         if ((*src & 0xFC00) == 0xD800 && (src + 1) < end
                && (*++src & 0xFC00) == 0xDC00) {
             ret += 4;
            src++;
         } else {
             ret += utf32_codepoint_utf8_length((char32_t) *src++);
         }
 }
 return ret;
}
","                && (*++src & 0xFC00) == 0xDC00) {
            src++;
"
"static int a2dp_command(struct a2dp_stream_common *common, char cmd)
{
 char ack;


     DEBUG(""A2DP COMMAND %s"", dump_a2dp_ctrl_event(cmd));
 
     /* send command */
    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)
     {
         ERROR(""cmd failed (%s)"", strerror(errno));
         skt_disconnect(common->ctrl_fd);
        common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
 return -1;
 }

 /* wait for ack byte */
 if (a2dp_ctrl_receive(common, &ack, 1) < 0)
 return -1;

    DEBUG(""A2DP COMMAND %s DONE STATUS %d"", dump_a2dp_ctrl_event(cmd), ack);

 if (ack == A2DP_CTRL_ACK_INCALL_FAILURE)
 return ack;
 if (ack != A2DP_CTRL_ACK_SUCCESS)
 return -1;

 return 0;
}
","    if (send(common->ctrl_fd, &cmd, 1, MSG_NOSIGNAL) == -1)
"
" static int a2dp_ctrl_receive(struct a2dp_stream_common *common, void* buffer, int length)
 {
    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
     if (ret < 0)
     {
         ERROR(""ack failed (%s)"", strerror(errno));
         if (errno == EINTR)
         {
             /* retry again */
            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
             if (ret < 0)
             {
                ERROR(""ack failed (%s)"", strerror(errno));
               skt_disconnect(common->ctrl_fd);
               common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
 return -1;
 }
 }
 else
 {
               skt_disconnect(common->ctrl_fd);
               common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
 return -1;

 }
 }
 return ret;
}
","    int ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
            ret = recv(common->ctrl_fd, buffer, length, MSG_NOSIGNAL);
"
"static void a2dp_open_ctrl_path(struct a2dp_stream_common *common)
{
 int i;

 /* retry logic to catch any timing variations on control channel */
 for (i = 0; i < CTRL_CHAN_RETRY_COUNT; i++)
 {
 /* connect control channel if not already connected */
 if ((common->ctrl_fd = skt_connect(A2DP_CTRL_PATH, common->buffer_sz)) > 0)
 {
 /* success, now check if stack is ready */
 if (check_a2dp_ready(common) == 0)

                 break;
 
             ERROR(""error : a2dp not ready, wait 250 ms and retry"");
            usleep(250000);
             skt_disconnect(common->ctrl_fd);
             common->ctrl_fd = AUDIO_SKT_DISCONNECTED;
         }
 
         /* ctrl channel not ready, wait a bit */
        usleep(250000);
     }
 }
","            usleep(250000);
        usleep(250000);
"
"static ssize_t in_read(struct audio_stream_in *stream, void* buffer,
 size_t bytes)
{
 struct a2dp_stream_in *in = (struct a2dp_stream_in *)stream;
 int read;

    DEBUG(""read %zu bytes, state: %d"", bytes, in->common.state);

 if (in->common.state == AUDIO_A2DP_STATE_SUSPENDED)
 {
        DEBUG(""stream suspended"");
 return -1;
 }

 /* only allow autostarting if we are in stopped or standby */
 if ((in->common.state == AUDIO_A2DP_STATE_STOPPED) ||
 (in->common.state == AUDIO_A2DP_STATE_STANDBY))
 {
        pthread_mutex_lock(&in->common.lock);

 if (start_audio_datapath(&in->common) < 0)
 {
 /* emulate time this write represents to avoid very fast write
               failures during transition periods or remote suspend */

 int us_delay = calc_audiotime(in->common.cfg, bytes);

 
             DEBUG(""emulate a2dp read delay (%d us)"", us_delay);
 
            usleep(us_delay);
             pthread_mutex_unlock(&in->common.lock);
             return -1;
         }

        pthread_mutex_unlock(&in->common.lock);
 }
 else if (in->common.state != AUDIO_A2DP_STATE_STARTED)
 {
        ERROR(""stream not in stopped or standby"");
 return -1;
 }

    read = skt_read(in->common.audio_fd, buffer, bytes);

 if (read == -1)
 {
        skt_disconnect(in->common.audio_fd);
        in->common.audio_fd = AUDIO_SKT_DISCONNECTED;
        in->common.state = AUDIO_A2DP_STATE_STOPPED;
 } else if (read == 0) {
        DEBUG(""read time out - return zeros"");
        memset(buffer, 0, bytes);
        read = bytes;
 }

    DEBUG(""read %d bytes out of %zu bytes"", read, bytes);
 return read;
}
","            usleep(us_delay);
"
"static ssize_t out_write(struct audio_stream_out *stream, const void* buffer,
 size_t bytes)
{
 struct a2dp_stream_out *out = (struct a2dp_stream_out *)stream;
 int sent;

    DEBUG(""write %zu bytes (fd %d)"", bytes, out->common.audio_fd);

    pthread_mutex_lock(&out->common.lock);

 if (out->common.state == AUDIO_A2DP_STATE_SUSPENDED)
 {
        DEBUG(""stream suspended"");
        pthread_mutex_unlock(&out->common.lock);
 return -1;
 }

 /* only allow autostarting if we are in stopped or standby */
 if ((out->common.state == AUDIO_A2DP_STATE_STOPPED) ||
 (out->common.state == AUDIO_A2DP_STATE_STANDBY))
 {
 if (start_audio_datapath(&out->common) < 0)
 {
 /* emulate time this write represents to avoid very fast write
               failures during transition periods or remote suspend */

 int us_delay = calc_audiotime(out->common.cfg, bytes);

 
             DEBUG(""emulate a2dp write delay (%d us)"", us_delay);
 
            usleep(us_delay);
             pthread_mutex_unlock(&out->common.lock);
             return -1;
         }
 }
 else if (out->common.state != AUDIO_A2DP_STATE_STARTED)
 {
        ERROR(""stream not in stopped or standby"");
        pthread_mutex_unlock(&out->common.lock);
 return -1;
 }

    pthread_mutex_unlock(&out->common.lock);
    sent = skt_write(out->common.audio_fd, buffer,  bytes);

 if (sent == -1) {
        skt_disconnect(out->common.audio_fd);
        out->common.audio_fd = AUDIO_SKT_DISCONNECTED;
 if (out->common.state != AUDIO_A2DP_STATE_SUSPENDED)
            out->common.state = AUDIO_A2DP_STATE_STOPPED;
 else
            ERROR(""write failed : stream suspended, avoid resetting state"");
 } else {
 const size_t frames = bytes / audio_stream_out_frame_size(stream);
        out->frames_rendered += frames;
        out->frames_presented += frames;
 }

    DEBUG(""wrote %d bytes out of %zu bytes"", sent, bytes);
 return sent;
}
","            usleep(us_delay);
"
"static int skt_read(int fd, void *p, size_t len)
{
 int read;
 struct pollfd pfd;
 struct timespec ts;

    FNLOG();

 
     ts_log(""skt_read recv"", len, NULL);
 
    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return read;
}
","    if ((read = recv(fd, p, len, MSG_NOSIGNAL)) == -1)
"
"static int skt_write(int fd, const void *p, size_t len)
{
 int sent;
 struct pollfd pfd;

    FNLOG();

    pfd.fd = fd;
    pfd.events = POLLOUT;


     /* poll for 500 ms */
 
     /* send time out */
    if (poll(&pfd, 1, 500) == 0)
         return 0;
 
     ts_log(""skt_write"", len, NULL);
 
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
     {
         ERROR(""write failed with errno=%d\n"", errno);
         return -1;
 }

 return sent;
}
","    if (poll(&pfd, 1, 500) == 0)
    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
"
"static void *btif_hh_poll_event_thread(void *arg)
{
 btif_hh_device_t *p_dev = arg;
    APPL_TRACE_DEBUG(""%s: Thread created fd = %d"", __FUNCTION__, p_dev->fd);
 struct pollfd pfds[1];
 int ret;

    pfds[0].fd = p_dev->fd;
    pfds[0].events = POLLIN;


     uhid_set_non_blocking(p_dev->fd);
 
     while(p_dev->hh_keep_polling){
        ret = poll(pfds, 1, 50);
         if (ret < 0) {
             APPL_TRACE_ERROR(""%s: Cannot poll for fds: %s\n"", __FUNCTION__, strerror(errno));
             break;
 }
 if (pfds[0].revents & POLLIN) {
            APPL_TRACE_DEBUG(""btif_hh_poll_event_thread: POLLIN"");
            ret = uhid_event(p_dev);
 if (ret){
 break;
 }
 }
 }

    p_dev->hh_poll_thread_id = -1;
 return 0;
}
","        ret = poll(pfds, 1, 50);
"
" static int uhid_write(int fd, const struct uhid_event *ev)
 {
    ssize_t ret = write(fd, ev, sizeof(*ev));
     if (ret < 0){
         int rtn = -errno;
         APPL_TRACE_ERROR(""%s: Cannot write to uhid:%s"",
                         __FUNCTION__, strerror(errno));
 return rtn;
 } else if (ret != (ssize_t)sizeof(*ev)) {
        APPL_TRACE_ERROR(""%s: Wrong size written to uhid: %zd != %zu"",
                         __FUNCTION__, ret, sizeof(*ev));
 return -EFAULT;
 }

 return 0;
}
","    ssize_t ret = write(fd, ev, sizeof(*ev));
"
"void bta_hl_co_put_rx_data (UINT8 app_id, tBTA_HL_MDL_HANDLE mdl_handle,
                            UINT16 data_size, UINT8 *p_data, UINT16 evt)
{
    UINT8 app_idx, mcl_idx, mdl_idx;
 btif_hl_mdl_cb_t *p_dcb;
    tBTA_HL_STATUS status = BTA_HL_STATUS_FAIL;
 int            r;
    BTIF_TRACE_DEBUG(""%s app_id=%d mdl_handle=0x%x data_size=%d"",
                      __FUNCTION__,app_id, mdl_handle, data_size);

 if (btif_hl_find_mdl_idx_using_handle(mdl_handle, &app_idx, &mcl_idx, &mdl_idx))
 {
        p_dcb = BTIF_HL_GET_MDL_CB_PTR(app_idx, mcl_idx, mdl_idx);

 if ((p_dcb->p_rx_pkt = (UINT8 *)btif_hl_get_buf(data_size)) != NULL)
 {
            memcpy(p_dcb->p_rx_pkt, p_data, data_size);
 if (p_dcb->p_scb)

             {
                 BTIF_TRACE_DEBUG(""app_idx=%d mcl_idx=0x%x mdl_idx=0x%x data_size=%d"",
                                   app_idx, mcl_idx, mdl_idx, data_size);
                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);
 
                 if (r == data_size)
                 {
                    BTIF_TRACE_DEBUG(""socket send success data_size=%d"",  data_size);
                    status = BTA_HL_STATUS_OK;
 }
 else
 {
                    BTIF_TRACE_ERROR(""socket send failed r=%d data_size=%d"",r, data_size);
 }


 }
            btif_hl_free_buf((void **) &p_dcb->p_rx_pkt);
 }
 }

    bta_hl_ci_put_rx_data(mdl_handle,  status, evt);
}
","                r = send(p_dcb->p_scb->socket_id[1], p_dcb->p_rx_pkt, data_size, 0);
"
"static void sync_lockstate_on_connect(btif_hh_device_t *p_dev)
{
 int keylockstates;

    BTIF_TRACE_EVENT(""%s: Syncing keyboard lock states after ""\
 ""reconnect..."",__FUNCTION__);
 /*If the device is connected, update keyboard state */
    update_keyboard_lockstates(p_dev);

 /*Check if the lockstate of caps,scroll,num is set.
     If so, send a report to the kernel
    so the lockstate is in sync */
    keylockstates = get_keylockstates();
 if (keylockstates)
 {

         BTIF_TRACE_DEBUG(""%s: Sending hid report to kernel ""\
             ""indicating lock key state 0x%x"",__FUNCTION__,
             keylockstates);
        usleep(200000);
         toggle_os_keylockstates(p_dev->fd, keylockstates);
     }
     else
 {
        BTIF_TRACE_DEBUG(""%s: NOT sending hid report to kernel ""\
 ""indicating lock key state 0x%x"",__FUNCTION__,
            keylockstates);
 }
}
","        usleep(200000);
"
"static inline int btif_hl_close_select_thread(void)
{

     int result = 0;
     char sig_on = btif_hl_signal_select_exit;
     BTIF_TRACE_DEBUG(""btif_hl_signal_select_exit"");
    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
     if (btif_is_enabled())
     {
         /* Wait for the select_thread_id to exit if BT is still enabled
        and only this profile getting  cleaned up*/
 if (select_thread_id != -1) {
            pthread_join(select_thread_id, NULL);
            select_thread_id = -1;
 }
 }
    list_free(soc_queue);
 return result;
}
","    result = send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
"
" static inline int btif_hl_select_close_connected(void){
     char sig_on = btif_hl_signal_select_close_connected;
     BTIF_TRACE_DEBUG(""btif_hl_select_close_connected"");
    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
 }
","    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
"
"static void *btif_hl_select_thread(void *arg){
    fd_set org_set, curr_set;
 int r, max_curr_s, max_org_s;
    UNUSED(arg);

    BTIF_TRACE_DEBUG(""entered btif_hl_select_thread"");
    FD_ZERO(&org_set);
    max_org_s = btif_hl_select_wakeup_init(&org_set);
    BTIF_TRACE_DEBUG(""max_s=%d "", max_org_s);

 for (;;)
 {
        r = 0;

         BTIF_TRACE_DEBUG(""set curr_set = org_set "");
         curr_set = org_set;
         max_curr_s = max_org_s;
        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);
         BTIF_TRACE_DEBUG(""select unblocked ret=%d"", ret);
         if (ret == -1)
         {
            BTIF_TRACE_DEBUG(""select() ret -1, exit the thread"");
            btif_hl_thread_cleanup();
            select_thread_id = -1;
 return 0;
 }
 else if (ret)
 {
            BTIF_TRACE_DEBUG(""btif_hl_select_wake_signaled, signal ret=%d"", ret);
 if (btif_hl_select_wake_signaled(&curr_set))
 {
                r = btif_hl_select_wake_reset();
                BTIF_TRACE_DEBUG(""btif_hl_select_wake_signaled, signal:%d"", r);
 if (r == btif_hl_signal_select_wakeup || r == btif_hl_signal_select_close_connected )
 {
                    btif_hl_select_wakeup_callback(&org_set, r);
 }
 else if( r == btif_hl_signal_select_exit)
 {
                    btif_hl_thread_cleanup();
                    BTIF_TRACE_DEBUG(""Exit hl_select_thread for btif_hl_signal_select_exit"");
 return 0;
 }
 }

            btif_hl_select_monitor_callback(&curr_set, &org_set);
            max_org_s = btif_hl_update_maxfd(max_org_s);
 }
 else
            BTIF_TRACE_DEBUG(""no data, select ret: %d\n"", ret);
 }
    BTIF_TRACE_DEBUG(""leaving hl_select_thread"");
 return 0;
}
","        int ret = select((max_curr_s + 1), &curr_set, NULL, NULL, NULL);
"
"static inline int btif_hl_select_wake_reset(void){

     char sig_recv = 0;
 
     BTIF_TRACE_DEBUG(""btif_hl_select_wake_reset"");
    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
     return(int)sig_recv;
 }
","    recv(signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
"
" static inline int btif_hl_select_wakeup(void){
     char sig_on = btif_hl_signal_select_wakeup;
     BTIF_TRACE_DEBUG(""btif_hl_select_wakeup"");
    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
 }
","    return send(signal_fds[1], &sig_on, sizeof(sig_on), 0);
"
"int btpan_tap_open()
{
 struct ifreq ifr;
 int fd, err;
 const char *clonedev = ""/dev/tun"";

 
     /* open the clone device */
 
    if ((fd = open(clonedev, O_RDWR)) < 0)
     {
         BTIF_TRACE_DEBUG(""could not open %s, err:%d"", clonedev, errno);
         return fd;
 }

    memset(&ifr, 0, sizeof(ifr));
    ifr.ifr_flags = IFF_TAP | IFF_NO_PI;


     strncpy(ifr.ifr_name, TAP_IF_NAME, IFNAMSIZ);
 
     /* try to create the device */
    if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0)
     {
         BTIF_TRACE_DEBUG(""ioctl error:%d, errno:%s"", err, strerror(errno));
         close(fd);
 return err;

     }
     if (tap_if_up(TAP_IF_NAME, controller_get_interface()->get_address()) == 0)
     {
        int flags = fcntl(fd, F_GETFL, 0);
        fcntl(fd, F_SETFL, flags | O_NONBLOCK);
         return fd;
     }
     BTIF_TRACE_ERROR(""can not bring up tap interface:%s"", TAP_IF_NAME);
    close(fd);
 return INVALID_FD;
}
","    if ((fd = open(clonedev, O_RDWR)) < 0)
    if ((err = ioctl(fd, TUNSETIFF, (void *) &ifr)) < 0)
        int flags = fcntl(fd, F_GETFL, 0);
        fcntl(fd, F_SETFL, flags | O_NONBLOCK);
"
"int btpan_tap_send(int tap_fd, const BD_ADDR src, const BD_ADDR dst, UINT16 proto, const char* buf,
                    UINT16 len, BOOLEAN ext, BOOLEAN forward)
{
    UNUSED(ext);
    UNUSED(forward);
 if (tap_fd != INVALID_FD)
 {
        tETH_HDR eth_hdr;
        memcpy(&eth_hdr.h_dest, dst, ETH_ADDR_LEN);
        memcpy(&eth_hdr.h_src, src, ETH_ADDR_LEN);
        eth_hdr.h_proto = htons(proto);
 char packet[TAP_MAX_PKT_WRITE_LEN + sizeof(tETH_HDR)];
        memcpy(packet, &eth_hdr, sizeof(tETH_HDR));
 if (len > TAP_MAX_PKT_WRITE_LEN)
 {
            LOG_ERROR(""btpan_tap_send eth packet size:%d is exceeded limit!"", len);
 return -1;
 }

         memcpy(packet + sizeof(tETH_HDR), buf, len);
 
         /* Send data to network interface */
        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));
         BTIF_TRACE_DEBUG(""ret:%d"", ret);
         return ret;
     }
 return -1;

}
","        int ret = write(tap_fd, packet, len + sizeof(tETH_HDR));
"
"static int tap_if_down(const char *devname)
{
 struct ifreq ifr;
 int sk;

    sk = socket(AF_INET, SOCK_DGRAM, 0);
 if (sk < 0)
 return -1;

    memset(&ifr, 0, sizeof(ifr));
    strncpy(ifr.ifr_name, devname, IF_NAMESIZE - 1);

 
     ifr.ifr_flags &= ~IFF_UP;
 
    ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);
 
     close(sk);
 
 return 0;
}
","    ioctl(sk, SIOCSIFFLAGS, (caddr_t) &ifr);
"
"void close_uinput (void)

 {
     BTIF_TRACE_DEBUG(""%s"", __FUNCTION__);
     if (uinput_fd > 0) {
        ioctl(uinput_fd, UI_DEV_DESTROY);
 
         close(uinput_fd);
         uinput_fd = -1;
 }
}
","        ioctl(uinput_fd, UI_DEV_DESTROY);
"
"int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
{
 struct uinput_event event;
    BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
        type, code, value);
    memset(&event, 0, sizeof(event));
    event.type  = type;

     event.code  = code;
     event.value = value;
 
    return write(fd, &event, sizeof(event));
 }
","    return write(fd, &event, sizeof(event));
"
"int uinput_create(char *name)
{
 struct uinput_dev dev;
 int fd, x = 0;

 
     for(x=0; x < MAX_UINPUT_PATHS; x++)
     {
        fd = open(uinput_dev_path[x], O_RDWR);
         if (fd < 0)
             continue;
         break;
 }
 if (x == MAX_UINPUT_PATHS) {
        BTIF_TRACE_ERROR(""%s ERROR: uinput device open failed"", __FUNCTION__);
 return -1;
 }
    memset(&dev, 0, sizeof(dev));
 if (name)
        strncpy(dev.name, name, UINPUT_MAX_NAME_SIZE-1);

    dev.id.bustype = BUS_BLUETOOTH;
    dev.id.vendor  = 0x0000;

     dev.id.product = 0x0000;
     dev.id.version = 0x0000;
 
    if (write(fd, &dev, sizeof(dev)) < 0) {
         BTIF_TRACE_ERROR(""%s Unable to write device information"", __FUNCTION__);
         close(fd);
         return -1;
     }
 
    ioctl(fd, UI_SET_EVBIT, EV_KEY);
    ioctl(fd, UI_SET_EVBIT, EV_REL);
    ioctl(fd, UI_SET_EVBIT, EV_SYN);
 
     for (x = 0; key_map[x].name != NULL; x++)
        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);
 
    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {
         BTIF_TRACE_ERROR(""%s Unable to create uinput device"", __FUNCTION__);
         close(fd);
         return -1;
 }
 return fd;
}
","        fd = open(uinput_dev_path[x], O_RDWR);
    if (write(fd, &dev, sizeof(dev)) < 0) {
    ioctl(fd, UI_SET_EVBIT, EV_KEY);
    ioctl(fd, UI_SET_EVBIT, EV_REL);
    ioctl(fd, UI_SET_EVBIT, EV_SYN);
        ioctl(fd, UI_SET_KEYBIT, key_map[x].mapped_id);
    if (ioctl(fd, UI_DEV_CREATE, NULL) < 0) {
"
"static BOOLEAN flush_incoming_que_on_wr_signal_l(l2cap_socket *sock)
{
 uint8_t *buf;

     uint32_t len;
 
     while (packet_get_head_l(sock, &buf, &len)) {
        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);
 
         if (sent == (signed)len)
             osi_free(buf);
 else if (sent >= 0) {
            packet_put_head_l(sock, buf + sent, len - sent);
            osi_free(buf);
 if (!sent) /* special case if other end not keeping up */
 return TRUE;
 }
 else {
            packet_put_head_l(sock, buf, len);
            osi_free(buf);
 return errno == EINTR || errno == EWOULDBLOCK || errno == EAGAIN;
 }
 }

 return FALSE;
}
","        int sent = send(sock->our_fd, buf, len, MSG_DONTWAIT);
"
"int bta_co_rfc_data_outgoing(void *user_data, uint8_t *buf, uint16_t size) {
  pthread_mutex_lock(&slot_lock);

 uint32_t id = (uintptr_t)user_data;
 int ret = false;
 rfc_slot_t *slot = find_rfc_slot_by_id(id);

   if (!slot)
     goto out;
 
  int received = recv(slot->fd, buf, size, 0);
   if(received == size) {
     ret = true;
   } else {
    LOG_ERROR(""%s error receiving RFCOMM data from app: %s"", __func__, strerror(errno));
    cleanup_rfc_slot(slot);
 }

out:;
  pthread_mutex_unlock(&slot_lock);
 return ret;
}
","  int received = recv(slot->fd, buf, size, 0);
"
"int bta_co_rfc_data_outgoing_size(void *user_data, int *size) {
  pthread_mutex_lock(&slot_lock);

 uint32_t id = (uintptr_t)user_data;
 int ret = false;
 *size = 0;
 rfc_slot_t *slot = find_rfc_slot_by_id(id);

   if (!slot)
     goto out;
 
  if (ioctl(slot->fd, FIONREAD, size) == 0) {
     ret = true;
   } else {
     LOG_ERROR(""%s unable to determine bytes remaining to be read on fd %d: %s"", __func__, slot->fd, strerror(errno));
    cleanup_rfc_slot(slot);
 }

out:;
  pthread_mutex_unlock(&slot_lock);
 return ret;
}
","  if (ioctl(slot->fd, FIONREAD, size) == 0) {
"
"void btsock_rfc_signaled(UNUSED_ATTR int fd, int flags, uint32_t user_id) {
  pthread_mutex_lock(&slot_lock);

 rfc_slot_t *slot = find_rfc_slot_by_id(user_id);
 if (!slot)
 goto out;

 bool need_close = false;

 if (flags & SOCK_THREAD_FD_RD && !slot->f.server) {

     if (slot->f.connected) {
       int size = 0;
      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(slot->fd, FIONREAD, &size) == 0 && size))
        pthread_mutex_unlock(&slot_lock);
         BTA_JvRfcommWrite(slot->rfc_handle, slot->id);
     } else {
       LOG_ERROR(""%s socket signaled for read while disconnected, slot: %d, channel: %d"", __func__, slot->id, slot->scn);
       need_close = true;
 }
 }

 if (flags & SOCK_THREAD_FD_WR) {
 if (!slot->f.connected || !flush_incoming_que_on_wr_signal(slot)) {
      LOG_ERROR(""%s socket signaled for write while disconnected (or write failure), slot: %d, channel: %d"", __func__, slot->id, slot->scn);
      need_close = true;
 }
 }


   if (need_close || (flags & SOCK_THREAD_FD_EXCEPTION)) {
     int size = 0;
    if (need_close || ioctl(slot->fd, FIONREAD, &size) != 0 || !size)
       cleanup_rfc_slot(slot);
   }
 
out:;
  pthread_mutex_unlock(&slot_lock);
}
","      if (!(flags & SOCK_THREAD_FD_EXCEPTION) || (ioctl(slot->fd, FIONREAD, &size) == 0 && size))
        pthread_mutex_unlock(&slot_lock);
    if (need_close || ioctl(slot->fd, FIONREAD, &size) != 0 || !size)
"
"static sent_status_t send_data_to_app(int fd, BT_HDR *p_buf) {

   if (p_buf->len == 0)
     return SENT_ALL;
 
  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);
 
   if (sent == -1) {
     if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)
 return SENT_NONE;
    LOG_ERROR(""%s error writing RFCOMM data back to app: %s"", __func__, strerror(errno));
 return SENT_FAILED;
 }

 if (sent == 0)
 return SENT_FAILED;

 if (sent == p_buf->len)
 return SENT_ALL;

  p_buf->offset += sent;
  p_buf->len -= sent;
 return SENT_PARTIAL;
}
","  ssize_t sent = send(fd, p_buf->data + p_buf->offset, p_buf->len, MSG_DONTWAIT);
"
"static inline int accept_server_socket(int s)

 {
     struct sockaddr_un client_address;
     socklen_t clen;
    int fd = accept(s, (struct sockaddr*)&client_address, &clen);
     APPL_TRACE_DEBUG(""accepted fd:%d for server fd:%d"", fd, s);
     return fd;
 }
","    int fd = accept(s, (struct sockaddr*)&client_address, &clen);
"
"int btsock_thread_add_fd(int h, int fd, int type, int flags, uint32_t user_id)
{
 if(h < 0 || h >= MAX_THREAD)
 {
        APPL_TRACE_ERROR(""invalid bt thread handle:%d"", h);
 return FALSE;
 }
 if(ts[h].cmd_fdw == -1)
 {
        APPL_TRACE_ERROR(""cmd socket is not created. socket thread may not initialized"");
 return FALSE;
 }
 if(flags & SOCK_THREAD_ADD_FD_SYNC)
 {
 if(ts[h].thread_id == pthread_self())
 {
            flags &= ~SOCK_THREAD_ADD_FD_SYNC;
            add_poll(h, fd, type, flags, user_id);
 return TRUE;
 }
        APPL_TRACE_DEBUG(""THREAD_ADD_FD_SYNC is not called in poll thread, fallback to async"");

     }
     sock_cmd_t cmd = {CMD_ADD_FD, fd, type, flags, user_id};
     APPL_TRACE_DEBUG(""adding fd:%d, flags:0x%x"", fd, flags);
    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
 }
","    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
"
" int btsock_thread_exit(int h)
 {
 if(h < 0 || h >= MAX_THREAD)
 {
        APPL_TRACE_ERROR(""invalid bt thread handle:%d"", h);
 return FALSE;
 }
 if(ts[h].cmd_fdw == -1)
 {
        APPL_TRACE_ERROR(""cmd socket is not created"");

         return FALSE;
     }
     sock_cmd_t cmd = {CMD_EXIT, 0, 0, 0, 0};
    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))
     {
         pthread_join(ts[h].thread_id, 0);
         pthread_mutex_lock(&thread_slot_lock);
        free_thread_slot(h);
        pthread_mutex_unlock(&thread_slot_lock);
 return TRUE;
 }
 return FALSE;
}
","    if(send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd))
"
" int btsock_thread_post_cmd(int h, int type, const unsigned char* data, int size, uint32_t user_id)
{
 if(h < 0 || h >= MAX_THREAD)
 {
        APPL_TRACE_ERROR(""invalid bt thread handle:%d"", h);
 return FALSE;
 }
 if(ts[h].cmd_fdw == -1)
 {
        APPL_TRACE_ERROR(""cmd socket is not created. socket thread may not initialized"");
 return FALSE;
 }
 sock_cmd_t cmd = {CMD_USER_PRIVATE, 0, type, size, user_id};
    APPL_TRACE_DEBUG(""post cmd type:%d, size:%d, h:%d, "", type, size, h);
 sock_cmd_t* cmd_send = &cmd;
 int size_send = sizeof(cmd);
 if(data && size)
 {
        size_send = sizeof(cmd) + size;
        cmd_send = (sock_cmd_t*)alloca(size_send);
 if(cmd_send)
 {
 *cmd_send = cmd;
            memcpy(cmd_send + 1, data, size);
 }
 else
 {
            APPL_TRACE_ERROR(""alloca failed at h:%d, cmd type:%d, size:%d"", h, type, size_send);

             return FALSE;
         }
     }
    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;
 }
","    return send(ts[h].cmd_fdw, cmd_send, size_send, 0) == size_send;
"
" bool btsock_thread_remove_fd_and_close(int thread_handle, int fd)
{
 if (thread_handle < 0 || thread_handle >= MAX_THREAD)
 {
        APPL_TRACE_ERROR(""%s invalid thread handle: %d"", __func__, thread_handle);
 return false;
 }
 if (fd == -1)
 {
        APPL_TRACE_ERROR(""%s invalid file descriptor."", __func__);
 return false;

     }
 
     sock_cmd_t cmd = {CMD_REMOVE_FD, fd, 0, 0, 0};
    return send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
 }
","    return send(ts[thread_handle].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
"
" int btsock_thread_wakeup(int h)
 {
 if(h < 0 || h >= MAX_THREAD)
 {
        APPL_TRACE_ERROR(""invalid bt thread handle:%d"", h);
 return FALSE;
 }
 if(ts[h].cmd_fdw == -1)
 {
        APPL_TRACE_ERROR(""thread handle:%d, cmd socket is not created"", h);

         return FALSE;
     }
     sock_cmd_t cmd = {CMD_WAKEUP, 0, 0, 0, 0};
    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
 }
","    return send(ts[h].cmd_fdw, &cmd, sizeof(cmd), 0) == sizeof(cmd);
"
"static int process_cmd_sock(int h)

 {
     sock_cmd_t cmd = {-1, 0, 0, 0, 0};
     int fd = ts[h].cmd_fdr;
    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))
     {
         APPL_TRACE_ERROR(""recv cmd errno:%d"", errno);
         return FALSE;
 }
    APPL_TRACE_DEBUG(""cmd.id:%d"", cmd.id);
 switch(cmd.id)
 {
 case CMD_ADD_FD:
            add_poll(h, cmd.fd, cmd.type, cmd.flags, cmd.user_id);
 break;
 case CMD_REMOVE_FD:
 for (int i = 1; i < MAX_POLL; ++i)
 {
 poll_slot_t *poll_slot = &ts[h].ps[i];
 if (poll_slot->pfd.fd == cmd.fd)
 {
                    remove_poll(h, poll_slot, poll_slot->flags);
 break;
 }
 }
            close(cmd.fd);
 break;
 case CMD_WAKEUP:
 break;
 case CMD_USER_PRIVATE:
            asrt(ts[h].cmd_callback);
 if(ts[h].cmd_callback)
                ts[h].cmd_callback(fd, cmd.type, cmd.flags, cmd.user_id);
 break;
 case CMD_EXIT:
 return FALSE;
 default:
            APPL_TRACE_DEBUG(""unknown cmd: %d"", cmd.id);
 break;
 }
 return TRUE;
}
","    if(recv(fd, &cmd, sizeof(cmd), MSG_WAITALL) != sizeof(cmd))
"
" static inline void set_socket_blocking(int s, int blocking)
 {
     int opts;
    opts = fcntl(s, F_GETFL);
     if (opts<0) APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
     if(blocking)
         opts &= ~O_NONBLOCK;
     else opts |= O_NONBLOCK;
    if (fcntl(s, F_SETFL, opts) < 0)
         APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
 }
","    opts = fcntl(s, F_GETFL);
    if (fcntl(s, F_SETFL, opts) < 0)
"
"static void *sock_poll_thread(void *arg)
{
 struct pollfd pfds[MAX_POLL];
    memset(pfds, 0, sizeof(pfds));
 int h = (intptr_t)arg;

     for(;;)
     {
         prepare_poll_fds(h, pfds);
        int ret = poll(pfds, ts[h].poll_count, -1);
         if(ret == -1)
         {
             APPL_TRACE_ERROR(""poll ret -1, exit the thread, errno:%d, err:%s"", errno, strerror(errno));
 break;
 }
 if(ret != 0)
 {
 int need_process_data_fd = TRUE;
 if(pfds[0].revents) //cmd fd always is the first one
 {
                asrt(pfds[0].fd == ts[h].cmd_fdr);
 if(!process_cmd_sock(h))
 {
                    APPL_TRACE_DEBUG(""h:%d, process_cmd_sock return false, exit..."", h);
 break;
 }
 if(ret == 1)
                    need_process_data_fd = FALSE;
 else ret--; //exclude the cmd fd
 }
 if(need_process_data_fd)
                process_data_sock(h, pfds, ret);
 }
 else {APPL_TRACE_DEBUG(""no data, select ret: %d"", ret)};
 }
    ts[h].thread_id = -1;
    APPL_TRACE_DEBUG(""socket poll thread exiting, h:%d"", h);
 return 0;
}
","        int ret = poll(pfds, ts[h].poll_count, -1);
"
"int sock_recv_all(int sock_fd, uint8_t* buf, int len)
{
 int r = len;

     int ret = -1;
     while(r)
     {
        do ret = recv(sock_fd, buf, r, MSG_WAITALL);
         while(ret < 0 && errno == EINTR);
         if(ret <= 0)
         {
            BTIF_TRACE_ERROR(""sock fd:%d recv errno:%d, ret:%d"", sock_fd, errno, ret);
 return -1;
 }
        buf += ret;
        r -= ret;
 }
 return len;
}
","        do ret = recv(sock_fd, buf, r, MSG_WAITALL);
"
"int sock_send_all(int sock_fd, const uint8_t* buf, int len)
{
 int s = len;

     int ret;
     while(s)
     {
        do ret = send(sock_fd, buf, s, 0);
         while(ret < 0 && errno == EINTR);
         if(ret <= 0)
         {
            BTIF_TRACE_ERROR(""sock fd:%d send errno:%d, ret:%d"", sock_fd, errno, ret);
 return -1;
 }
        buf += ret;
        s -= ret;
 }
 return len;
}
","        do ret = send(sock_fd, buf, s, 0);
"
"int sock_send_fd(int sock_fd, const uint8_t* buf, int len, int send_fd)
{
 ssize_t ret;
 struct msghdr msg;
 unsigned char *buffer = (unsigned char *)buf;
    memset(&msg, 0, sizeof(msg));

 struct cmsghdr *cmsg;
 char msgbuf[CMSG_SPACE(1)];
    asrt(send_fd != -1);
 if(sock_fd == -1 || send_fd == -1)
 return -1;
    msg.msg_control = msgbuf;
    msg.msg_controllen = sizeof msgbuf;
    cmsg = CMSG_FIRSTHDR(&msg);
    cmsg->cmsg_level = SOL_SOCKET;
    cmsg->cmsg_type = SCM_RIGHTS;
    cmsg->cmsg_len = CMSG_LEN(sizeof send_fd);
    memcpy(CMSG_DATA(cmsg), &send_fd, sizeof send_fd);

 int ret_len = len;
 while (len > 0) {
 struct iovec iv;
        memset(&iv, 0, sizeof(iv));

        iv.iov_base = buffer;
        iv.iov_len = len;

        msg.msg_iov = &iv;

         msg.msg_iovlen = 1;
 
         do {
            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);
         } while (ret < 0 && errno == EINTR);
 
         if (ret < 0) {
            BTIF_TRACE_ERROR(""fd:%d, send_fd:%d, sendmsg ret:%d, errno:%d, %s"",
                              sock_fd, send_fd, (int)ret, errno, strerror(errno));
            ret_len = -1;
 break;
 }

        buffer += ret;
        len -= ret;

        memset(&msg, 0, sizeof(msg));
 }
    BTIF_TRACE_DEBUG(""close fd:%d after sent"", send_fd);
    close(send_fd);
 return ret_len;
}
","            ret = sendmsg(sock_fd, &msg, MSG_NOSIGNAL);
"
"void GKI_delay(UINT32 timeout_ms) {
 struct timespec delay;
  delay.tv_sec = timeout_ms / 1000;
  delay.tv_nsec = 1000 * 1000 * (timeout_ms % 1000);

 
   int err;
   do {
    err = nanosleep(&delay, &delay);
   } while (err == -1 && errno == EINTR);
 }
","    err = nanosleep(&delay, &delay);
"
" static void btsnoop_write(const void *data, size_t length) {
   if (logfile_fd != INVALID_FD)
    write(logfile_fd, data, length);
 
   btsnoop_net_write(data, length);
 }
","    write(logfile_fd, data, length);
"
"static void update_logging() {
 bool should_log = module_started &&
 (logging_enabled_via_api || stack_config->get_btsnoop_turned_on());

 if (should_log == is_logging)
 return;

  is_logging = should_log;
 if (should_log) {
    btsnoop_net_open();

 const char *log_path = stack_config->get_btsnoop_log_path();

 if (stack_config->get_btsnoop_should_save_last()) {
 char last_log_path[PATH_MAX];
      snprintf(last_log_path, PATH_MAX, ""%s.%llu"", log_path, btsnoop_timestamp());
 if (!rename(log_path, last_log_path) && errno != ENOENT)

         LOG_ERROR(""%s unable to rename '%s' to '%s': %s"", __func__, log_path, last_log_path, strerror(errno));
     }
 
    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
     if (logfile_fd == INVALID_FD) {
       LOG_ERROR(""%s unable to open '%s': %s"", __func__, log_path, strerror(errno));
       is_logging = false;
       return;
     }
 
    write(logfile_fd, ""btsnoop\0\0\0\0\1\0\0\x3\xea"", 16);
   } else {
     if (logfile_fd != INVALID_FD)
       close(logfile_fd);

    logfile_fd = INVALID_FD;
    btsnoop_net_close();
 }
}
","    logfile_fd = open(log_path, O_WRONLY | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
    write(logfile_fd, ""btsnoop\0\0\0\0\1\0\0\x3\xea"", 16);
"
"void btsnoop_net_write(const void *data, size_t length) {
#if (!defined(BT_NET_DEBUG) || (BT_NET_DEBUG != TRUE))
 return; // Disable using network sockets for security reasons
#endif

 
   pthread_mutex_lock(&client_socket_lock_);
   if (client_socket_ != -1) {
    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {
       safe_close_(&client_socket_);
     }
   }
  pthread_mutex_unlock(&client_socket_lock_);
}
","    if (send(client_socket_, data, length, 0) == -1 && errno == ECONNRESET) {
"
"static void *listen_fn_(UNUSED_ATTR void *context) {

  prctl(PR_SET_NAME, (unsigned long)LISTEN_THREAD_NAME_, 0, 0, 0);

  listen_socket_ = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
 if (listen_socket_ == -1) {
    LOG_ERROR(""%s socket creation failed: %s"", __func__, strerror(errno));
 goto cleanup;
 }

 int enable = 1;
 if (setsockopt(listen_socket_, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) == -1) {
    LOG_ERROR(""%s unable to set SO_REUSEADDR: %s"", __func__, strerror(errno));
 goto cleanup;
 }

 struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(LOCALHOST_);
  addr.sin_port = htons(LISTEN_PORT_);
 if (bind(listen_socket_, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
    LOG_ERROR(""%s unable to bind listen socket: %s"", __func__, strerror(errno));
 goto cleanup;
 }

 if (listen(listen_socket_, 10) == -1) {
    LOG_ERROR(""%s unable to listen: %s"", __func__, strerror(errno));
 goto cleanup;

   }
 
   for (;;) {
    int client_socket = accept(listen_socket_, NULL, NULL);
     if (client_socket == -1) {
       if (errno == EINVAL || errno == EBADF) {
         break;
 }
      LOG_WARN(""%s error accepting socket: %s"", __func__, strerror(errno));
 continue;
 }

 /* When a new client connects, we have to send the btsnoop file header. This allows
       a decoder to treat the session as a new, valid btsnoop file. */

     pthread_mutex_lock(&client_socket_lock_);
     safe_close_(&client_socket_);
     client_socket_ = client_socket;
    send(client_socket_, ""btsnoop\0\0\0\0\1\0\0\x3\xea"", 16, 0);
     pthread_mutex_unlock(&client_socket_lock_);
   }
 
cleanup:
  safe_close_(&listen_socket_);
 return NULL;
}
","    int client_socket = accept(listen_socket_, NULL, NULL);
    send(client_socket_, ""btsnoop\0\0\0\0\1\0\0\x3\xea"", 16, 0);
"
"static uint16_t transmit_data(serial_data_type_t type, uint8_t *data, uint16_t length) {
  assert(data != NULL);
  assert(length > 0);

 if (type < DATA_TYPE_COMMAND || type > DATA_TYPE_SCO) {
    LOG_ERROR(""%s invalid data type: %d"", __func__, type);
 return 0;
 }

 --data;
 uint8_t previous_byte = *data;
 *(data) = type;
 ++length;

 
   uint16_t transmitted_length = 0;
   while (length > 0) {
    ssize_t ret = write(uart_fd, data + transmitted_length, length);
     switch (ret) {
       case -1:
         LOG_ERROR(""In %s, error writing to the uart serial port: %s"", __func__, strerror(errno));
 goto done;
 case 0:
 goto done;
 default:
        transmitted_length += ret;
        length -= ret;
 break;
 }
 }

done:;
 *(data) = previous_byte;

 if (transmitted_length > 0)
 --transmitted_length;

 return transmitted_length;
}
","    ssize_t ret = write(uart_fd, data + transmitted_length, length);
"
"static uint16_t transmit_data_on(int fd, uint8_t *data, uint16_t length) {
  assert(data != NULL);
  assert(length > 0);

 
   uint16_t transmitted_length = 0;
   while (length > 0) {
    ssize_t ret = write(fd, data + transmitted_length, length);
     switch (ret) {
       case -1:
         LOG_ERROR(""In %s, error writing to the serial port with fd %d: %s"", __func__, fd, strerror(errno));
 return transmitted_length;
 case 0:
 return transmitted_length;
 default:
        transmitted_length += ret;
        length -= ret;
 break;
 }
 }

 return transmitted_length;
}
","    ssize_t ret = write(fd, data + transmitted_length, length);
"
"static void command_timed_out(UNUSED_ATTR void *context) {
  pthread_mutex_lock(&commands_pending_response_lock);

 if (list_is_empty(commands_pending_response)) {
    LOG_ERROR(""%s with no commands pending response"", __func__);
 } else {
 waiting_command_t *wait_entry = list_front(commands_pending_response);
    pthread_mutex_unlock(&commands_pending_response_lock);

    LOG_ERROR(""%s hci layer timeout waiting for response to a command. opcode: 0x%x"", __func__, wait_entry->opcode);

   }
 
   LOG_ERROR(""%s restarting the bluetooth process."", __func__);
  usleep(10000);
   kill(getpid(), SIGKILL);
 }
","  usleep(10000);
"
"bool config_save(const config_t *config, const char *filename) {
  assert(config != NULL);

   assert(filename != NULL);
   assert(*filename != '\0');
 
  char *temp_filename = osi_calloc(strlen(filename) + 5);
  if (!temp_filename) {
    LOG_ERROR(""%s unable to allocate memory for filename."", __func__);
    return false;
   }
 
  strcpy(temp_filename, filename);
  strcat(temp_filename, "".new"");
 
  FILE *fp = fopen(temp_filename, ""wt"");
   if (!fp) {
     LOG_ERROR(""%s unable to write file '%s': %s"", __func__, temp_filename, strerror(errno));
     goto error;
 }

 
   for (const list_node_t *node = list_begin(config->sections); node != list_end(config->sections); node = list_next(node)) {
     const section_t *section = (const section_t *)list_node(node);
    fprintf(fp, ""[%s]\n"", section->name);
 
     for (const list_node_t *enode = list_begin(section->entries); enode != list_end(section->entries); enode = list_next(enode)) {
       const entry_t *entry = (const entry_t *)list_node(enode);
      fprintf(fp, ""%s = %s\n"", entry->key, entry->value);
     }
 
    if (list_next(node) != list_end(config->sections))
      fputc('\n', fp);
   }
 
  fflush(fp);
  fclose(fp);
 
   if (chmod(temp_filename, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) == -1) {
    LOG_ERROR(""%s unable to change file permissions '%s': %s"", __func__, filename, strerror(errno));

     goto error;
   }
 
   if (rename(temp_filename, filename) == -1) {
     LOG_ERROR(""%s unable to commit file '%s': %s"", __func__, filename, strerror(errno));
     goto error;
   }
 
   osi_free(temp_filename);
   return true;
 
error:;
   unlink(temp_filename);
   osi_free(temp_filename);
   return false;
 }
","  char *temp_filename = osi_calloc(strlen(filename) + 5);
  if (!temp_filename) {
    LOG_ERROR(""%s unable to allocate memory for filename."", __func__);
    return false;
  strcpy(temp_filename, filename);
  strcat(temp_filename, "".new"");
  FILE *fp = fopen(temp_filename, ""wt"");
    fprintf(fp, ""[%s]\n"", section->name);
      fprintf(fp, ""%s = %s\n"", entry->key, entry->value);
    if (list_next(node) != list_end(config->sections))
      fputc('\n', fp);
  fflush(fp);
  fclose(fp);
error:;
"
"static bool has_byte(const eager_reader_t *reader) {
  assert(reader != NULL);

  fd_set read_fds;
  FD_ZERO(&read_fds);
  FD_SET(reader->bytes_available_fd, &read_fds);

 struct timeval timeout;

   timeout.tv_sec = 0;
   timeout.tv_usec = 0;
 
  select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout);
   return FD_ISSET(reader->bytes_available_fd, &read_fds);
 }
","  select(reader->bytes_available_fd + 1, &read_fds, NULL, NULL, &timeout);
"
"static void inbound_data_waiting(void *context) {
 eager_reader_t *reader = (eager_reader_t *)context;

 data_buffer_t *buffer = (data_buffer_t *)reader->allocator->alloc(reader->buffer_size + sizeof(data_buffer_t));
 if (!buffer) {
    LOG_ERROR(""%s couldn't aquire memory for inbound data buffer."", __func__);
 return;
 }


   buffer->length = 0;
   buffer->offset = 0;
 
  int bytes_read = read(reader->inbound_fd, buffer->data, reader->buffer_size);
   if (bytes_read > 0) {
     buffer->length = bytes_read;
    fixed_queue_enqueue(reader->buffers, buffer);

    eventfd_write(reader->bytes_available_fd, bytes_read);
 } else {
 if (bytes_read == 0)
      LOG_WARN(""%s fd said bytes existed, but none were found."", __func__);
 else
      LOG_WARN(""%s unable to read from file descriptor: %s"", __func__, strerror(errno));

    reader->allocator->free(buffer);
 }
}
","  int bytes_read = read(reader->inbound_fd, buffer->data, reader->buffer_size);
"
"static reactor_status_t run_reactor(reactor_t *reactor, int iterations) {
  assert(reactor != NULL);

  reactor->run_thread = pthread_self();
  reactor->is_running = true;

 struct epoll_event events[MAX_EVENTS];
 for (int i = 0; iterations == 0 || i < iterations; ++i) {
    pthread_mutex_lock(&reactor->list_lock);
    list_clear(reactor->invalidation_list);
    pthread_mutex_unlock(&reactor->list_lock);

 
     int ret;
     do {
      ret = epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1);
     } while (ret == -1 && errno == EINTR);
 
     if (ret == -1) {
      LOG_ERROR(""%s error in epoll_wait: %s"", __func__, strerror(errno));
      reactor->is_running = false;
 return REACTOR_STATUS_ERROR;
 }

 for (int j = 0; j < ret; ++j) {
 if (events[j].data.ptr == NULL) {
 eventfd_t value;
        eventfd_read(reactor->event_fd, &value);
        reactor->is_running = false;
 return REACTOR_STATUS_STOP;
 }

 reactor_object_t *object = (reactor_object_t *)events[j].data.ptr;

      pthread_mutex_lock(&reactor->list_lock);
 if (list_contains(reactor->invalidation_list, object)) {
        pthread_mutex_unlock(&reactor->list_lock);
 continue;
 }

      pthread_mutex_lock(&object->lock);
      pthread_mutex_unlock(&reactor->list_lock);

      reactor->object_removed = false;
 if (events[j].events & (EPOLLIN | EPOLLHUP | EPOLLRDHUP | EPOLLERR) && object->read_ready)
        object->read_ready(object->context);
 if (!reactor->object_removed && events[j].events & EPOLLOUT && object->write_ready)
        object->write_ready(object->context);
      pthread_mutex_unlock(&object->lock);

 if (reactor->object_removed) {
        pthread_mutex_destroy(&object->lock);
        osi_free(object);
 }
 }
 }

  reactor->is_running = false;
 return REACTOR_STATUS_DONE;
}
","      ret = epoll_wait(reactor->epoll_fd, events, MAX_EVENTS, -1);
"
"bool semaphore_try_wait(semaphore_t *semaphore) {

   assert(semaphore != NULL);
   assert(semaphore->fd != INVALID_FD);
 
  int flags = fcntl(semaphore->fd, F_GETFL);
   if (flags == -1) {
     LOG_ERROR(""%s unable to get flags for semaphore fd: %s"", __func__, strerror(errno));
     return false;
   }
  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {
     LOG_ERROR(""%s unable to set O_NONBLOCK for semaphore fd: %s"", __func__, strerror(errno));
     return false;
   }

 eventfd_t value;

   if (eventfd_read(semaphore->fd, &value) == -1)
     return false;
 
  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)
     LOG_ERROR(""%s unable to resetore flags for semaphore fd: %s"", __func__, strerror(errno));
   return true;
 }
","  int flags = fcntl(semaphore->fd, F_GETFL);
  if (fcntl(semaphore->fd, F_SETFL, flags | O_NONBLOCK) == -1) {
  if (fcntl(semaphore->fd, F_SETFL, flags) == -1)
"
" socket_t *socket_accept(const socket_t *socket) {
   assert(socket != NULL);
 
  int fd = accept(socket->fd, NULL, NULL);
   if (fd == INVALID_FD) {
     LOG_ERROR(""%s unable to accept socket: %s"", __func__, strerror(errno));
     return NULL;
 }

 socket_t *ret = (socket_t *)osi_calloc(sizeof(socket_t));
 if (!ret) {
    close(fd);
    LOG_ERROR(""%s unable to allocate memory for socket."", __func__);
 return NULL;
 }

  ret->fd = fd;
 return ret;
}
","  int fd = accept(socket->fd, NULL, NULL);
"
"ssize_t socket_bytes_available(const socket_t *socket) {

   assert(socket != NULL);
 
   int size = 0;
  if (ioctl(socket->fd, FIONREAD, &size) == -1)
     return -1;
   return size;
 }
","  if (ioctl(socket->fd, FIONREAD, &size) == -1)
"
"ssize_t socket_read(const socket_t *socket, void *buf, size_t count) {

   assert(socket != NULL);
   assert(buf != NULL);
 
  return recv(socket->fd, buf, count, MSG_DONTWAIT);
 }
","  return recv(socket->fd, buf, count, MSG_DONTWAIT);
"
" ssize_t socket_write(const socket_t *socket, const void *buf, size_t count) {
   assert(socket != NULL);
   assert(buf != NULL);
 
  return send(socket->fd, buf, count, MSG_DONTWAIT);
 }
","  return send(socket->fd, buf, count, MSG_DONTWAIT);
"
" ssize_t socket_write_and_transfer_fd(const socket_t *socket, const void *buf, size_t count, int fd) {
  assert(socket != NULL);
  assert(buf != NULL);

 if (fd == INVALID_FD)
 return socket_write(socket, buf, count);

 struct msghdr msg;
 struct iovec iov;
 char control_buf[CMSG_SPACE(sizeof(int))];

  iov.iov_base = (void *)buf;
  iov.iov_len = count;

  msg.msg_iov = &iov;
  msg.msg_iovlen = 1;
  msg.msg_control = control_buf;
  msg.msg_controllen = sizeof(control_buf);
  msg.msg_name = NULL;
  msg.msg_namelen = 0;

 struct cmsghdr *header = CMSG_FIRSTHDR(&msg);
  header->cmsg_level = SOL_SOCKET;
  header->cmsg_type = SCM_RIGHTS;

   header->cmsg_len = CMSG_LEN(sizeof(int));
   *(int *)CMSG_DATA(header) = fd;
 
  ssize_t ret = sendmsg(socket->fd, &msg, MSG_DONTWAIT);
   close(fd);
   return ret;
 }
","  ssize_t ret = sendmsg(socket->fd, &msg, MSG_DONTWAIT);
"
" static void msleep(uint64_t ms) {
  usleep(ms * 1000);
 }
","  usleep(ms * 1000);
"
" void *atomic_thread(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
    usleep(1);
     atomic_inc_prefix_s32(&at->data[i]);
   }
   return NULL;
}
","    usleep(1);
"
" void *atomic_thread_inc_dec(void *context) {
   struct atomic_test_s32_s *at = (struct atomic_test_s32_s *)context;
   for (int i = 0; i < at->max_val; i++) {
    usleep(1);
     atomic_inc_prefix_s32(&at->data[i]);
    usleep(1);
     atomic_dec_prefix_s32(&at->data[i]);
   }
   return NULL;
}
","    usleep(1);
    usleep(1);
"
"static bool write_hci_command(hci_packet_t type, const void *packet, size_t length) {
 int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
 if (sock == INVALID_FD)
 goto error;

 struct sockaddr_in addr;

   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = htonl(0x7F000001);
   addr.sin_port = htons(8873);
  if (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)
     goto error;
 
  if (send(sock, &type, 1, 0) != 1)
     goto error;
 
  if (send(sock, &length, 2, 0) != 2)
     goto error;
 
  if (send(sock, packet, length, 0) != (ssize_t)length)
     goto error;
 
   close(sock);
 return true;

error:;
  close(sock);
 return false;
}
","  if (connect(sock, (const struct sockaddr *)&addr, sizeof(addr)) == -1)
  if (send(sock, &type, 1, 0) != 1)
  if (send(sock, &length, 2, 0) != 2)
  if (send(sock, packet, length, 0) != (ssize_t)length)
"
"UINT32 UIPC_Read(tUIPC_CH_ID ch_id, UINT16 *p_msg_evt, UINT8 *p_buf, UINT32 len)
{
 int n;
 int n_read = 0;
 int fd = uipc_main.ch[ch_id].fd;
 struct pollfd pfd;
    UNUSED(p_msg_evt);

 if (ch_id >= UIPC_CH_NUM)
 {
        BTIF_TRACE_ERROR(""UIPC_Read : invalid ch id %d"", ch_id);
 return 0;
 }

 if (fd == UIPC_DISCONNECTED)
 {
        BTIF_TRACE_ERROR(""UIPC_Read : channel %d closed"", ch_id);
 return 0;
 }


 while (n_read < (int)len)
 {
        pfd.fd = fd;
        pfd.events = POLLIN|POLLHUP;

 
         /* make sure there is data prior to attempting read to avoid blocking
            a read for more than poll timeout */
        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)
         {
             BTIF_TRACE_EVENT(""poll timeout (%d ms)"", uipc_main.ch[ch_id].read_poll_tmo_ms);
             break;
 }


 if (pfd.revents & (POLLHUP|POLLNVAL) )
 {
            BTIF_TRACE_EVENT(""poll : channel detached remotely"");
            UIPC_LOCK();
            uipc_close_locked(ch_id);
            UIPC_UNLOCK();

             return 0;
         }
 
        n = recv(fd, p_buf+n_read, len-n_read, 0);
 
 
 if (n == 0)
 {
            BTIF_TRACE_EVENT(""UIPC_Read : channel detached remotely"");
            UIPC_LOCK();
            uipc_close_locked(ch_id);
            UIPC_UNLOCK();
 return 0;
 }

 if (n < 0)
 {
            BTIF_TRACE_EVENT(""UIPC_Read : read failed (%s)"", strerror(errno));
 return 0;
 }

        n_read+=n;

 }

 return n_read;
}
","        if (poll(&pfd, 1, uipc_main.ch[ch_id].read_poll_tmo_ms) == 0)
        n = recv(fd, p_buf+n_read, len-n_read, 0);
"
"BOOLEAN UIPC_Send(tUIPC_CH_ID ch_id, UINT16 msg_evt, UINT8 *p_buf,
        UINT16 msglen)
{
    UNUSED(msg_evt);

    BTIF_TRACE_DEBUG(""UIPC_Send : ch_id:%d %d bytes"", ch_id, msglen);

 
     UIPC_LOCK();
 
    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)
     {
         BTIF_TRACE_ERROR(""failed to write (%s)"", strerror(errno));
     }

    UIPC_UNLOCK();

 return FALSE;
}
","    if (write(uipc_main.ch[ch_id].fd, p_buf, msglen) < 0)
"
"static int accept_server_socket(int sfd)
{
 struct sockaddr_un remote;
 struct pollfd pfd;
 int fd;
 socklen_t len = sizeof(struct sockaddr_un);

    BTIF_TRACE_EVENT(""accept fd %d"", sfd);

 /* make sure there is data to process */

     pfd.fd = sfd;
     pfd.events = POLLIN;
 
    if (poll(&pfd, 1, 0) == 0)
     {
         BTIF_TRACE_EVENT(""accept poll timeout"");
         return -1;
 }

 
 
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
     {
          BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
          return -1;
 }


 return fd;
}
","    if (poll(&pfd, 1, 0) == 0)
    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
"
"static void uipc_check_interrupt_locked(void)
{
 if (SAFE_FD_ISSET(uipc_main.signal_fds[0], &uipc_main.read_set))

     {
         char sig_recv = 0;
        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
     }
 }
","        recv(uipc_main.signal_fds[0], &sig_recv, sizeof(sig_recv), MSG_WAITALL);
"
"static void uipc_flush_ch_locked(tUIPC_CH_ID ch_id)
{
 char buf[UIPC_FLUSH_BUFFER_SIZE];
 struct pollfd pfd;
 int ret;

    pfd.events = POLLIN;
    pfd.fd = uipc_main.ch[ch_id].fd;

 if (uipc_main.ch[ch_id].fd == UIPC_DISCONNECTED)
 {
        BTIF_TRACE_EVENT(""%s() - fd disconnected. Exiting"", __FUNCTION__);
 return;
 }

 
     while (1)
     {
        ret = poll(&pfd, 1, 1);
         BTIF_TRACE_VERBOSE(""%s() - polling fd %d, revents: 0x%x, ret %d"",
                 __FUNCTION__, pfd.fd, pfd.revents, ret);
 
 if (pfd.revents & (POLLERR|POLLHUP))
 {
            BTIF_TRACE_EVENT(""%s() - POLLERR or POLLHUP. Exiting"", __FUNCTION__);
 return;
 }

 if (ret <= 0)
 {
            BTIF_TRACE_EVENT(""%s() - error (%d). Exiting"", __FUNCTION__, ret);
 return;
 }

 
         /* read sufficiently large buffer to ensure flush empties socket faster than
            it is getting refilled */
        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);
     }
 }
","        ret = poll(&pfd, 1, 1);
        read(pfd.fd, &buf, UIPC_FLUSH_BUFFER_SIZE);
"
"static void uipc_read_task(void *arg)
{
 int ch_id;
 int result;
    UNUSED(arg);

    prctl(PR_SET_NAME, (unsigned long)""uipc-main"", 0, 0, 0);

    raise_priority_a2dp(TASK_UIPC_READ);

 while (uipc_main.running)

     {
         uipc_main.read_set = uipc_main.active_set;
 
        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);
 
         if (result == 0)
         {
            BTIF_TRACE_EVENT(""select timeout"");
 continue;
 }
 else if (result < 0)
 {
            BTIF_TRACE_EVENT(""select failed %s"", strerror(errno));
 continue;
 }

        UIPC_LOCK();

 /* clear any wakeup interrupt */
        uipc_check_interrupt_locked();

 /* check pending task events */
        uipc_check_task_flags_locked();

 /* make sure we service audio channel first */
        uipc_check_fd_locked(UIPC_CH_ID_AV_AUDIO);

 /* check for other connections */
 for (ch_id = 0; ch_id < UIPC_CH_NUM; ch_id++)
 {
 if (ch_id != UIPC_CH_ID_AV_AUDIO)
                uipc_check_fd_locked(ch_id);
 }

        UIPC_UNLOCK();
 }

    BTIF_TRACE_EVENT(""UIPC READ THREAD EXITING"");

    uipc_main_cleanup();

    uipc_main.tid = 0;

    BTIF_TRACE_EVENT(""UIPC READ THREAD DONE"");
}
","        result = select(uipc_main.max_fd+1, &uipc_main.read_set, NULL, NULL, NULL);
"
"static inline void uipc_wakeup_locked(void)

 {
     char sig_on = 1;
     BTIF_TRACE_EVENT(""UIPC SEND WAKE UP"");
    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);
 }
","    send(uipc_main.signal_fds[1], &sig_on, sizeof(sig_on), 0);
"
" static byte parseHexByte(const char * &str) {
     byte b = parseHexChar(str[0]);
    if (str[1] == ':' || str[1] == '\0') {
        str += 2;
        return b;
     } else {
         b = b << 4 | parseHexChar(str[1]);
        str += 3;
        return b;
     }
 }
","    if (str[1] == ':' || str[1] == '\0') {
        str += 2;
        return b;
        str += 3;
        return b;
"
"    BufferMeta(const sp<IMemory> &mem, bool is_backup = false)
         : mMem(mem),
          mIsBackup(is_backup) {
     }
","          mIsBackup(is_backup) {
"
"    BufferMeta(size_t size)
         : mSize(size),
          mIsBackup(false) {
     }
","          mIsBackup(false) {
"
"    BufferMeta(const sp<GraphicBuffer> &graphicBuffer)
         : mGraphicBuffer(graphicBuffer),
          mIsBackup(false) {
     }
","          mIsBackup(false) {
"
"status_t OMXNodeInstance::allocateBuffer(
        OMX_U32 portIndex, size_t size, OMX::buffer_id *buffer,

         void **buffer_data) {
     Mutex::Autolock autoLock(mLock);
 
    BufferMeta *buffer_meta = new BufferMeta(size);
 
     OMX_BUFFERHEADERTYPE *header;
 
    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, size);

 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBuffer, err, BUFFER_FMT(portIndex, ""%zu@"", size));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pAppPrivate, buffer_meta);

 *buffer = makeBufferID(header);
 *buffer_data = header->pBuffer;

    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }
    CLOG_BUFFER(allocateBuffer, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p"", size, *buffer_data));

 return OK;
}
","    BufferMeta *buffer_meta = new BufferMeta(size);
"
"status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size()) {

         return BAD_VALUE;
     }
 
    BufferMeta *buffer_meta = new BufferMeta(params, true);
 
     OMX_BUFFERHEADERTYPE *header;
 
    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pAppPrivate, buffer_meta);

 *buffer = makeBufferID(header);

    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
","    BufferMeta *buffer_meta = new BufferMeta(params, true);
"
"status_t OMXNodeInstance::emptyBuffer(
        OMX::buffer_id buffer,
        OMX_U32 rangeOffset, OMX_U32 rangeLength,

         OMX_U32 flags, OMX_TICKS timestamp, int fenceFd) {
     Mutex::Autolock autoLock(mLock);
 
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     BufferMeta *buffer_meta =
         static_cast<BufferMeta *>(header->pAppPrivate);
     sp<ABuffer> backup = buffer_meta->getBuffer(header, true /* backup */, false /* limit */);
    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* backup */, false /* limit */);

 if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource
 && backup->capacity() >= sizeof(VideoNativeMetadata)
 && codec->capacity() >= sizeof(VideoGrallocMetadata)
 && ((VideoNativeMetadata *)backup->base())->eType
 == kMetadataBufferTypeANWBuffer) {
 VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();
 VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();
        CLOG_BUFFER(emptyBuffer, ""converting ANWB %p to handle %p"",
                backupMeta.pBuffer, backupMeta.pBuffer->handle);
        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;
        codecMeta.eType = kMetadataBufferTypeGrallocSource;
        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;
        header->nOffset = 0;
 } else {
 if (rangeOffset > header->nAllocLen
 || rangeLength > header->nAllocLen - rangeOffset) {
            CLOG_ERROR(emptyBuffer, OMX_ErrorBadParameter, FULL_BUFFER(NULL, header, fenceFd));
 if (fenceFd >= 0) {
 ::close(fenceFd);
 }
 return BAD_VALUE;
 }
        header->nFilledLen = rangeLength;
        header->nOffset = rangeOffset;

        buffer_meta->CopyToOMX(header);
 }

 return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer, fenceFd);
}
","    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
"
" status_t OMXNodeInstance::fillBuffer(OMX::buffer_id buffer, int fenceFd) {
     Mutex::Autolock autoLock(mLock);
 
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     header->nFilledLen = 0;
     header->nOffset = 0;
     header->nFlags = 0;

 status_t res = storeFenceInMeta_l(header, fenceFd, kPortIndexOutput);
 if (res != OK) {
        CLOG_ERROR(fillBuffer::storeFenceInMeta, res, EMPTY_BUFFER(buffer, header, fenceFd));
 return res;
 }

 {
 Mutex::Autolock _l(mDebugLock);
        mOutputBuffersWithCodec.add(header);
        CLOG_BUMPED_BUFFER(fillBuffer, WITH_STATS(EMPTY_BUFFER(buffer, header, fenceFd)));
 }

    OMX_ERRORTYPE err = OMX_FillThisBuffer(mHandle, header);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(fillBuffer, err, EMPTY_BUFFER(buffer, header, fenceFd));
 Mutex::Autolock _l(mDebugLock);
        mOutputBuffersWithCodec.remove(header);
 }
 return StatusFromOMXError(err);
}
","    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
"
"OMX_BUFFERHEADERTYPE *OMXNodeInstance::findBufferHeader(OMX::buffer_id buffer) {
     if (buffer == 0) {
         return NULL;
     }
 Mutex::Autolock autoLock(mBufferIDLock);
 ssize_t index = mBufferIDToBufferHeader.indexOfKey(buffer);
 if (index < 0) {

         CLOGW(""findBufferHeader: buffer %u not found"", buffer);
         return NULL;
     }
    return mBufferIDToBufferHeader.valueAt(index);
 }
","    return mBufferIDToBufferHeader.valueAt(index);
"
"status_t OMXNodeInstance::freeBuffer(
        OMX_U32 portIndex, OMX::buffer_id buffer) {
 Mutex::Autolock autoLock(mLock);
    CLOG_BUFFER(freeBuffer, ""%s:%u %#x"", portString(portIndex), portIndex, buffer);

 
     removeActiveBuffer(portIndex, buffer);
 
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     BufferMeta *buffer_meta = static_cast<BufferMeta *>(header->pAppPrivate);
 
     OMX_ERRORTYPE err = OMX_FreeBuffer(mHandle, portIndex, header);
    CLOG_IF_ERROR(freeBuffer, err, ""%s:%u %#x"", portString(portIndex), portIndex, buffer);

 delete buffer_meta;
    buffer_meta = NULL;
    invalidateBufferID(buffer);

 return StatusFromOMXError(err);
}
","    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
"
"bool OMXNodeInstance::handleMessage(omx_message &msg) {
 const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());

 
     if (msg.type == omx_message::FILL_BUFFER_DONE) {
         OMX_BUFFERHEADERTYPE *buffer =
            findBufferHeader(msg.u.extended_buffer_data.buffer);
 
         {
             Mutex::Autolock _l(mDebugLock);
            mOutputBuffersWithCodec.remove(buffer);

            CLOG_BUMPED_BUFFER(
                    FBD, WITH_STATS(FULL_BUFFER(
                            msg.u.extended_buffer_data.buffer, buffer, msg.fenceFd)));

            unbumpDebugLevel_l(kPortIndexOutput);
 }

 BufferMeta *buffer_meta =
 static_cast<BufferMeta *>(buffer->pAppPrivate);

 if (buffer->nOffset + buffer->nFilledLen < buffer->nOffset
 || buffer->nOffset + buffer->nFilledLen > buffer->nAllocLen) {
            CLOG_ERROR(onFillBufferDone, OMX_ErrorBadParameter,
                    FULL_BUFFER(NULL, buffer, msg.fenceFd));
 }
        buffer_meta->CopyFromOMX(buffer);

 if (bufferSource != NULL) {
            bufferSource->codecBufferFilled(buffer);

            msg.u.extended_buffer_data.timestamp = buffer->nTimeStamp;

         }
     } else if (msg.type == omx_message::EMPTY_BUFFER_DONE) {
         OMX_BUFFERHEADERTYPE *buffer =
            findBufferHeader(msg.u.buffer_data.buffer);
 
         {
             Mutex::Autolock _l(mDebugLock);
            mInputBuffersWithCodec.remove(buffer);

            CLOG_BUMPED_BUFFER(
                    EBD, WITH_STATS(EMPTY_BUFFER(msg.u.buffer_data.buffer, buffer, msg.fenceFd)));
 }

 if (bufferSource != NULL) {
            bufferSource->codecBufferEmptied(buffer, msg.fenceFd);
 return true;
 }
 }

 return false;
}
","            findBufferHeader(msg.u.extended_buffer_data.buffer);
            findBufferHeader(msg.u.buffer_data.buffer);
"
"status_t OMXNodeInstance::updateGraphicBufferInMeta(

         OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
         OMX::buffer_id buffer) {
     Mutex::Autolock autoLock(mLock);
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
     return updateGraphicBufferInMeta_l(portIndex, graphicBuffer, buffer, header);
 }
","    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);
"
"status_t OMXNodeInstance::useBuffer(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size()) {

         return BAD_VALUE;
     }
 
    BufferMeta *buffer_meta = new BufferMeta(params);
 
     OMX_BUFFERHEADERTYPE *header;
 
    OMX_ERRORTYPE err = OMX_UseBuffer(
            mHandle, &header, portIndex, buffer_meta,
            allottedSize, static_cast<OMX_U8 *>(params->pointer()));

 if (err != OMX_ErrorNone) {
        CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(
                portIndex, (size_t)allottedSize, params->pointer()));

 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pAppPrivate, buffer_meta);

 *buffer = makeBufferID(header);

    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(
 *buffer, portIndex, ""%u(%zu)@%p"", allottedSize, params->size(), params->pointer()));
 return OK;
}
","    BufferMeta *buffer_meta = new BufferMeta(params);
"
"status_t OMXNodeInstance::useGraphicBuffer(
        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
        OMX::buffer_id *buffer) {
 Mutex::Autolock autoLock(mLock);

    OMX_INDEXTYPE index;
 if (OMX_GetExtensionIndex(
            mHandle,
 const_cast<OMX_STRING>(""OMX.google.android.index.useAndroidNativeBuffer2""),
 &index) == OMX_ErrorNone) {
 return useGraphicBuffer2_l(portIndex, graphicBuffer, buffer);
 }

    OMX_STRING name = const_cast<OMX_STRING>(
 ""OMX.google.android.index.useAndroidNativeBuffer"");
    OMX_ERRORTYPE err = OMX_GetExtensionIndex(mHandle, name, &index);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(getExtensionIndex, err, ""%s"", name);

         return StatusFromOMXError(err);
     }
 
    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
 
     OMX_BUFFERHEADERTYPE *header;
 
    OMX_VERSIONTYPE ver;
    ver.s.nVersionMajor = 1;
    ver.s.nVersionMinor = 0;
    ver.s.nRevision = 0;
    ver.s.nStep = 0;
 UseAndroidNativeBufferParams params = {
 sizeof(UseAndroidNativeBufferParams), ver, portIndex, bufferMeta,
 &header, graphicBuffer,
 };

    err = OMX_SetParameter(mHandle, index, &params);

 if (err != OMX_ErrorNone) {
        CLOG_ERROR(setParameter, err, ""%s(%#x): %s:%u meta=%p GB=%p"", name, index,
                portString(portIndex), portIndex, bufferMeta, graphicBuffer->handle);

 delete bufferMeta;
        bufferMeta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pAppPrivate, bufferMeta);

 *buffer = makeBufferID(header);

    addActiveBuffer(portIndex, *buffer);
    CLOG_BUFFER(useGraphicBuffer, NEW_BUFFER_FMT(
 *buffer, portIndex, ""GB=%p"", graphicBuffer->handle));
 return OK;
}
","    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
"
"status_t OMXNodeInstance::useGraphicBuffer2_l(
        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
        OMX::buffer_id *buffer) {

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;
    OMX_ERRORTYPE err = OMX_GetParameter(mHandle, OMX_IndexParamPortDefinition, &def);
 if (err != OMX_ErrorNone) {
        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;
        CLOG_ERROR(getParameter, err, ""%s(%#x): %s:%u"",
                asString(index), index, portString(portIndex), portIndex);

         return UNKNOWN_ERROR;
     }
 
    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
 
     OMX_BUFFERHEADERTYPE *header = NULL;
     OMX_U8* bufferHandle = const_cast<OMX_U8*>(
 reinterpret_cast<const OMX_U8*>(graphicBuffer->handle));

    err = OMX_UseBuffer(
            mHandle,
 &header,
            portIndex,
            bufferMeta,
            def.nBufferSize,
            bufferHandle);

 if (err != OMX_ErrorNone) {
        CLOG_ERROR(useBuffer, err, BUFFER_FMT(portIndex, ""%u@%p"", def.nBufferSize, bufferHandle));
 delete bufferMeta;
        bufferMeta = NULL;
 *buffer = 0;
 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pBuffer, bufferHandle);
    CHECK_EQ(header->pAppPrivate, bufferMeta);

 *buffer = makeBufferID(header);

    addActiveBuffer(portIndex, *buffer);
    CLOG_BUFFER(useGraphicBuffer2, NEW_BUFFER_FMT(
 *buffer, portIndex, ""%u@%p"", def.nBufferSize, bufferHandle));
 return OK;
}
","    BufferMeta *bufferMeta = new BufferMeta(graphicBuffer);
"
"status_t MediaPlayer::setDataSource(
 const sp<IMediaHTTPService> &httpService,
 const char *url, const KeyedVector<String8, String8> *headers)
{

     ALOGV(""setDataSource(%s)"", url);
     status_t err = BAD_VALUE;
     if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
         if (service != 0) {
             sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
             if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(httpService, url, headers))) {
                player.clear();
 }
            err = attachNewPlayer(player);
 }
 }
 return err;
}
","        const sp<IMediaPlayerService>& service(getMediaPlayerService());
"
"status_t MediaPlayer::setDataSource(int fd, int64_t offset, int64_t length)

 {
     ALOGV(""setDataSource(%d, %"" PRId64 "", %"" PRId64 "")"", fd, offset, length);
     status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(fd, offset, length))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
","    const sp<IMediaPlayerService>& service(getMediaPlayerService());
"
"status_t MediaPlayer::setDataSource(const sp<IStreamSource> &source)

 {
     ALOGV(""setDataSource"");
     status_t err = UNKNOWN_ERROR;
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
     if (service != 0) {
         sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
         if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
 (NO_ERROR != player->setDataSource(source))) {
            player.clear();
 }
        err = attachNewPlayer(player);
 }
 return err;
}
","    const sp<IMediaPlayerService>& service(getMediaPlayerService());
"
"MediaRecorder::MediaRecorder(const String16& opPackageName) : mSurfaceMediaSource(NULL)

 {
     ALOGV(""constructor"");
 
    const sp<IMediaPlayerService>& service(getMediaPlayerService());
     if (service != NULL) {
         mMediaRecorder = service->createMediaRecorder(opPackageName);
     }
 if (mMediaRecorder != NULL) {
        mCurrentState = MEDIA_RECORDER_IDLE;
 }


    doCleanUp();
}
","    const sp<IMediaPlayerService>& service(getMediaPlayerService());
"
" INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)
 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
     {
         FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     }
     return;
 }
","    if (ps_stream->u4_offset < ps_stream->u4_max_offset)
"
"static int enable(void) {
  LOG_INFO(""%s"", __func__);
 
   if (!interface_ready())
     return BT_STATUS_NOT_READY;

  stack_manager_get_interface()->start_up_stack_async();
 return BT_STATUS_SUCCESS;
}
","  LOG_INFO(""%s"", __func__);
"
"void bdt_enable(void)
{
    bdt_log(""ENABLE BT"");
 if (bt_enabled) {

         bdt_log(""Bluetooth is already enabled"");
         return;
     }
    status = sBtInterface->enable();
 
     check_return_status(status);
 }
","    status = sBtInterface->enable();
"
" bool adapter_enable_disable() {
   int error;
 
  CALL_AND_WAIT(error = bt_interface->enable(), adapter_state_changed);
   TASSERT(error == BT_STATUS_SUCCESS, ""Error enabling Bluetooth: %d"", error);
   TASSERT(adapter_get_state() == BT_STATE_ON, ""Adapter did not turn on."");
 
  CALL_AND_WAIT(error = bt_interface->disable(), adapter_state_changed);
  TASSERT(error == BT_STATUS_SUCCESS, ""Error disabling Bluetooth: %d"", error);
  TASSERT(adapter_get_state() == BT_STATE_OFF, ""Adapter did not turn off."");

 return true;
}
","  CALL_AND_WAIT(error = bt_interface->enable(), adapter_state_changed);
"
" static void print_maps(struct pid_info_t* info)
 {
     FILE *maps;
     size_t offset;
     char device[10];
     long int inode;
    char file[PATH_MAX];
 
     strlcat(info->path, ""maps"", sizeof(info->path));
 
    maps = fopen(info->path, ""r"");

     if (!maps)
         goto out;
 
    while (fscanf(maps, ""%*x-%*x %*s %zx %s %ld %s\n"", &offset, device, &inode,
            file) == 4) {
         if (inode == 0 || !strcmp(device, ""00:00""))
             continue;

        printf(""%-9s %5d %10s %4s %9s %18s %9zd %10ld %s\n"",
                info->cmdline, info->pid, info->user, ""mem"",
 ""???"", device, offset, inode, file);
 }

    fclose(maps);

out:
    info->path[info->parent_length] = '\0';
}
","    char file[PATH_MAX];
    while (fscanf(maps, ""%*x-%*x %*s %zx %s %ld %s\n"", &offset, device, &inode,
            file) == 4) {
"
" int res_unpack(vorbis_info_residue *info,
		vorbis_info *vi,oggpack_buffer *opb){
   int j,k;
   codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;
   memset(info,0,sizeof(*info));

  info->type=oggpack_read(opb,16);
 if(info->type>2 || info->type<0)goto errout;
  info->begin=oggpack_read(opb,24);
  info->end=oggpack_read(opb,24);
  info->grouping=oggpack_read(opb,24)+1;
  info->partitions=(char)(oggpack_read(opb,6)+1);
  info->groupbook=(unsigned char)oggpack_read(opb,8);
 if(info->groupbook>=ci->books)goto errout;

  info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));
  info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));

 for(j=0;j<info->partitions;j++){
 int cascade=oggpack_read(opb,3);
 if(oggpack_read(opb,1))
      cascade|=(oggpack_read(opb,5)<<3);
    info->stagemasks[j]=cascade;
 }


   for(j=0;j<info->partitions;j++){
     for(k=0;k<8;k++){
       if((info->stagemasks[j]>>k)&1){
	unsigned char book=(unsigned char)oggpack_read(opb,8);
	if(book>=ci->books)goto errout;
	info->stagebooks[j*8+k]=book;
	if(k+1>info->stages)info->stages=k+1;
       }else
	info->stagebooks[j*8+k]=0xff;
     }
   }
 
 if(oggpack_eop(opb))goto errout;

 return 0;
 errout:
  res_clear_info(info);
 return 1;

 }
","		vorbis_info *vi,oggpack_buffer *opb){
	unsigned char book=(unsigned char)oggpack_read(opb,8);
	if(book>=ci->books)goto errout;
	info->stagebooks[j*8+k]=book;
	if(k+1>info->stages)info->stages=k+1;
	info->stagebooks[j*8+k]=0xff;
"
"int readpng_init(FILE *infile, ulg *pWidth, ulg *pHeight)
{
    uch sig[8];


 /* first do a quick check that the file really is a PNG image; could
     * have used slightly more general png_sig_cmp() function instead */

    fread(sig, 1, 8, infile);
 if (png_sig_cmp(sig, 0, 8))
 return 1; /* bad signature */


 
     /* could pass pointers to user-defined error handlers instead of NULLs: */
 
    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
     if (!png_ptr)
         return 4;   /* out of memory */
 
    info_ptr = png_create_info_struct(png_ptr);
 if (!info_ptr) {
        png_destroy_read_struct(&png_ptr, NULL, NULL);
 return 4; /* out of memory */
 }


 /* we could create a second info struct here (end_info), but it's only
     * useful if we want to keep pre- and post-IDAT chunk info separated
     * (mainly for PNG-aware image editors and converters) */


 /* setjmp() must be called in every function that calls a PNG-reading
     * libpng function */

 if (setjmp(png_jmpbuf(png_ptr))) {
        png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 return 2;
 }


    png_init_io(png_ptr, infile);
    png_set_sig_bytes(png_ptr, 8); /* we already read the 8 signature bytes */

    png_read_info(png_ptr, info_ptr); /* read all PNG info up to image data */


 /* alternatively, could make separate calls to png_get_image_width(),
     * etc., but want bit_depth and color_type for later [don't care about
     * compression_type and filter_type => NULLs] */

    png_get_IHDR(png_ptr, info_ptr, &width, &height, &bit_depth, &color_type,
      NULL, NULL, NULL);
 *pWidth = width;
 *pHeight = height;


 /* OK, that's all we need for now; return happy */

 return 0;
}
","    png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
"
"uch *readpng_get_image(double display_exponent, int *pChannels, ulg *pRowbytes)
{
    ulg  rowbytes;


 /* expand palette images to RGB, low-bit-depth grayscale images to 8 bits,
     * transparency chunks to full alpha channel; strip 16-bit-per-sample
     * images to 8 bits per sample; and convert grayscale to RGB[A] */

 /* GRR WARNING:  grayscale needs to be expanded and channels reset! */

 *pRowbytes = rowbytes = channels*width;
 *pChannels = channels;

 if ((image_data = (uch *)malloc(rowbytes*height)) == NULL) {
 return NULL;
 }

 Trace((stderr, ""readpng_get_image:  rowbytes = %ld, height = %ld\n"", rowbytes, height));


 
     /* now we can go ahead and just read the whole image */
 
    fread(image_data, 1L, rowbytes*height, saved_infile);
 
     return image_data;
 }
","    fread(image_data, 1L, rowbytes*height, saved_infile);
"
"main(void)
{

    fwrite(signature, sizeof signature, 1, stdout);
    put_chunk(IHDR, sizeof IHDR);
 
   for(;;)
       put_chunk(unknown, sizeof unknown);
 }
","   for(;;)
"
"image_size_of_type(int color_type, int bit_depth, unsigned int *colors)
 {
    if (*colors)
       return 16;

 else

    {
       int pixel_depth = pixel_depth_of_type(color_type, bit_depth);
 
      if (pixel_depth < 8)
          return 64;
 
       else if (pixel_depth > 16)
 return 1024;

 else
 return 256;
 }
}
","      if (pixel_depth < 8)
"
" load_fake(png_charp param, png_bytepp profile)
 {
    char *endptr = NULL;
   unsigned long long int size = strtoull(param, &endptr, 0/*base*/);
 
    /* The 'fake' format is <number>*[string] */
    if (endptr != NULL && *endptr == '*')
 {
 size_t len = strlen(++endptr);
 size_t result = (size_t)size;

 if (len == 0) len = 1; /* capture the terminating '\0' */

 /* Now repeat that string to fill 'size' bytes. */
 if (result == size && (*profile = malloc(result)) != NULL)
 {
         png_bytep out = *profile;

 if (len == 1)
            memset(out, *endptr, result);

 else
 {
 while (size >= len)
 {
               memcpy(out, endptr, len);
               out += len;
               size -= len;
 }
            memcpy(out, endptr, size);
 }

 return result;
 }

 else
 {
         fprintf(stderr, ""%s: size exceeds system limits\n"", param);
         exit(1);
 }
 }

 return 0;
}
","   unsigned long long int size = strtoull(param, &endptr, 0/*base*/);
"
"set_value(png_bytep row, size_t rowbytes, png_uint_32 x, unsigned int bit_depth,
   png_uint_32 value, png_const_bytep gamma_table, double conv)
{
 unsigned int mask = (1U << bit_depth)-1;

   x *= bit_depth; /* Maximum x is 4*1024, maximum bit_depth is 16 */

 if (value <= mask)
 {
      png_uint_32 offset = x >> 3;

 if (offset < rowbytes && (bit_depth < 16 || offset+1 < rowbytes))
 {
         row += offset;

 switch (bit_depth)
 {
 case 1:
 case 2:
 case 4:
 /* Don't gamma correct - values get smashed */
 {
 unsigned int shift = (8 - bit_depth) - (x & 0x7U);

                  mask <<= shift;
                  value = (value << shift) & mask;
 *row = (png_byte)((*row & ~mask) | value);
 }
 return;

 default:
               fprintf(stderr, ""makepng: bad bit depth (internal error)\n"");

                exit(1);
 
             case 16:
               value = (unsigned int)floor(65535*pow(value/65535.,conv)+.5);
                *row++ = (png_byte)(value >> 8);
                *row = (png_byte)value;
                return;

 case 8:
 *row = gamma_table[value];
 return;
 }
 }

 else
 {
         fprintf(stderr, ""makepng: row buffer overflow (internal error)\n"");
         exit(1);
 }
 }

 else
 {
      fprintf(stderr, ""makepng: component overflow (internal error)\n"");
      exit(1);

    }
 }
","               value = (unsigned int)floor(65535*pow(value/65535.,conv)+.5);
"
"display_log(struct display *dp, error_level level, const char *fmt, ...)
 /* 'level' is as above, fmt is a stdio style format string.  This routine
    * does not return if level is above LIBPNG_WARNING
    */
{
   dp->results |= 1U << level;

 if (level > (error_level)(dp->options & LEVEL_MASK))
 {
 const char *lp;
      va_list ap;

 switch (level)
 {
 case INFORMATION:    lp = ""information""; break;
 case LIBPNG_WARNING: lp = ""warning(libpng)""; break;
 case APP_WARNING:    lp = ""warning(pngimage)""; break;
 case APP_FAIL:       lp = ""error(continuable)""; break;
 case LIBPNG_ERROR:   lp = ""error(libpng)""; break;
 case LIBPNG_BUG:     lp = ""bug(libpng)""; break;
 case APP_ERROR:      lp = ""error(pngimage)""; break;
 case USER_ERROR:     lp = ""error(user)""; break;

 case INTERNAL_ERROR: /* anything unexpected is an internal error: */
 case VERBOSE: case WARNINGS: case ERRORS: case QUIET:
 default:             lp = ""bug(pngimage)""; break;
 }

      fprintf(stderr, ""%s: %s: %s"",
         dp->filename != NULL ? dp->filename : ""<stdin>"", lp, dp->operation);

 if (dp->transforms != 0)
 {

          int tr = dp->transforms;
 
          if (is_combo(tr))
            fprintf(stderr, ""(0x%x)"", tr);
 
          else
             fprintf(stderr, ""(%s)"", transform_name(tr));
 }

      fprintf(stderr, "": "");

      va_start(ap, fmt);
      vfprintf(stderr, fmt, ap);
      va_end(ap);

      fputc('\n', stderr);
 }
 /* else do not output any message */

 /* Errors cause this routine to exit to the fail code */
 if (level > APP_FAIL || (level > ERRORS && !(dp->options & CONTINUE)))
      longjmp(dp->error_return, level);
}
","            fprintf(stderr, ""(0x%x)"", tr);
"
"transform_name(int t)
 /* The name, if 't' has multiple bits set the name of the lowest set bit is
    * returned.
    */
{
 unsigned int i;

 
    t &= -t; /* first set bit */
 
   for (i=0; i<TTABLE_SIZE; ++i)
    {
       if ((transform_info[i].transform & t) != 0)
          return transform_info[i].name;
 }

 return ""invalid transform"";
}
","   for (i=0; i<TTABLE_SIZE; ++i)
"
"validate_T(void)
 /* Validate the above table - this just builds the above values */

 {
    unsigned int i;
 
   for (i=0; i<TTABLE_SIZE; ++i)
    {
       if (transform_info[i].when & TRANSFORM_R)
          read_transforms |= transform_info[i].transform;

 if (transform_info[i].when & TRANSFORM_W)
         write_transforms |= transform_info[i].transform;
 }

 /* Reversible transforms are those which are supported on both read and
    * write.
    */
   rw_transforms = read_transforms & write_transforms;
}
","   for (i=0; i<TTABLE_SIZE; ++i)
"
"freeimage(Image *image)
{
   freebuffer(image);
   png_image_free(&image->image);

 if (image->input_file != NULL)
 {
      fclose(image->input_file);
      image->input_file = NULL;
 }

 if (image->input_memory != NULL)
 {
      free(image->input_memory);
      image->input_memory = NULL;
      image->input_memory_size = 0;
 }

 
    if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
    {
      remove(image->tmpfile_name);
       image->tmpfile_name[0] = 0;
    }
 }
","      remove(image->tmpfile_name);
"
"read_one_file(Image *image)
{
 if (!(image->opts & READ_FILE) || (image->opts & USE_STDIO))
 {
 /* memory or stdio. */
 FILE *f = fopen(image->file_name, ""rb"");

 if (f != NULL)
 {
 if (image->opts & READ_FILE)
            image->input_file = f;

 else /* memory */
 {
 if (fseek(f, 0, SEEK_END) == 0)

             {
                long int cb = ftell(f);
 
               if (cb > 0 && (unsigned long int)cb < (size_t)~(size_t)0)
                {
                  png_bytep b = voidcast(png_bytep, malloc((size_t)cb));
                  if (b != NULL)
                   {
                     rewind(f);
 
                     if (fread(b, (size_t)cb, 1, f) == 1)
                      {
                        fclose(f);
                        image->input_memory_size = cb;
                        image->input_memory = b;
                      }
 
                      else
                     {
                        free(b);
                         return logclose(image, f, image->file_name,
                           "": read failed: "");
                     }
                   }
 
                   else
                      return logclose(image, f, image->file_name,
                        "": out of memory: "");
                }
 
                else if (cb == 0)
 return logclose(image, f, image->file_name,
 "": zero length: "");

 else
 return logclose(image, f, image->file_name,
 "": tell failed: "");
 }

 else
 return logclose(image, f, image->file_name, "": seek failed: "");
 }
 }

 else
 return logerror(image, image->file_name, "": open failed: "",
            strerror(errno));
 }

 return read_file(image, FORMAT_NO_CHANGE, NULL);
}
","               if (cb > 0 && (unsigned long int)cb < (size_t)~(size_t)0)
                  png_bytep b = voidcast(png_bytep, malloc((size_t)cb));
                  if (b != NULL)
                     rewind(f);
                     if (fread(b, (size_t)cb, 1, f) == 1)
                        fclose(f);
                        image->input_memory_size = cb;
                        image->input_memory = b;
                     {
                        free(b);
                           "": read failed: "");
                     }
                        "": out of memory: "");
"
"read_callback(png_structp pp, png_unknown_chunkp pc)
{
 /* This function mimics the behavior of png_set_keep_unknown_chunks by
    * returning '0' to keep the chunk and '1' to discard it.
    */
   display *d = voidcast(display*, png_get_user_chunk_ptr(pp));
 int chunk = findb(pc->name);
 int keep, discard;

 if (chunk < 0) /* not one in our list, so not a known chunk */
      keep = d->keep;

 else
 {
      keep = chunk_info[chunk].keep;
 if (keep == PNG_HANDLE_CHUNK_AS_DEFAULT)
 {
 /* See the comments in png.h - use the default for unknown chunks,
          * do not keep known chunks.
          */
 if (chunk_info[chunk].unknown)
            keep = d->keep;

 else
            keep = PNG_HANDLE_CHUNK_NEVER;
 }
 }

 switch (keep)
 {
 default:
         fprintf(stderr, ""%s(%s): %d: unrecognized chunk option\n"", d->file,
            d->test, chunk_info[chunk].keep);
         display_exit(d);

 case PNG_HANDLE_CHUNK_AS_DEFAULT:
 case PNG_HANDLE_CHUNK_NEVER:
         discard = 1/*handled; discard*/;
 break;

 case PNG_HANDLE_CHUNK_IF_SAFE:
 case PNG_HANDLE_CHUNK_ALWAYS:
         discard = 0/*not handled; keep*/;
 break;
 }

 /* Also store information about this chunk in the display, the relevant flag
    * is set if the chunk is to be kept ('not handled'.)
    */
 if (chunk >= 0) if (!discard) /* stupidity to stop a GCC warning */
 {
      png_uint_32 flag = chunk_info[chunk].flag;

 if (pc->location & PNG_AFTER_IDAT)
         d->after_IDAT |= flag;

 else
         d->before_IDAT |= flag;
 }


    /* However if there is no support to store unknown chunks don't ask libpng to
     * do it; there will be an png_error.
     */
#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
       return discard;
 #  else
       return 1; /*handled; discard*/
#  endif

 }
","#  ifdef PNG_STORE_UNKNOWN_CHUNKS_SUPPORTED
"
"image_transform_png_set_@_add(image_transform *this,
    PNG_CONST image_transform **that, char *name, size_t sizeof_name,
    size_t *pos, png_byte colour_type, png_byte bit_depth)
{
   this->next = *that;
   *that = this;
   *pos = safecat(name, sizeof_name, *pos, "" +@"");
   return 1;
}
","    PNG_CONST image_transform **that, char *name, size_t sizeof_name,
    size_t *pos, png_byte colour_type, png_byte bit_depth)
{
   this->next = *that;
   *that = this;
   *pos = safecat(name, sizeof_name, *pos, "" +@"");
   return 1;
}
"
"image_transform_png_set_@_mod(PNG_CONST image_transform *this,
    image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
   this->next->mod(this->next, that, pp, display);
}
","    image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
{
   this->next->mod(this->next, that, pp, display);
}
"
"image_transform_png_set_@_set(PNG_CONST image_transform *this,
    transform_display *that, png_structp pp, png_infop pi)
{
   png_set_@(pp);
   this->next->set(this->next, that, pp, pi);
}
","    transform_display *that, png_structp pp, png_infop pi)
{
   png_set_@(pp);
   this->next->set(this->next, that, pp, pi);
}
"
" chrm_modification_init(chrm_modification *me, png_modifier *pm,
   PNG_CONST color_encoding *encoding)
 {
    CIE_color white = white_point(encoding);
 
 /* Original end points: */
   me->encoding = encoding;

 /* Chromaticities (in fixed point): */
   me->wx = fix(chromaticity_x(white));
   me->wy = fix(chromaticity_y(white));

   me->rx = fix(chromaticity_x(encoding->red));
   me->ry = fix(chromaticity_y(encoding->red));
   me->gx = fix(chromaticity_x(encoding->green));
   me->gy = fix(chromaticity_y(encoding->green));
   me->bx = fix(chromaticity_x(encoding->blue));
   me->by = fix(chromaticity_y(encoding->blue));

   modification_init(&me->this);
   me->this.chunk = CHUNK_cHRM;
   me->this.modify_fn = chrm_modify;
   me->this.add = CHUNK_PLTE;
   me->this.next = pm->modifications;
   pm->modifications = &me->this;
}
","   PNG_CONST color_encoding *encoding)
"
"deinterlace_row(png_bytep buffer, png_const_bytep row,
   unsigned int pixel_size, png_uint_32 w, int pass)
{
   /* The inverse of the above, 'row' is part of row 'y' of the output image,
    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute
    * the pixels of row into buffer and return the number written (to allow
    * this to be checked).
    */
   png_uint_32 xin, xout, xstep;
   xout = PNG_PASS_START_COL(pass);
   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
   for (xin=0; xout<w; xout+=xstep)
   {
      pixel_copy(buffer, xout, row, xin, pixel_size);
      ++xin;
   }
}
","   unsigned int pixel_size, png_uint_32 w, int pass)
{
   /* The inverse of the above, 'row' is part of row 'y' of the output image,
    * in 'buffer'.  The image is 'w' wide and this is pass 'pass', distribute
    * the pixels of row into buffer and return the number written (to allow
    * this to be checked).
    */
   png_uint_32 xin, xout, xstep;
   xout = PNG_PASS_START_COL(pass);
   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
   for (xin=0; xout<w; xout+=xstep)
   {
      pixel_copy(buffer, xout, row, xin, pixel_size);
      ++xin;
   }
}
"
"static double digitize(double value, int depth, int do_round)
{
 /* 'value' is in the range 0 to 1, the result is the same value rounded to a
    * multiple of the digitization factor - 8 or 16 bits depending on both the
    * sample depth and the 'assume' setting.  Digitization is normally by

     * rounding and 'do_round' should be 1, if it is 0 the digitized value will
     * be truncated.
     */
   PNG_CONST unsigned int digitization_factor = (1U << depth) -1;
 
    /* Limiting the range is done as a convenience to the caller - it's easier to
     * do it once here than every time at the call site.
    */
 if (value <= 0)
      value = 0;

 else if (value >= 1)
      value = 1;

   value *= digitization_factor;
 if (do_round) value += .5;
 return floor(value)/digitization_factor;
}
","   PNG_CONST unsigned int digitization_factor = (1U << depth) -1;
"
" gamma_display_init(gamma_display *dp, png_modifier *pm, png_uint_32 id,
     double file_gamma, double screen_gamma, png_byte sbit, int threshold_test,
     int use_input_precision, int scale16, int expand16,
    int do_background, PNG_CONST png_color_16 *pointer_to_the_background_color,
     double background_gamma)
 {
    /* Standard fields */
   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/,
       pm->use_update_info);
 
    /* Parameter fields */
   dp->pm = pm;
   dp->file_gamma = file_gamma;
   dp->screen_gamma = screen_gamma;
   dp->background_gamma = background_gamma;
   dp->sbit = sbit;
   dp->threshold_test = threshold_test;
   dp->use_input_precision = use_input_precision;
   dp->scale16 = scale16;
   dp->expand16 = expand16;
   dp->do_background = do_background;
 if (do_background && pointer_to_the_background_color != 0)
      dp->background_color = *pointer_to_the_background_color;
 else
      memset(&dp->background_color, 0, sizeof dp->background_color);

 /* Local variable fields */
   dp->maxerrout = dp->maxerrpc = dp->maxerrabs = 0;
}
","    int do_background, PNG_CONST png_color_16 *pointer_to_the_background_color,
   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/,
"
" static void gamma_transform_test(png_modifier *pm,
   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,
   PNG_CONST int palette_number,
   PNG_CONST int interlace_type, PNG_CONST double file_gamma,
   PNG_CONST double screen_gamma, PNG_CONST png_byte sbit,
   PNG_CONST int use_input_precision, PNG_CONST int scale16)
 {
    size_t pos = 0;
    char name[64];

 if (sbit != bit_depth && sbit != 0)
 {
      pos = safecat(name, sizeof name, pos, ""sbit("");
      pos = safecatn(name, sizeof name, pos, sbit);
      pos = safecat(name, sizeof name, pos, "") "");
 }

 else
      pos = safecat(name, sizeof name, pos, ""gamma "");

 if (scale16)
      pos = safecat(name, sizeof name, pos, ""16to8 "");

   pos = safecatd(name, sizeof name, pos, file_gamma, 3);
   pos = safecat(name, sizeof name, pos, ""->"");
   pos = safecatd(name, sizeof name, pos, screen_gamma, 3);

   gamma_test(pm, colour_type, bit_depth, palette_number, interlace_type,
      file_gamma, screen_gamma, sbit, 0, name, use_input_precision,
      scale16, pm->test_gamma_expand16, 0 , 0, 0);
}
","   PNG_CONST png_byte colour_type, PNG_CONST png_byte bit_depth,
   PNG_CONST int palette_number,
   PNG_CONST int interlace_type, PNG_CONST double file_gamma,
   PNG_CONST double screen_gamma, PNG_CONST png_byte sbit,
   PNG_CONST int use_input_precision, PNG_CONST int scale16)
"
"image_pixel_add_alpha(image_pixel *this, PNG_CONST standard_display *display)
 {
    if (this->colour_type == PNG_COLOR_TYPE_PALETTE)
       image_pixel_convert_PLTE(this);

 if ((this->colour_type & PNG_COLOR_MASK_ALPHA) == 0)

    {
       if (this->colour_type == PNG_COLOR_TYPE_GRAY)
       {
         if (this->bit_depth < 8)
            this->bit_depth = 8;
 
          if (this->have_tRNS)
          {
             this->have_tRNS = 0;
 
             /* Check the input, original, channel value here against the
             * original tRNS gray chunk valie.
             */
 if (this->red == display->transparent.red)
 this->alphaf = 0;
 else
 this->alphaf = 1;
 }
 else
 this->alphaf = 1;

 this->colour_type = PNG_COLOR_TYPE_GRAY_ALPHA;
 }

 else if (this->colour_type == PNG_COLOR_TYPE_RGB)
 {
 if (this->have_tRNS)
 {
 this->have_tRNS = 0;

 /* Again, check the exact input values, not the current transformed
             * value!
             */
 if (this->red == display->transparent.red &&
 this->green == display->transparent.green &&
 this->blue == display->transparent.blue)

                this->alphaf = 0;
             else
                this->alphaf = 1;
            this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;
          }
       }
 
       /* The error in the alpha is zero and the sBIT value comes from the
       * original sBIT data (actually it will always be the original bit depth).
       */
 this->alphae = 0;

       this->alpha_sBIT = display->alpha_sBIT;
    }
 }
","         if (this->bit_depth < 8)
            this->bit_depth = 8;
            this->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;
"
" image_pixel_init(image_pixel *this, png_const_bytep row, png_byte colour_type,
    png_byte bit_depth, png_uint_32 x, store_palette palette)
 {
   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==
       PNG_COLOR_TYPE_PALETTE ? 8 : bit_depth);
   PNG_CONST unsigned int max = (1U<<sample_depth)-1;
 
    /* Initially just set everything to the same number and the alpha to opaque.
     * Note that this currently assumes a simple palette where entry x has colour
     * rgb(x,x,x)!
     */
    this->palette_index = this->red = this->green = this->blue =
      sample(row, colour_type, bit_depth, x, 0);
    this->alpha = max;
    this->red_sBIT = this->green_sBIT = this->blue_sBIT = this->alpha_sBIT =
       sample_depth;

 /* Then override as appropriate: */
 if (colour_type == 3) /* palette */
 {

       /* This permits the caller to default to the sample value. */
       if (palette != 0)
       {
         PNG_CONST unsigned int i = this->palette_index;
 
          this->red = palette[i].red;
          this->green = palette[i].green;
 this->blue = palette[i].blue;
 this->alpha = palette[i].alpha;
 }
 }

 else /* not palette */

    {
       unsigned int i = 0;
 
       if (colour_type & 2)
       {
         this->green = sample(row, colour_type, bit_depth, x, 1);
         this->blue = sample(row, colour_type, bit_depth, x, 2);
         i = 2;
       }
      if (colour_type & 4)
         this->alpha = sample(row, colour_type, bit_depth, x, ++i);
    }
 
    /* Calculate the scaled values, these are simply the values divided by
     * 'max' and the error is initialized to the double precision epsilon value
     * from the header file.
     */
   image_pixel_setf(this, max);
 
    /* Store the input information for use in the transforms - these will
     * modify the information.
    */
 this->colour_type = colour_type;

    this->bit_depth = bit_depth;
    this->sample_depth = sample_depth;
    this->have_tRNS = 0;
 }
","    png_byte bit_depth, png_uint_32 x, store_palette palette)
   PNG_CONST png_byte sample_depth = (png_byte)(colour_type ==
   PNG_CONST unsigned int max = (1U<<sample_depth)-1;
      sample(row, colour_type, bit_depth, x, 0);
         PNG_CONST unsigned int i = this->palette_index;
         this->green = sample(row, colour_type, bit_depth, x, 1);
         this->blue = sample(row, colour_type, bit_depth, x, 2);
         i = 2;
      if (colour_type & 4)
         this->alpha = sample(row, colour_type, bit_depth, x, ++i);
   image_pixel_setf(this, max);
"
"image_pixel_setf(image_pixel *this, unsigned int max)
 {
   this->redf = this->red / (double)max;
   this->greenf = this->green / (double)max;
   this->bluef = this->blue / (double)max;
   this->alphaf = this->alpha / (double)max;
 
   if (this->red < max)
       this->rede = this->redf * DBL_EPSILON;
    else
       this->rede = 0;
   if (this->green < max)
       this->greene = this->greenf * DBL_EPSILON;
    else
       this->greene = 0;
   if (this->blue < max)
       this->bluee = this->bluef * DBL_EPSILON;
    else
       this->bluee = 0;
   if (this->alpha < max)
       this->alphae = this->alphaf * DBL_EPSILON;
    else
       this->alphae = 0;
}
","   this->redf = this->red / (double)max;
   this->greenf = this->green / (double)max;
   this->bluef = this->blue / (double)max;
   this->alphaf = this->alpha / (double)max;
   if (this->red < max)
   if (this->green < max)
   if (this->blue < max)
   if (this->alpha < max)
"
" image_transform_default_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
    UNUSED(bit_depth)

 this->next = *that;
 *that = this;

 return 1;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
"image_transform_png_set_background_set(PNG_CONST image_transform *this,
     transform_display *that, png_structp pp, png_infop pi)
 {
    png_byte colour_type, bit_depth;
   png_byte random_bytes[8]; /* 8 bytes - 64 bits - the biggest pixel */
 int expand;
   png_color_16 back;

 /* We need a background colour, because we don't know exactly what transforms
    * have been set we have to supply the colour in the original file format and
    * so we need to know what that is!  The background colour is stored in the
    * transform_display.
    */
   RANDOMIZE(random_bytes);

 /* Read the random value, for colour type 3 the background colour is actually
    * expressed as a 24bit rgb, not an index.
    */
   colour_type = that->this.colour_type;
 if (colour_type == 3)
 {
      colour_type = PNG_COLOR_TYPE_RGB;
      bit_depth = 8;
      expand = 0; /* passing in an RGB not a pixel index */
 }

 
    else
    {
       bit_depth = that->this.bit_depth;
       expand = 1;
    }
 
    image_pixel_init(&data, random_bytes, colour_type,
      bit_depth, 0/*x*/, 0/*unused: palette*/);
 
    /* Extract the background colour from this image_pixel, but make sure the
     * unused fields of 'back' are garbage.
    */
   RANDOMIZE(back);

 if (colour_type & PNG_COLOR_MASK_COLOR)
 {
      back.red = (png_uint_16)data.red;
      back.green = (png_uint_16)data.green;
      back.blue = (png_uint_16)data.blue;
 }

 else
      back.gray = (png_uint_16)data.red;

#  ifdef PNG_FLOATING_POINT_SUPPORTED
      png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);
#  else
      png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);
#  endif

 this->next->set(this->next, that, pp, pi);

 }
","      bit_depth, 0/*x*/, 0/*unused: palette*/);
"
" image_transform_png_set_expand_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 /* expand_16 does something unless the bit depth is already 16. */
 return bit_depth < 16;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
"image_transform_png_set_expand_16_mod(PNG_CONST image_transform *this,
     image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    /* Expect expand_16 to expand everything to 16 bits as a result of also
     * causing 'expand' to happen.
    */
 if (that->colour_type == PNG_COLOR_TYPE_PALETTE)

       image_pixel_convert_PLTE(that);
 
    if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);
 
    if (that->bit_depth < 16)
       that->sample_depth = that->bit_depth = 16;

 this->next->mod(this->next, that, pp, display);
}
","    PNG_CONST transform_display *display)
      image_pixel_add_alpha(that, &display->this);
"
" image_transform_png_set_expand_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 /* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
    * depth is at least 8 already.
    */
 return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
" image_transform_png_set_expand_gray_1_2_4_to_8_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    return image_transform_png_set_expand_add(this, that, colour_type,
       bit_depth);
 }
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
" image_transform_png_set_expand_gray_1_2_4_to_8_mod(
    PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    image_transform_png_set_expand_mod(this, that, pp, display);
 }
","    PNG_CONST image_transform *this, image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
"
" image_transform_png_set_expand_gray_1_2_4_to_8_set(
    PNG_CONST image_transform *this, transform_display *that, png_structp pp,
     png_infop pi)
 {
    png_set_expand_gray_1_2_4_to_8(pp);
    this->next->set(this->next, that, pp, pi);
 }
","    PNG_CONST image_transform *this, transform_display *that, png_structp pp,
"
"image_transform_png_set_expand_mod(PNG_CONST image_transform *this,
     image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    /* The general expand case depends on what the colour type is: */
    if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
      image_pixel_convert_PLTE(that);
 else if (that->bit_depth < 8) /* grayscale */

       that->sample_depth = that->bit_depth = 8;
 
    if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);
 
    this->next->mod(this->next, that, pp, display);
 }
","    PNG_CONST transform_display *display)
      image_pixel_add_alpha(that, &display->this);
"
" image_transform_png_set_gray_to_rgb_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 return (colour_type & PNG_COLOR_MASK_COLOR) == 0;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
"image_transform_png_set_gray_to_rgb_mod(PNG_CONST image_transform *this,
     image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    /* NOTE: we can actually pend the tRNS processing at this point because we
     * can correctly recognize the original pixel value even though we have
    * mapped the one gray channel to the three RGB ones, but in fact libpng

     * doesn't do this, so we don't either.
     */
    if ((that->colour_type & PNG_COLOR_MASK_COLOR) == 0 && that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);
 
    /* Simply expand the bit depth and alter the colour type as required. */
    if (that->colour_type == PNG_COLOR_TYPE_GRAY)
 {
 /* RGB images have a bit depth at least equal to '8' */
 if (that->bit_depth < 8)
         that->sample_depth = that->bit_depth = 8;

 /* And just changing the colour type works here because the green and blue
       * channels are being maintained in lock-step with the red/gray:
       */
      that->colour_type = PNG_COLOR_TYPE_RGB;
 }

 else if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
      that->colour_type = PNG_COLOR_TYPE_RGB_ALPHA;

 this->next->mod(this->next, that, pp, display);
}
","    PNG_CONST transform_display *display)
      image_pixel_add_alpha(that, &display->this);
"
" image_transform_png_set_palette_to_rgb_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 return colour_type == PNG_COLOR_TYPE_PALETTE;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
"image_transform_png_set_palette_to_rgb_mod(PNG_CONST image_transform *this,
     image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
       image_pixel_convert_PLTE(that);

 this->next->mod(this->next, that, pp, display);
}
","    PNG_CONST transform_display *display)
"
" image_transform_png_set_rgb_to_gray_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 return (colour_type & PNG_COLOR_MASK_COLOR) != 0;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
" image_transform_png_set_scale_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
"image_transform_png_set_scale_16_mod(PNG_CONST image_transform *this,
     image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    if (that->bit_depth == 16)
    {
      that->sample_depth = that->bit_depth = 8;
 if (that->red_sBIT > 8) that->red_sBIT = 8;
 if (that->green_sBIT > 8) that->green_sBIT = 8;
 if (that->blue_sBIT > 8) that->blue_sBIT = 8;
 if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;
 }

 this->next->mod(this->next, that, pp, display);
}
","    PNG_CONST transform_display *display)
"
" image_transform_png_set_strip_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(colour_type)
 
 this->next = *that;
 *that = this;

 return bit_depth > 8;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
"image_transform_png_set_strip_16_mod(PNG_CONST image_transform *this,
     image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    if (that->bit_depth == 16)
    {
      that->sample_depth = that->bit_depth = 8;
 if (that->red_sBIT > 8) that->red_sBIT = 8;
 if (that->green_sBIT > 8) that->green_sBIT = 8;
 if (that->blue_sBIT > 8) that->blue_sBIT = 8;
 if (that->alpha_sBIT > 8) that->alpha_sBIT = 8;

 /* Prior to 1.5.4 png_set_strip_16 would use an 'accurate' method if this
       * configuration option is set.  From 1.5.4 the flag is never set and the
       * 'scale' API (above) must be used.
       */
#     ifdef PNG_READ_ACCURATE_SCALE_SUPPORTED
#        if PNG_LIBPNG_VER >= 10504
#           error PNG_READ_ACCURATE_SCALE should not be set
#        endif

 /* The strip 16 algorithm drops the low 8 bits rather than calculating
          * 1/257, so we need to adjust the permitted errors appropriately:
          * Notice that this is only relevant prior to the addition of the

           * png_set_scale_16 API in 1.5.4 (but 1.5.4+ always defines the above!)
           */
          {
            PNG_CONST double d = (255-128.5)/65535;
             that->rede += d;
             that->greene += d;
             that->bluee += d;
            that->alphae += d;
 }
#     endif
 }

 this->next->mod(this->next, that, pp, display);
}
","    PNG_CONST transform_display *display)
            PNG_CONST double d = (255-128.5)/65535;
"
" image_transform_png_set_strip_alpha_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 return (colour_type & PNG_COLOR_MASK_ALPHA) != 0;
}
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
"
"image_transform_png_set_strip_alpha_mod(PNG_CONST image_transform *this,
     image_pixel *that, png_const_structp pp,
    PNG_CONST transform_display *display)
 {
    if (that->colour_type == PNG_COLOR_TYPE_GRAY_ALPHA)
       that->colour_type = PNG_COLOR_TYPE_GRAY;
 else if (that->colour_type == PNG_COLOR_TYPE_RGB_ALPHA)
      that->colour_type = PNG_COLOR_TYPE_RGB;

   that->have_tRNS = 0;
   that->alphaf = 1;

 this->next->mod(this->next, that, pp, display);
}
","    PNG_CONST transform_display *display)
"
" image_transform_png_set_tRNS_to_alpha_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
 {
    UNUSED(bit_depth)
 
 this->next = *that;
 *that = this;

 
    /* We don't know yet whether there will be a tRNS chunk, but we know that
     * this transformation should do nothing if there already is an alpha
    * channel.
     */
   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
 }
","    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
    * channel.
   return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
"
"image_transform_png_set_tRNS_to_alpha_mod(PNG_CONST image_transform *this,
    image_pixel *that, png_const_structp pp,
   PNG_CONST transform_display *display)
 {
    /* LIBPNG BUG: this always forces palette images to RGB. */
    if (that->colour_type == PNG_COLOR_TYPE_PALETTE)
       image_pixel_convert_PLTE(that);
 
    /* This effectively does an 'expand' only if there is some transparency to
     * convert to an alpha channel.
     */
    if (that->have_tRNS)
      image_pixel_add_alpha(that, &display->this);
 
    /* LIBPNG BUG: otherwise libpng still expands to 8 bits! */
    else
    {
 if (that->bit_depth < 8)
         that->bit_depth =8;

       if (that->sample_depth < 8)
          that->sample_depth = 8;
    }
 
    this->next->mod(this->next, that, pp, display);
 }
","   PNG_CONST transform_display *display)
      image_pixel_add_alpha(that, &display->this);
"
"interlace_row(png_bytep buffer, png_const_bytep imageRow,
   unsigned int pixel_size, png_uint_32 w, int pass)
{
   png_uint_32 xin, xout, xstep;
   /* Note that this can, trivially, be optimized to a memcpy on pass 7, the
    * code is presented this way to make it easier to understand.  In practice
    * consult the code in the libpng source to see other ways of doing this.
    */
   xin = PNG_PASS_START_COL(pass);
   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
   for (xout=0; xin<w; xin+=xstep)
   {
      pixel_copy(buffer, xout, imageRow, xin, pixel_size);
      ++xout;
   }
}
","   unsigned int pixel_size, png_uint_32 w, int pass)
{
   png_uint_32 xin, xout, xstep;
   /* Note that this can, trivially, be optimized to a memcpy on pass 7, the
    * code is presented this way to make it easier to understand.  In practice
    * consult the code in the libpng source to see other ways of doing this.
    */
   xin = PNG_PASS_START_COL(pass);
   xstep = 1U<<PNG_PASS_COL_SHIFT(pass);
   for (xout=0; xin<w; xin+=xstep)
   {
      pixel_copy(buffer, xout, imageRow, xin, pixel_size);
      ++xout;
   }
}
"
"make_errors(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
    int bdlo, int PNG_CONST bdhi)
 {
    for (; bdlo <= bdhi; ++bdlo)
    {
 int interlace_type;

 for (interlace_type = PNG_INTERLACE_NONE;
           interlace_type < INTERLACE_LAST; ++interlace_type)
 {
 unsigned int test;

          char name[FILE_NAME_SIZE];
 
          standard_name(name, sizeof name, 0, colour_type, 1<<bdlo, 0,
            interlace_type, 0, 0, 0);
 
         for (test=0; test<(sizeof error_test)/(sizeof error_test[0]); ++test)
          {
             make_error(&pm->this, colour_type, DEPTH(bdlo), interlace_type,
                test, name);

 if (fail(pm))
 return 0;
 }
 }
 }

 return 1; /* keep going */
}
","    int bdlo, int PNG_CONST bdhi)
            interlace_type, 0, 0, 0);
         for (test=0; test<(sizeof error_test)/(sizeof error_test[0]); ++test)
"
"make_size(png_store* PNG_CONST ps, png_byte PNG_CONST colour_type, int bdlo,
    int PNG_CONST bdhi)
 {
    for (; bdlo <= bdhi; ++bdlo)
    {
      png_uint_32 width;

 for (width = 1; width <= 16; ++width)
 {
         png_uint_32 height;

 for (height = 1; height <= 16; ++height)
 {
 /* The four combinations of DIY interlace and interlace or not -
             * no interlace + DIY should be identical to no interlace with
             * libpng doing it.
             */
            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
               width, height, 0);
            make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_NONE,
               width, height, 1);

 #        ifdef PNG_WRITE_INTERLACING_SUPPORTED
             make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,
                width, height, 0);
             make_size_image(ps, colour_type, DEPTH(bdlo), PNG_INTERLACE_ADAM7,
                width, height, 1);
 #        endif
 }
 }
 }
}
","    int PNG_CONST bdhi)
"
"make_transform_images(png_store *ps)
 {
    png_byte colour_type = 0;
    png_byte bit_depth = 0;
    unsigned int palette_number = 0;
 
    /* This is in case of errors. */
   safecat(ps->test, sizeof ps->test, 0, ""make standard images"");
 
    /* Use next_format to enumerate all the combinations we test, including
    * generating multiple low bit depth palette images.
     */
   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
    {
       int interlace_type;
 
 for (interlace_type = PNG_INTERLACE_NONE;
           interlace_type < INTERLACE_LAST; ++interlace_type)
 {

          char name[FILE_NAME_SIZE];
 
          standard_name(name, sizeof name, 0, colour_type, bit_depth,
            palette_number, interlace_type, 0, 0, 0);
         make_transform_image(ps, colour_type, bit_depth, palette_number,
             interlace_type, name);
       }
    }
 }
","   safecat(ps->test, sizeof ps->test, 0, ""make standard images"");
    * generating multiple low bit depth palette images.
   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
            palette_number, interlace_type, 0, 0, 0);
         make_transform_image(ps, colour_type, bit_depth, palette_number,
"
" next_format(png_bytep colour_type, png_bytep bit_depth,
   unsigned int* palette_number, int no_low_depth_gray)
 {
    if (*bit_depth == 0)
    {
       *colour_type = 0;
      if (no_low_depth_gray)
         *bit_depth = 8;
      else
          *bit_depth = 1;
       *palette_number = 0;
       return 1;
    }
 
   if (*colour_type == 3)
    {
      /* Add multiple palettes for colour type 3. */
      if (++*palette_number < PALETTE_COUNT(*bit_depth))
          return 1;
 
       *palette_number = 0;
    }
 
 *bit_depth = (png_byte)(*bit_depth << 1);

 
    /* Palette images are restricted to 8 bit depth */
    if (*bit_depth <= 8
#     ifdef DO_16BIT
          || (*colour_type != 3 && *bit_depth <= 16)
#     endif
       )
       return 1;
 
 /* Move to the next color type, or return 0 at the end. */
 switch (*colour_type)
 {
 case 0:
 *colour_type = 2;
 *bit_depth = 8;
 return 1;

 case 2:
 *colour_type = 3;
 *bit_depth = 1;
 return 1;

 case 3:
 *colour_type = 4;
 *bit_depth = 8;
 return 1;

 case 4:
 *colour_type = 6;
 *bit_depth = 8;
 return 1;

 default:
 return 0;
 }
}
","   unsigned int* palette_number, int no_low_depth_gray)
      if (no_low_depth_gray)
         *bit_depth = 8;
      else
   if (*colour_type == 3)
      /* Add multiple palettes for colour type 3. */
      if (++*palette_number < PALETTE_COUNT(*bit_depth))
#     ifdef DO_16BIT
#     endif
"
" normalize_color_encoding(color_encoding *encoding)
 {
   PNG_CONST double whiteY = encoding->red.Y + encoding->green.Y +
       encoding->blue.Y;
 
    if (whiteY != 1)
 {
      encoding->red.X /= whiteY;
      encoding->red.Y /= whiteY;
      encoding->red.Z /= whiteY;
      encoding->green.X /= whiteY;
      encoding->green.Y /= whiteY;
      encoding->green.Z /= whiteY;
      encoding->blue.X /= whiteY;
      encoding->blue.Y /= whiteY;
      encoding->blue.Z /= whiteY;
 }

 }
","   PNG_CONST double whiteY = encoding->red.Y + encoding->green.Y +
"
"perform_gamma_composition_tests(png_modifier *pm, int do_background,
 int expand_16)
{
   png_byte colour_type = 0;
   png_byte bit_depth = 0;
 unsigned int palette_number = 0;

 
    /* Skip the non-alpha cases - there is no setting of a transparency colour at
     * present.
     */
   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
      if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0)
    {
       unsigned int i, j;
 
 /* Don't skip the i==j case here - it's relevant. */
 for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)
 {
         gamma_composition_test(pm, colour_type, bit_depth, palette_number,
            pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],
            pm->use_input_precision, do_background, expand_16);

 if (fail(pm))
 return;
 }
 }
}
","   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
      if ((colour_type & PNG_COLOR_MASK_ALPHA) != 0)
"
"static void perform_gamma_sbit_tests(png_modifier *pm)
{
   png_byte sbit;

 /* The only interesting cases are colour and grayscale, alpha is ignored here
    * for overall speed.  Only bit depths where sbit is less than the bit depth
    * are tested.
    */
 for (sbit=pm->sbitlow; sbit<(1<<READ_BDHI); ++sbit)
 {

       png_byte colour_type = 0, bit_depth = 0;
       unsigned int npalette = 0;
 
      while (next_format(&colour_type, &bit_depth, &npalette, 1/*gamma*/))
          if ((colour_type & PNG_COLOR_MASK_ALPHA) == 0 &&
             ((colour_type == 3 && sbit < 8) ||
             (colour_type != 3 && sbit < bit_depth)))
 {
 unsigned int i;

 for (i=0; i<pm->ngamma_tests; ++i)
 {
 unsigned int j;

 for (j=0; j<pm->ngamma_tests; ++j) if (i != j)
 {
               gamma_transform_test(pm, colour_type, bit_depth, npalette,
                  pm->interlace_type, 1/pm->gammas[i], pm->gammas[j],
                  sbit, pm->use_input_precision_sbit, 0 /*scale16*/);

 if (fail(pm))
 return;
 }
 }
 }
 }
}
","      while (next_format(&colour_type, &bit_depth, &npalette, 1/*gamma*/))
"
"static void perform_gamma_scale16_tests(png_modifier *pm)
{

 #  ifndef PNG_MAX_GAMMA_8
 #     define PNG_MAX_GAMMA_8 11
 #  endif
#  define SBIT_16_TO_8 PNG_MAX_GAMMA_8
    /* Include the alpha cases here. Note that sbit matches the internal value
     * used by the library - otherwise we will get spurious errors from the
     * internal sbit style approximation.
    *
    * The threshold test is here because otherwise the 16 to 8 conversion will
    * proceed *without* gamma correction, and the tests above will fail (but not
    * by much) - this could be fixed, it only appears with the -g option.
    */
 unsigned int i, j;
 for (i=0; i<pm->ngamma_tests; ++i)
 {
 for (j=0; j<pm->ngamma_tests; ++j)
 {
 if (i != j &&
             fabs(pm->gammas[j]/pm->gammas[i]-1) >= PNG_GAMMA_THRESHOLD)
 {
            gamma_transform_test(pm, 0, 16, 0, pm->interlace_type,
 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
               pm->use_input_precision_16to8, 1 /*scale16*/);

 if (fail(pm))
 return;

            gamma_transform_test(pm, 2, 16, 0, pm->interlace_type,
 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
               pm->use_input_precision_16to8, 1 /*scale16*/);

 if (fail(pm))
 return;

            gamma_transform_test(pm, 4, 16, 0, pm->interlace_type,
 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
               pm->use_input_precision_16to8, 1 /*scale16*/);

 if (fail(pm))
 return;

            gamma_transform_test(pm, 6, 16, 0, pm->interlace_type,
 1/pm->gammas[i], pm->gammas[j], SBIT_16_TO_8,
               pm->use_input_precision_16to8, 1 /*scale16*/);

 if (fail(pm))
 return;
 }
 }
 }
}
","#  define SBIT_16_TO_8 PNG_MAX_GAMMA_8
"
"perform_gamma_threshold_tests(png_modifier *pm)
{
   png_byte colour_type = 0;
   png_byte bit_depth = 0;
 unsigned int palette_number = 0;


    /* Don't test more than one instance of each palette - it's pointless, in
     * fact this test is somewhat excessive since libpng doesn't make this
     * decision based on colour type or bit depth!
     */
   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
      if (palette_number == 0)
    {
       double test_gamma = 1.0;
       while (test_gamma >= .4)
 {
 /* There's little point testing the interlacing vs non-interlacing,
          * but this can be set from the command line.
          */
         gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,
            test_gamma, 1/test_gamma);
         test_gamma *= .95;
 }

 /* And a special test for sRGB */
      gamma_threshold_test(pm, colour_type, bit_depth, pm->interlace_type,
 .45455, 2.2);

 if (fail(pm))
 return;
 }

 }
","   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
      if (palette_number == 0)
"
"static void perform_gamma_transform_tests(png_modifier *pm)
{
   png_byte colour_type = 0;

    png_byte bit_depth = 0;
    unsigned int palette_number = 0;
 
   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
    {
       unsigned int i, j;
 
 for (i=0; i<pm->ngamma_tests; ++i) for (j=0; j<pm->ngamma_tests; ++j)
 if (i != j)
 {
            gamma_transform_test(pm, colour_type, bit_depth, palette_number,
               pm->interlace_type, 1/pm->gammas[i], pm->gammas[j], 0/*sBIT*/,
               pm->use_input_precision, 0 /*do not scale16*/);

 if (fail(pm))
 return;
 }
 }
}
","   while (next_format(&colour_type, &bit_depth, &palette_number, 1/*gamma*/))
"
" perform_transform_test(png_modifier *pm)
 {
   png_byte colour_type = 0;

    png_byte bit_depth = 0;
    unsigned int palette_number = 0;
 
   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
    {
       png_uint_32 counter = 0;
       size_t base_pos;
 char name[64];

      base_pos = safecat(name, sizeof name, 0, ""transform:"");


       for (;;)
       {
          size_t pos = base_pos;
         PNG_CONST image_transform *list = 0;
 
          /* 'max' is currently hardwired to '1'; this should be settable on the
           * command line.
          */
         counter = image_transform_add(&list, 1/*max*/, counter,
            name, sizeof name, &pos, colour_type, bit_depth);

 if (counter == 0)
 break;

 /* The command line can change this to checking interlaced images. */
 do
 {
            pm->repeat = 0;
            transform_test(pm, FILEID(colour_type, bit_depth, palette_number,
               pm->interlace_type, 0, 0, 0), list, name);

 if (fail(pm))
 return;
 }
 while (pm->repeat);
 }
 }
}
","   while (next_format(&colour_type, &bit_depth, &palette_number, 0))
         PNG_CONST image_transform *list = 0;
"
" pixel_copy(png_bytep toBuffer, png_uint_32 toIndex,
   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize)
 {
    /* Assume we can multiply by 'size' without overflow because we are
     * just working in a single buffer.
    */
   toIndex *= pixelSize;
   fromIndex *= pixelSize;

    if (pixelSize < 8) /* Sub-byte */
    {
       /* Mask to select the location of the copied pixel: */
      unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));
       /* The following read the entire pixels and clears the extra: */
       unsigned int destByte = toBuffer[toIndex >> 3] & ~destMask;
       unsigned int sourceByte = fromBuffer[fromIndex >> 3];
 
       /* Don't rely on << or >> supporting '0' here, just in case: */
       fromIndex &= 7;
      if (fromIndex > 0) sourceByte <<= fromIndex;
      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;
 
       toBuffer[toIndex >> 3] = (png_byte)(destByte | (sourceByte & destMask));
    }
 else /* One or more bytes */
      memmove(toBuffer+(toIndex>>3), fromBuffer+(fromIndex>>3), pixelSize>>3);
}
","   png_const_bytep fromBuffer, png_uint_32 fromIndex, unsigned int pixelSize)
      unsigned int destMask = ((1U<<pixelSize)-1) << (8-pixelSize-(toIndex&7));
      if (fromIndex > 0) sourceByte <<= fromIndex;
      if ((toIndex & 7) > 0) sourceByte >>= toIndex & 7;
"
" random_32(void)
 {
 
   for(;;)
    {
       png_byte mark[4];
       png_uint_32 result;

      store_pool_mark(mark);
      result = png_get_uint_32(mark);

 if (result != 0)
 return result;
 }
}
","   for(;;)
"
"row_copy(png_bytep toBuffer, png_const_bytep fromBuffer, unsigned int bitWidth)
 {
    memcpy(toBuffer, fromBuffer, bitWidth >> 3);
 
 if ((bitWidth & 7) != 0)
 {
 unsigned int mask;

 
       toBuffer += bitWidth >> 3;
       fromBuffer += bitWidth >> 3;
      /* The remaining bits are in the top of the byte, the mask is the bits to
       * retain.
       */
      mask = 0xff >> (bitWidth & 7);
       *toBuffer = (png_byte)((*toBuffer & mask) | (*fromBuffer & ~mask));
    }
 }
","      /* The remaining bits are in the top of the byte, the mask is the bits to
       * retain.
       */
      mask = 0xff >> (bitWidth & 7);
"
" static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
 {
    while (pos < bufsize && cat != NULL && *cat != 0)
       buffer[pos++] = *cat++;

 if (pos >= bufsize)
      pos = bufsize-1;

   buffer[pos] = 0;
 return pos;
}
","   PNG_CONST char *cat)
"
" safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST color_encoding *e, double encoding_gamma)
 {
    if (e != 0)
    {
 if (encoding_gamma != 0)
         pos = safecat(buffer, bufsize, pos, ""("");
      pos = safecat(buffer, bufsize, pos, ""R("");
      pos = safecatd(buffer, bufsize, pos, e->red.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);
      pos = safecat(buffer, bufsize, pos, ""),G("");
      pos = safecatd(buffer, bufsize, pos, e->green.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);
      pos = safecat(buffer, bufsize, pos, ""),B("");
      pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);
      pos = safecat(buffer, bufsize, pos, "","");
      pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);
      pos = safecat(buffer, bufsize, pos, "")"");
 if (encoding_gamma != 0)
         pos = safecat(buffer, bufsize, pos, "")"");
 }

 if (encoding_gamma != 0)
 {
      pos = safecat(buffer, bufsize, pos, ""^"");
      pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);
 }

 
    return pos;
 }
","   PNG_CONST color_encoding *e, double encoding_gamma)
"
" safecat_current_encoding(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST png_modifier *pm)
 {
    pos = safecat_color_encoding(buffer, bufsize, pos, pm->current_encoding,
       pm->current_gamma);

 if (pm->encoding_ignored)
      pos = safecat(buffer, bufsize, pos, ""[overridden]"");

 
    return pos;
 }
","   PNG_CONST png_modifier *pm)
"
" sample(png_const_bytep row, png_byte colour_type, png_byte bit_depth,
    png_uint_32 x, unsigned int sample_index)
 {
    png_uint_32 bit_index, result;
 
 /* Find a sample index for the desired sample: */
   x *= bit_depth;
   bit_index = x;

 if ((colour_type & 1) == 0) /* !palette */
 {
 if (colour_type & 2)
         bit_index *= 3;

 if (colour_type & 4)
         bit_index += x; /* Alpha channel */

 /* Multiple channels; select one: */
 if (colour_type & (2+4))
         bit_index += sample_index * bit_depth;
 }

 /* Return the sample from the row as an integer. */
   row += bit_index >> 3;
   result = *row;

 if (bit_depth == 8)

       return result;
 
    else if (bit_depth > 8)
      return (result << 8) + *++row;
 
   /* Less than 8 bits per sample. */
    bit_index &= 7;
   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);
 }
","    png_uint_32 x, unsigned int sample_index)
      return (result << 8) + *++row;
   /* Less than 8 bits per sample. */
   return (result >> (8-bit_index-bit_depth)) & ((1U<<bit_depth)-1);
"
" set_modifier_for_read(png_modifier *pm, png_infopp ppi, png_uint_32 id,
    PNG_CONST char *name)
 {
    /* Do this first so that the modifier fields are cleared even if an error
     * happens allocating the png_struct.  No allocation is done here so no
    * cleanup is required.
    */
   pm->state = modifier_start;
   pm->bit_depth = 0;
   pm->colour_type = 255;

   pm->pending_len = 0;
   pm->pending_chunk = 0;
   pm->flush = 0;
   pm->buffer_count = 0;
   pm->buffer_position = 0;

 return set_store_for_read(&pm->this, ppi, id, name);
}
","    PNG_CONST char *name)
"
" set_store_for_read(png_store *ps, png_infopp ppi, png_uint_32 id,
   PNG_CONST char *name)
 {
    /* Set the name for png_error */
    safecat(ps->test, sizeof ps->test, 0, name);

 if (ps->pread != NULL)
      png_error(ps->pread, ""read store already in use"");

   store_read_reset(ps);

 /* Both the create APIs can return NULL if used in their default mode
    * (because there is no other way of handling an error because the jmp_buf
    * by default is stored in png_struct and that has not been allocated!)
    * However, given that store_error works correctly in these circumstances
    * we don't ever expect NULL in this program.
    */
#  ifdef PNG_USER_MEM_SUPPORTED
 if (!ps->speed)
         ps->pread = png_create_read_struct_2(PNG_LIBPNG_VER_STRING, ps,
             store_error, store_warning, &ps->read_memory_pool, store_malloc,
             store_free);

 else
#  endif
   ps->pread = png_create_read_struct(PNG_LIBPNG_VER_STRING, ps, store_error,
      store_warning);

 if (ps->pread == NULL)
 {
 struct exception_context *the_exception_context = &ps->exception_context;

      store_log(ps, NULL, ""png_create_read_struct returned NULL (unexpected)"",
 1 /*error*/);

 Throw ps;
 }

#  ifdef PNG_SET_OPTION_SUPPORTED
 {
 int opt;
 for (opt=0; opt<ps->noptions; ++opt)
 if (png_set_option(ps->pread, ps->options[opt].option,
               ps->options[opt].setting) == PNG_OPTION_INVALID)
                  png_error(ps->pread, ""png option invalid"");
 }
#  endif

   store_read_set(ps, id);

 if (ppi != NULL)
 *ppi = ps->piread = png_create_info_struct(ps->pread);

 return ps->pread;
}
","   PNG_CONST char *name)
"
"set_store_for_write(png_store *ps, png_infopp ppi,
   PNG_CONST char * volatile name)
 {
    anon_context(ps);
 
 Try
 {
 if (ps->pwrite != NULL)
         png_error(ps->pwrite, ""write store already in use"");

      store_write_reset(ps);
      safecat(ps->wname, sizeof ps->wname, 0, name);

 /* Don't do the slow memory checks if doing a speed test, also if user
       * memory is not supported we can't do it anyway.
       */
#     ifdef PNG_USER_MEM_SUPPORTED
 if (!ps->speed)
            ps->pwrite = png_create_write_struct_2(PNG_LIBPNG_VER_STRING,
               ps, store_error, store_warning, &ps->write_memory_pool,
               store_malloc, store_free);

 else
#     endif
         ps->pwrite = png_create_write_struct(PNG_LIBPNG_VER_STRING,
            ps, store_error, store_warning);

      png_set_write_fn(ps->pwrite, ps, store_write, store_flush);

#     ifdef PNG_SET_OPTION_SUPPORTED
 {
 int opt;
 for (opt=0; opt<ps->noptions; ++opt)
 if (png_set_option(ps->pwrite, ps->options[opt].option,
                  ps->options[opt].setting) == PNG_OPTION_INVALID)
                  png_error(ps->pwrite, ""png option invalid"");
 }
#     endif

 if (ppi != NULL)
 *ppi = ps->piwrite = png_create_info_struct(ps->pwrite);
 }

 Catch_anonymous
 return NULL;

 return ps->pwrite;
}
","   PNG_CONST char * volatile name)
"
"standard_info_part2(standard_display *dp, png_const_structp pp,

     png_const_infop pi, int nImages)
 {
    /* Record cbRow now that it can be found. */
   dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),
      png_get_bit_depth(pp, pi));
    dp->bit_width = png_get_image_width(pp, pi) * dp->pixel_size;
    dp->cbRow = png_get_rowbytes(pp, pi);
 
 /* Validate the rowbytes here again. */
 if (dp->cbRow != (dp->bit_width+7)/8)
      png_error(pp, ""bad png_get_rowbytes calculation"");

 /* Then ensure there is enough space for the output image(s). */
   store_ensure_image(dp->ps, pp, nImages, dp->cbRow, dp->h);
}
","   dp->pixel_size = bit_size(pp, png_get_color_type(pp, pi),
      png_get_bit_depth(pp, pi));
"
"standard_name(char *buffer, size_t bufsize, size_t pos, png_byte colour_type,
 int bit_depth, unsigned int npalette, int interlace_type,

     png_uint_32 w, png_uint_32 h, int do_interlace)
 {
    pos = safecat(buffer, bufsize, pos, colour_types[colour_type]);
   if (npalette > 0)
    {
       pos = safecat(buffer, bufsize, pos, ""["");
       pos = safecatn(buffer, bufsize, pos, npalette);
       pos = safecat(buffer, bufsize, pos, ""]"");
    }
    pos = safecat(buffer, bufsize, pos, "" "");
    pos = safecatn(buffer, bufsize, pos, bit_depth);
    pos = safecat(buffer, bufsize, pos, "" bit"");

 if (interlace_type != PNG_INTERLACE_NONE)
 {
      pos = safecat(buffer, bufsize, pos, "" interlaced"");
 if (do_interlace)
         pos = safecat(buffer, bufsize, pos, ""(pngvalid)"");
 else
         pos = safecat(buffer, bufsize, pos, ""(libpng)"");
 }

 if (w > 0 || h > 0)
 {
      pos = safecat(buffer, bufsize, pos, "" "");
      pos = safecatn(buffer, bufsize, pos, w);
      pos = safecat(buffer, bufsize, pos, ""x"");
      pos = safecatn(buffer, bufsize, pos, h);
 }

 return pos;
}
","   if (npalette > 0)
"
" store_message(png_store *ps, png_const_structp pp, char *buffer, size_t bufsize,
   size_t pos, PNG_CONST char *msg)
 {
    if (pp != NULL && pp == ps->pread)
    {
 /* Reading a file */
      pos = safecat(buffer, bufsize, pos, ""read: "");

 if (ps->current != NULL)
 {
         pos = safecat(buffer, bufsize, pos, ps->current->name);
         pos = safecat(buffer, bufsize, pos, sep);
 }
 }

 else if (pp != NULL && pp == ps->pwrite)
 {
 /* Writing a file */
      pos = safecat(buffer, bufsize, pos, ""write: "");
      pos = safecat(buffer, bufsize, pos, ps->wname);
      pos = safecat(buffer, bufsize, pos, sep);
 }

 else
 {
 /* Neither reading nor writing (or a memory error in struct delete) */
      pos = safecat(buffer, bufsize, pos, ""pngvalid: "");
 }

 if (ps->test[0] != 0)
 {
      pos = safecat(buffer, bufsize, pos, ps->test);
      pos = safecat(buffer, bufsize, pos, sep);
 }
   pos = safecat(buffer, bufsize, pos, msg);
 return pos;
}
","   size_t pos, PNG_CONST char *msg)
"
"store_pool_delete(png_store *ps, store_pool *pool)
{
 if (pool->list != NULL)
 {
      fprintf(stderr, ""%s: %s %s: memory lost (list follows):\n"", ps->test,
         pool == &ps->read_memory_pool ? ""read"" : ""write"",
         pool == &ps->read_memory_pool ? (ps->current != NULL ?
            ps->current->name : ""unknown file"") : ps->wname);
 ++ps->nerrors;

 do
 {
         store_memory *next = pool->list;
         pool->list = next->next;

          next->next = NULL;
 
          fprintf(stderr, ""\t%lu bytes @ %p\n"",
             (unsigned long)next->size, (PNG_CONST void*)(next+1));
          /* The NULL means this will always return, even if the memory is
           * corrupted.
           */
         store_memory_free(NULL, pool, next);
 }
 while (pool->list != NULL);
 }

 /* And reset the other fields too for the next time. */
 if (pool->max > pool->max_max) pool->max_max = pool->max;
   pool->max = 0;
 if (pool->current != 0) /* unexpected internal error */
      fprintf(stderr, ""%s: %s %s: memory counter mismatch (internal error)\n"",
         ps->test, pool == &ps->read_memory_pool ? ""read"" : ""write"",
         pool == &ps->read_memory_pool ? (ps->current != NULL ?
            ps->current->name : ""unknown file"") : ps->wname);
   pool->current = 0;

 if (pool->limit > pool->max_limit)
      pool->max_limit = pool->limit;

   pool->limit = 0;

 if (pool->total > pool->max_total)
      pool->max_total = pool->total;

   pool->total = 0;

 /* Get a new mark too. */
   store_pool_mark(pool->mark);
}
","             (unsigned long)next->size, (PNG_CONST void*)(next+1));
"
"test_standard(png_modifier* PNG_CONST pm, png_byte PNG_CONST colour_type,
    int bdlo, int PNG_CONST bdhi)
 {
    for (; bdlo <= bdhi; ++bdlo)
    {
 int interlace_type;

 for (interlace_type = PNG_INTERLACE_NONE;

            interlace_type < INTERLACE_LAST; ++interlace_type)
       {
          standard_test(&pm->this, FILEID(colour_type, DEPTH(bdlo), 0/*palette*/,
            interlace_type, 0, 0, 0), 0/*do_interlace*/, pm->use_update_info);
 
          if (fail(pm))
             return 0;
 }
 }

 return 1; /* keep going */
}
","    int bdlo, int PNG_CONST bdhi)
            interlace_type, 0, 0, 0), 0/*do_interlace*/, pm->use_update_info);
"
" transform_display_init(transform_display *dp, png_modifier *pm, png_uint_32 id,
    PNG_CONST image_transform *transform_list)
 {
    memset(dp, 0, sizeof *dp);
 
    /* Standard fields */
   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/,
       pm->use_update_info);
 
    /* Parameter fields */
    dp->pm = pm;
    dp->transform_list = transform_list;
 
    /* Local variable fields */
    dp->output_colour_type = 255; /* invalid */
    dp->output_bit_depth = 255;  /* invalid */
 }
","    PNG_CONST image_transform *transform_list)
   standard_display_init(&dp->this, &pm->this, id, 0/*do_interlace*/,
"
"read_png(FILE *fp)
{
   png_structp png_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING,0,0,0);
   png_infop info_ptr = NULL;
   png_bytep row = NULL, display = NULL;

 if (png_ptr == NULL)
 return 0;

 if (setjmp(png_jmpbuf(png_ptr)))
 {
      png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
 if (row != NULL) free(row);
 if (display != NULL) free(display);
 return 0;
 }

   png_init_io(png_ptr, fp);

   info_ptr = png_create_info_struct(png_ptr);
 if (info_ptr == NULL)
      png_error(png_ptr, ""OOM allocating info structure"");

   png_set_keep_unknown_chunks(png_ptr, PNG_HANDLE_CHUNK_ALWAYS, NULL, 0);

   png_read_info(png_ptr, info_ptr);


    {
       png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);
 
       row = malloc(rowbytes);
       display = malloc(rowbytes);
 
 if (row == NULL || display == NULL)
         png_error(png_ptr, ""OOM allocating row buffers"");

 
       {
          png_uint_32 height = png_get_image_height(png_ptr, info_ptr);
         int passes = png_set_interlace_handling(png_ptr);
          int pass;
 
          png_start_read_image(png_ptr);

 for (pass = 0; pass < passes; ++pass)

          {
             png_uint_32 y = height;
 
             /* NOTE: this trashes the row each time; interlace handling won't
              * work, but this avoids memory thrashing for speed testing.
              */
 while (y-- > 0)
               png_read_row(png_ptr, row, display);
 }
 }
 }

 /* Make sure to read to the end of the file: */
   png_read_end(png_ptr, info_ptr);
   png_destroy_read_struct(&png_ptr, &info_ptr, NULL);
   free(row);
   free(display);
 return 1;
}
","         int passes = png_set_interlace_handling(png_ptr);
"
"void usage()
{
  fprintf (stderr, ""PNG2PNM\n"");
  fprintf (stderr, ""   by Willem van Schaik, 1999\n"");
#ifdef __TURBOC__
  fprintf (stderr, ""   for Turbo-C and Borland-C compilers\n"");
#else
  fprintf (stderr, ""   for Linux (and Unix) compilers\n"");
#endif

   fprintf (stderr, ""Usage:  png2pnm [options] <file>.png [<file>.pnm]\n"");
   fprintf (stderr, ""   or:  ... | png2pnm [options]\n"");
   fprintf (stderr, ""Options:\n"");
  fprintf (stderr, ""   -r[aw]   write pnm-file in binary format (P4/P5/P6) (default)\n"");
   fprintf (stderr, ""   -n[oraw] write pnm-file in ascii format (P1/P2/P3)\n"");
  fprintf (stderr, ""   -a[lpha] <file>.pgm write PNG alpha channel as pgm-file\n"");
   fprintf (stderr, ""   -h | -?  print this help-information\n"");
 }
","  fprintf (stderr, ""   -r[aw]   write pnm-file in binary format (P4/P5/P6) (default)\n"");
  fprintf (stderr, ""   -a[lpha] <file>.pgm write PNG alpha channel as pgm-file\n"");
"
"void usage()
{
  fprintf (stderr, ""PNM2PNG\n"");
  fprintf (stderr, ""   by Willem van Schaik, 1999\n"");
#ifdef __TURBOC__
  fprintf (stderr, ""   for Turbo-C and Borland-C compilers\n"");
#else
  fprintf (stderr, ""   for Linux (and Unix) compilers\n"");
#endif
  fprintf (stderr, ""Usage:  pnm2png [options] <file>.<pnm> [<file>.png]\n"");

   fprintf (stderr, ""   or:  ... | pnm2png [options]\n"");
   fprintf (stderr, ""Options:\n"");
   fprintf (stderr, ""   -i[nterlace]   write png-file with interlacing on\n"");
  fprintf (stderr, ""   -a[lpha] <file>.pgm read PNG alpha channel as pgm-file\n"");
   fprintf (stderr, ""   -h | -?  print this help-information\n"");
 }
","  fprintf (stderr, ""   -a[lpha] <file>.pgm read PNG alpha channel as pgm-file\n"");
"
"IDAT_list_extend(struct IDAT_list *tail)
{
 /* Use the previous cached value if available. */
 struct IDAT_list *next = tail->next;

 if (next == NULL)
 {
 /* Insert a new, malloc'ed, block of IDAT information buffers, this
       * one twice as large as the previous one:
       */
 unsigned int length = 2 * tail->length;

 
       if (length < tail->length) /* arithmetic overflow */
          length = tail->length;
      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));
       CLEAR(*next);
 
       /* The caller must handle this: */
 if (next == NULL)
 return NULL;

      next->next = NULL;
      next->length = length;
      tail->next = next;
 }

 return next;
}
","      next = png_voidcast(IDAT_list*, malloc(IDAT_list_size(NULL, length)));
"
" allocate(struct file *file, int allocate_idat)
 {
   struct control *control = png_voidcast(struct control*, file->alloc_ptr);
 
    if (allocate_idat)
    {
      assert(file->idat == NULL);
      IDAT_init(&control->idat, file);
 }

 else /* chunk */
 {
      assert(file->chunk == NULL);
      chunk_init(&control->chunk, file);
 }
}
","   struct control *control = png_voidcast(struct control*, file->alloc_ptr);
"
"chunk_type_valid(png_uint_32 c)
 /* Bit whacking approach to chunk name validation that is intended to avoid
    * branches.  The cost is that it uses a lot of 32-bit constants, which might
    * be bad on some architectures.
    */
{
   png_uint_32 t;

 /* Remove bit 5 from all but the reserved byte; this means every
    * 8-bit unit must be in the range 65-90 to be valid.  So bit 5
    * must be zero, bit 6 must be set and bit 7 zero.
    */

    c &= ~PNG_U32(32,32,0,32);
    t = (c & ~0x1f1f1f1f) ^ 0x40404040;
 
   /* Subtract 65 for each 8 bit quantity, this must not overflow
     * and each byte must then be in the range 0-25.
     */
    c -= PNG_U32(65,65,65,65);
   t |=c ;

 /* Subtract 26, handling the overflow which should set the top
    * three bits of each byte.
    */
   c -= PNG_U32(25,25,25,26);
   t |= ~c;

 return (t & 0xe0e0e0e0) == 0;
}
","   /* Subtract 65 for each 8 bit quantity, this must not overflow
"
"get_control(png_const_structrp png_ptr)
{

    /* This just returns the (file*).  The chunk and idat control structures
     * don't always exist.
     */
   struct control *control = png_voidcast(struct control*,
       png_get_error_ptr(png_ptr));
    return &control->file;
 }
","   struct control *control = png_voidcast(struct control*,
"
" main(void)
 {
    fprintf(stderr,
       ""pngfix needs libpng with a zlib >=1.2.4 (not 0x%x)\n"",
      PNG_ZLIB_VERNUM);
    return 77;
 }
","      PNG_ZLIB_VERNUM);
"
" main(void)
 {
   fprintf(stderr, ""pngfix does not work without read support\n"");
    return 77;
 }
","   fprintf(stderr, ""pngfix does not work without read support\n"");
"
" make_random_bytes(png_uint_32* seed, void* pv, size_t size)
 {
    png_uint_32 u0 = seed[0], u1 = seed[1];
   png_bytep bytes = png_voidcast(png_bytep, pv);
 
    /* There are thirty-three bits; the next bit in the sequence is bit-33 XOR
     * bit-20.  The top 1 bit is in u1, the bottom 32 are in u0.
    */
 size_t i;
 for (i=0; i<size; ++i)
 {
 /* First generate 8 new bits then shift them in at the end. */
      png_uint_32 u = ((u0 >> (20-8)) ^ ((u1 << 7) | (u0 >> (32-7)))) & 0xff;
      u1 <<= 8;
      u1 |= u0 >> 24;
      u0 <<= 8;
      u0 |= u;
 *bytes++ = (png_byte)u;
 }

   seed[0] = u0;
   seed[1] = u1;
}
","   png_bytep bytes = png_voidcast(png_bytep, pv);
"
"zlib_init(struct zlib *zlib, struct IDAT *idat, struct chunk *chunk,
 int window_bits, png_uint_32 offset)
 /* Initialize a zlib_control; the result is true/false */
{
   CLEAR(*zlib);

   zlib->idat = idat;
   zlib->chunk = chunk;
   zlib->file = chunk->file;
   zlib->global = chunk->global;
   zlib->rewrite_offset = offset; /* never changed for this zlib */

 /* *_out does not need to be set: */
   zlib->z.next_in = Z_NULL;
   zlib->z.avail_in = 0;
   zlib->z.zalloc = Z_NULL;
   zlib->z.zfree = Z_NULL;
   zlib->z.opaque = Z_NULL;

   zlib->state = -1;
   zlib->window_bits = window_bits;

   zlib->compressed_digits = 0;
   zlib->uncompressed_digits = 0;


    /* These values are sticky across reset (in addition to the stuff in the
     * first block, which is actually constant.)
     */
   zlib->file_bits = 16;
    zlib->ok_bits = 16; /* unset */
    zlib->cksum = 0; /* set when a checksum error is detected */
 
 /* '0' means use the header; inflateInit2 should always succeed because it
    * does nothing apart from allocating the internal zstate.
    */
   zlib->rc = inflateInit2(&zlib->z, 0);
 if (zlib->rc != Z_OK)
 {
      zlib_message(zlib, 1/*unexpected*/);
 return 0;
 }

 else
 {
      zlib->state = 0; /* initialized */
 return 1;
 }
}
","   zlib->file_bits = 16;
"
"native_handle* Parcel::readNativeHandle() const
{
 int numFds, numInts;
 status_t err;
    err = readInt32(&numFds);
 if (err != NO_ERROR) return 0;
    err = readInt32(&numInts);
 if (err != NO_ERROR) return 0;

    native_handle* h = native_handle_create(numFds, numInts);
 if (!h) {
 return 0;
 }

 
     for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
         h->data[i] = dup(readFileDescriptor());
        if (h->data[i] < 0) err = BAD_VALUE;
     }
     err = read(h->data + numFds, sizeof(int)*numInts);
     if (err != NO_ERROR) {
        native_handle_close(h);
        native_handle_delete(h);
        h = 0;
 }
 return h;
}
","        if (h->data[i] < 0) err = BAD_VALUE;
"
"OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         hComp,
        OMX_IN OMX_BUFFERHEADERTYPE* buffer)
{
    OMX_ERRORTYPE ret1 = OMX_ErrorNone;

     unsigned int nBufferIndex ;
 
     DEBUG_PRINT_LOW(""ETB: buffer = %p, buffer->pBuffer[%p]"", buffer, buffer->pBuffer);
    if (m_state == OMX_StateInvalid) {
         DEBUG_PRINT_ERROR(""ERROR: Empty this buffer in Invalid State"");
         return OMX_ErrorInvalidState;
     }

 if (buffer == NULL || (buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> buffer is null or buffer size is invalid"");
 return OMX_ErrorBadParameter;
 }

 if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::etb--> OMX Version Invalid"");
 return OMX_ErrorVersionMismatch;
 }

 if (buffer->nInputPortIndex != (OMX_U32)PORT_INDEX_IN) {
        DEBUG_PRINT_ERROR(""ERROR: Bad port index to call empty_this_buffer"");
 return OMX_ErrorBadPortIndex;
 }
 if (!m_sInPortDef.bEnabled) {
        DEBUG_PRINT_ERROR(""ERROR: Cannot call empty_this_buffer while I/P port is disabled"");
 return OMX_ErrorIncorrectStateOperation;
 }

    nBufferIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);

 if (nBufferIndex > m_sInPortDef.nBufferCountActual ) {
        DEBUG_PRINT_ERROR(""ERROR: ETB: Invalid buffer index[%d]"", nBufferIndex);
 return OMX_ErrorBadParameter;
 }

    m_etb_count++;
    DEBUG_PRINT_LOW(""DBG: i/p nTimestamp = %u"", (unsigned)buffer->nTimeStamp);
    post_event ((unsigned long)hComp,(unsigned long)buffer,m_input_msg_id);
 return OMX_ErrorNone;
}
","    if (m_state == OMX_StateInvalid) {
"
"OMX_ERRORTYPE  omx_video::fill_this_buffer(OMX_IN OMX_HANDLETYPE  hComp,

         OMX_IN OMX_BUFFERHEADERTYPE* buffer)
 {
     DEBUG_PRINT_LOW(""FTB: buffer->pBuffer[%p]"", buffer->pBuffer);
    if (m_state == OMX_StateInvalid) {
         DEBUG_PRINT_ERROR(""ERROR: FTB in Invalid State"");
         return OMX_ErrorInvalidState;
     }

 if (buffer == NULL ||(buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Invalid buffer or size"");
 return OMX_ErrorBadParameter;
 }

 if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->OMX Version Invalid"");
 return OMX_ErrorVersionMismatch;
 }

 if (buffer->nOutputPortIndex != (OMX_U32)PORT_INDEX_OUT) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->Bad port index"");
 return OMX_ErrorBadPortIndex;
 }

 if (!m_sOutPortDef.bEnabled) {
        DEBUG_PRINT_ERROR(""ERROR: omx_video::ftb-->port is disabled"");
 return OMX_ErrorIncorrectStateOperation;
 }

    post_event((unsigned long) hComp, (unsigned long)buffer,OMX_COMPONENT_GENERATE_FTB);
 return OMX_ErrorNone;
}
","    if (m_state == OMX_StateInvalid) {
"
" static BT_HDR *create_pbuf(UINT16 len, UINT8 *data)
 {
    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));
 
     if (p_buf) {
         UINT8* pbuf_data;

        p_buf->len = len;
        p_buf->offset = BTA_HH_MIN_OFFSET;

        pbuf_data = (UINT8*) (p_buf + 1) + p_buf->offset;
        memcpy(pbuf_data, data, len);
 }
 return p_buf;
}
","    BT_HDR* p_buf = GKI_getbuf((UINT16) (len + BTA_HH_MIN_OFFSET + sizeof(BT_HDR)));
"
" status_t NuPlayer::GenericSource::setBuffers(
         bool audio, Vector<MediaBuffer *> &buffers) {
    if (mIsSecure && !audio) {
         return mVideoTrack.mSource->setBuffers(buffers);
     }
     return INVALID_OPERATION;
}
","    if (mIsSecure && !audio) {
"
"bool SampleTable::isValid() const {

     return mChunkOffsetOffset >= 0
         && mSampleToChunkOffset >= 0
         && mSampleSizeOffset >= 0
        && !mTimeToSample.empty();
 }
","        && !mTimeToSample.empty();
"
" status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
         return ERROR_MALFORMED;
     }
 
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

    mTimeToSampleCount = U32_AT(&header[4]);
 if ((uint64_t)mTimeToSampleCount >
 (uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
        ALOGE(""  Error: Time-to-sample table size too large."");

 return ERROR_OUT_OF_RANGE;
 }

 if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
                                mTimeToSampleCount * 2)) {
        ALOGE(""  Error: Incomplete data read for time-to-sample table."");
 return ERROR_IO;
 }


     for (size_t i = 0; i < mTimeToSample.size(); ++i) {
         mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
     }
     return OK;
 }
","    if (!mTimeToSample.empty() || data_size < 8) {
"
"static ssize_t get_node_path_locked(struct node* node, char* buf, size_t bufsize) {
 const char* name;
 size_t namelen;
 if (node->graft_path) {
        name = node->graft_path;
        namelen = node->graft_pathlen;
 } else if (node->actual_name) {
        name = node->actual_name;
        namelen = node->namelen;
 } else {
        name = node->name;
        namelen = node->namelen;
 }

 if (bufsize < namelen + 1) {
 return -1;
 }

 
     ssize_t pathlen = 0;
     if (node->parent && node->graft_path == NULL) {
        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
         if (pathlen < 0) {
             return -1;
         }
        buf[pathlen++] = '/';
 }

    memcpy(buf + pathlen, name, namelen + 1); /* include trailing \0 */
 return pathlen + namelen;
}
","        pathlen = get_node_path_locked(node->parent, buf, bufsize - namelen - 2);
"
"OMX_ERRORTYPE  omx_venc::component_deinit(OMX_IN OMX_HANDLETYPE hComp)
{
 (void) hComp;
    OMX_U32 i = 0;
    DEBUG_PRINT_HIGH(""omx_venc(): Inside component_deinit()"");
 if (OMX_StateLoaded != m_state) {
        DEBUG_PRINT_ERROR(""WARNING:Rxd DeInit,OMX not in LOADED state %d"",\
                m_state);
 }

     if (m_out_mem_ptr) {
         DEBUG_PRINT_LOW(""Freeing the Output Memory"");
         for (i=0; i< m_sOutPortDef.nBufferCountActual; i++ ) {
            free_output_buffer (&m_out_mem_ptr[i]);
         }
         free(m_out_mem_ptr);
         m_out_mem_ptr = NULL;
 }

 /*Check if the input buffers have to be cleaned up*/
 if (m_inp_mem_ptr
#ifdef _ANDROID_ICS_
 && !meta_mode_enable
#endif

        ) {
         DEBUG_PRINT_LOW(""Freeing the Input Memory"");
         for (i=0; i<m_sInPortDef.nBufferCountActual; i++ ) {
            free_input_buffer (&m_inp_mem_ptr[i]);
         }
 
 
        free(m_inp_mem_ptr);
        m_inp_mem_ptr = NULL;
 }

    m_ftb_q.m_size=0;
    m_cmd_q.m_size=0;
    m_etb_q.m_size=0;
    m_ftb_q.m_read = m_ftb_q.m_write =0;
    m_cmd_q.m_read = m_cmd_q.m_write =0;
    m_etb_q.m_read = m_etb_q.m_write =0;

#ifdef _ANDROID_
    DEBUG_PRINT_HIGH(""Calling m_heap_ptr.clear()"");
    m_heap_ptr.clear();
#endif // _ANDROID_
    DEBUG_PRINT_HIGH(""Calling venc_close()"");
 if (handle) {
        handle->venc_close();
        DEBUG_PRINT_HIGH(""Deleting HANDLE[%p]"", handle);
 delete (handle);
        handle = NULL;
 }
    DEBUG_PRINT_INFO(""Component Deinit"");
 return OMX_ErrorNone;
}
","            free_output_buffer (&m_out_mem_ptr[i]);
            free_input_buffer (&m_inp_mem_ptr[i]);
"
"bool omx_vdec::release_output_done(void)
{

     bool bRet = false;
     unsigned i=0,j=0;
 
    DEBUG_PRINT_LOW(""Value of m_out_mem_ptr %p"",m_inp_mem_ptr);
     if (m_out_mem_ptr) {
         for (; j < drv_ctx.op_buf.actualcount ; j++) {
             if (BITMASK_PRESENT(&m_out_bm_count,j)) {
 break;
 }
 }
 if (j == drv_ctx.op_buf.actualcount) {
            m_out_bm_count = 0;
            bRet = true;
 }
 } else {
        m_out_bm_count = 0;
        bRet = true;
 }
 return bRet;
}
","    DEBUG_PRINT_LOW(""Value of m_out_mem_ptr %p"",m_inp_mem_ptr);
"
"void Segment::AppendCluster(Cluster* pCluster) {
  assert(pCluster);
  assert(pCluster->m_index >= 0);
 
   const long count = m_clusterCount + m_clusterPreloadCount;
 
   long& size = m_clusterSize;
  assert(size >= count);
   const long idx = pCluster->m_index;
  assert(idx == m_clusterCount);
 
   if (count >= size) {
     const long n = (size <= 0) ? 2048 : 2 * size;
 
    Cluster** const qq = new Cluster* [n];
    Cluster** q = qq;
 
     Cluster** p = m_clusters;
     Cluster** const pp = p + count;
 
 while (p != pp)
 *q++ = *p++;

 delete[] m_clusters;

    m_clusters = qq;
    size = n;

   }
 
   if (m_clusterPreloadCount > 0) {
    assert(m_clusters);
     Cluster** const p = m_clusters + m_clusterCount;
    assert(*p);
    assert((*p)->m_index < 0);
 
     Cluster** q = p + m_clusterPreloadCount;
    assert(q < (m_clusters + size));
 
     for (;;) {
       Cluster** const qq = q - 1;
      assert((*qq)->m_index < 0);
 
       *q = *qq;
       q = qq;

 if (q == p)
 break;
 }
 }

 
   m_clusters[idx] = pCluster;
   ++m_clusterCount;
 }
","  assert(pCluster);
  assert(pCluster->m_index >= 0);
  assert(size >= count);
  assert(idx == m_clusterCount);
    Cluster** const qq = new Cluster* [n];
    Cluster** q = qq;
    assert(m_clusters);
    assert(*p);
    assert((*p)->m_index < 0);
    assert(q < (m_clusters + size));
      assert((*qq)->m_index < 0);
"
"int Track::Info::Copy(Info& dst) const {
 if (&dst == this)
 return 0;

  dst.type = type;
  dst.number = number;
  dst.defaultDuration = defaultDuration;
  dst.codecDelay = codecDelay;
  dst.seekPreRoll = seekPreRoll;
  dst.uid = uid;
  dst.lacing = lacing;
  dst.settings = settings;


 if (int status = CopyStr(&Info::nameAsUTF8, dst))
 return status;

 if (int status = CopyStr(&Info::language, dst))
 return status;

 if (int status = CopyStr(&Info::codecId, dst))
 return status;

 if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
 return status;

 if (codecPrivateSize > 0) {
 if (codecPrivate == NULL)
 return -1;

 if (dst.codecPrivate)
 return -1;


     if (dst.codecPrivateSize != 0)
       return -1;
 
    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
 
     if (dst.codecPrivate == NULL)
       return -1;

    memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
    dst.codecPrivateSize = codecPrivateSize;
 }

 return 0;
}
","    dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
"
"int Track::Info::CopyStr(char* Info::*str, Info& dst_) const {
 if (str == static_cast<char * Info::*>(NULL))
 return -1;

 char*& dst = dst_.*str;

 if (dst) // should be NULL already
 return -1;

 const char* const src = this->*str;

 if (src == NULL)
 return 0;

 
   const size_t len = strlen(src);
 
  dst = new (std::nothrow) char[len + 1];
 
   if (dst == NULL)
     return -1;

  strcpy(dst, src);

 return 0;
}
","  dst = new (std::nothrow) char[len + 1];
"
"Cluster* Cluster::Create(Segment* pSegment, long idx, long long off)
{
  assert(pSegment);
  assert(off >= 0);
 
   const long long element_start = pSegment->m_start + off;
 
  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);
  assert(pCluster);
 
   return pCluster;
 }
","{
  assert(pSegment);
  assert(off >= 0);
  Cluster* const pCluster = new Cluster(pSegment, idx, element_start);
  assert(pCluster);
"
"long Cluster::CreateBlock(long long id,
 long long pos, // absolute pos of payload
 long long size, long long discard_padding) {
  assert((id == 0x20) || (id == 0x23)); // BlockGroup or SimpleBlock

 if (m_entries_count < 0) { // haven't parsed anything yet
    assert(m_entries == NULL);

     assert(m_entries_size == 0);
 
     m_entries_size = 1024;
    m_entries = new BlockEntry* [m_entries_size];
 
     m_entries_count = 0;
   } else {
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count <= m_entries_size);


     if (m_entries_count >= m_entries_size) {
       const long entries_size = 2 * m_entries_size;
 
      BlockEntry** const entries = new BlockEntry* [entries_size];
      assert(entries);
 
       BlockEntry** src = m_entries;
       BlockEntry** const src_end = src + m_entries_count;

 BlockEntry** dst = entries;

 while (src != src_end)
 *dst++ = *src++;

 delete[] m_entries;

      m_entries = entries;
      m_entries_size = entries_size;
 }
 }

 if (id == 0x20) // BlockGroup ID
 return CreateBlockGroup(pos, size, discard_padding);
 else // SimpleBlock ID
 return CreateSimpleBlock(pos, size);
}
","    m_entries = new BlockEntry* [m_entries_size];
      BlockEntry** const entries = new BlockEntry* [entries_size];
      assert(entries);
"
"const Cluster* Segment::FindOrPreloadCluster(long long requested_pos) {
 if (requested_pos < 0)
 return 0;

 Cluster** const ii = m_clusters;
 Cluster** i = ii;

 const long count = m_clusterCount + m_clusterPreloadCount;

 Cluster** const jj = ii + count;
 Cluster** j = jj;

 while (i < j) {

 Cluster** const k = i + (j - i) / 2;
    assert(k < jj);

 Cluster* const pCluster = *k;
    assert(pCluster);


 const long long pos = pCluster->GetPosition();
    assert(pos >= 0);

 if (pos < requested_pos)
      i = k + 1;
 else if (pos > requested_pos)
      j = k;
 else
 return pCluster;
 }

  assert(i == j);

 
   Cluster* const pCluster = Cluster::Create(this, -1, requested_pos);
  assert(pCluster);
 
   const ptrdiff_t idx = i - m_clusters;
 
  PreloadCluster(pCluster, idx);
   assert(m_clusters);
   assert(m_clusterPreloadCount > 0);
   assert(m_clusters[idx] == pCluster);

 return pCluster;
}
","  assert(pCluster);
  PreloadCluster(pCluster, idx);
"
" const BlockEntry* Cues::GetBlock(const CuePoint* pCP,
                                  const CuePoint::TrackPosition* pTP) const {
  if (pCP == NULL)
    return NULL;
  if (pTP == NULL)
     return NULL;
 
   return m_pSegment->GetBlock(*pCP, *pTP);
}
","  if (pCP == NULL)
    return NULL;
  if (pTP == NULL)
"
"const BlockEntry* Segment::GetBlock(const CuePoint& cp,
 const CuePoint::TrackPosition& tp) {
 Cluster** const ii = m_clusters;
 Cluster** i = ii;

 const long count = m_clusterCount + m_clusterPreloadCount;

 Cluster** const jj = ii + count;
 Cluster** j = jj;

 while (i < j) {

 Cluster** const k = i + (j - i) / 2;
    assert(k < jj);

 Cluster* const pCluster = *k;
    assert(pCluster);


 const long long pos = pCluster->GetPosition();
    assert(pos >= 0);

 if (pos < tp.m_pos)
      i = k + 1;
 else if (pos > tp.m_pos)
      j = k;
 else
 return pCluster->GetEntry(cp, tp);
 }

  assert(i == j);

 
   Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos);  //, -1);
  assert(pCluster);
 
   const ptrdiff_t idx = i - m_clusters;
 
  PreloadCluster(pCluster, idx);
   assert(m_clusters);
   assert(m_clusterPreloadCount > 0);
   assert(m_clusters[idx] == pCluster);

 return pCluster->GetEntry(cp, tp);
}
","  assert(pCluster);
  PreloadCluster(pCluster, idx);
"
" const CuePoint* Cues::GetFirst() const {
  if (m_cue_points == NULL)
     return NULL;
 
  if (m_count == 0)
    return NULL;
#if 0
    LoadCuePoint();  //init cues
    const size_t count = m_count + m_preload_count;
    if (count == 0)  //weird
        return NULL;
#endif
   CuePoint* const* const pp = m_cue_points;
  assert(pp);
 
   CuePoint* const pCP = pp[0];
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
 
   return pCP;
 }
","  if (m_cue_points == NULL)
  if (m_count == 0)
    return NULL;
#if 0
    LoadCuePoint();  //init cues
    const size_t count = m_count + m_preload_count;
    if (count == 0)  //weird
        return NULL;
#endif
  assert(pp);
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
"
"long Track::GetFirst(const BlockEntry*& pBlockEntry) const {
 const Cluster* pCluster = m_pSegment->GetFirst();

 for (int i = 0;;) {
 if (pCluster == NULL) {
      pBlockEntry = GetEOS();
 return 1;

     }
 
     if (pCluster->EOS()) {
#if 0
            if (m_pSegment->Unparsed() <= 0) {  //all clusters have been loaded
                pBlockEntry = GetEOS();
                return 1;
            }
#else
       if (m_pSegment->DoneParsing()) {
         pBlockEntry = GetEOS();
         return 1;
       }
#endif
 
       pBlockEntry = 0;
       return E_BUFFER_NOT_FULL;
 }

 long status = pCluster->GetFirst(pBlockEntry);

 if (status < 0) // error
 return status;

 if (pBlockEntry == 0) { // empty cluster
      pCluster = m_pSegment->GetNext(pCluster);
 continue;
 }

 for (;;) {
 const Block* const pBlock = pBlockEntry->GetBlock();
      assert(pBlock);

 const long long tn = pBlock->GetTrackNumber();

 if ((tn == m_info.number) && VetEntry(pBlockEntry))
 return 0;

 const BlockEntry* pNextEntry;

      status = pCluster->GetNext(pBlockEntry, pNextEntry);

 if (status < 0) // error
 return status;

 if (pNextEntry == 0)
 break;

      pBlockEntry = pNextEntry;
 }

 ++i;

 if (i >= 100)
 break;

    pCluster = m_pSegment->GetNext(pCluster);
 }


  pBlockEntry = GetEOS(); // so we can return a non-NULL value
 return 1;
}
","#if 0
            if (m_pSegment->Unparsed() <= 0) {  //all clusters have been loaded
                pBlockEntry = GetEOS();
                return 1;
            }
#else
#endif
"
" const CuePoint* Cues::GetLast() const {
  if (m_cue_points == NULL)
     return NULL;
 
  if (m_count <= 0)
    return NULL;
#if 0
    LoadCuePoint();  //init cues
    const size_t count = m_count + m_preload_count;
    if (count == 0)  //weird
        return NULL;
    const size_t index = count - 1;
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    CuePoint* const pCP = pp[index];
    assert(pCP);
    pCP->Load(m_pSegment->m_pReader);
    assert(pCP->GetTimeCode() >= 0);
#else
   const long index = m_count - 1;
 
   CuePoint* const* const pp = m_cue_points;
  assert(pp);
 
   CuePoint* const pCP = pp[index];
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
#endif
 
   return pCP;
 }
","  if (m_cue_points == NULL)
  if (m_count <= 0)
    return NULL;
#if 0
    LoadCuePoint();  //init cues
    const size_t count = m_count + m_preload_count;
    if (count == 0)  //weird
        return NULL;
    const size_t index = count - 1;
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    CuePoint* const pCP = pp[index];
    assert(pCP);
    pCP->Load(m_pSegment->m_pReader);
    assert(pCP->GetTimeCode() >= 0);
#else
  assert(pp);
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
#endif
"
" const CuePoint* Cues::GetNext(const CuePoint* pCurr) const {
  if (pCurr == NULL)
     return NULL;
 
  assert(pCurr->GetTimeCode() >= 0);
  assert(m_cue_points);
  assert(m_count >= 1);
#if 0
    const size_t count = m_count + m_preload_count;
    size_t index = pCurr->m_index;
    assert(index < count);
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    assert(pp[index] == pCurr);
    ++index;
    if (index >= count)
        return NULL;
    CuePoint* const pNext = pp[index];
    assert(pNext);
    pNext->Load(m_pSegment->m_pReader);
#else
  long index = pCurr->m_index;
  assert(index < m_count);
   CuePoint* const* const pp = m_cue_points;
  assert(pp);
  assert(pp[index] == pCurr);
 
   ++index;
 
 if (index >= m_count)

     return NULL;
 
   CuePoint* const pNext = pp[index];
  assert(pNext);
  assert(pNext->GetTimeCode() >= 0);
#endif
 
   return pNext;
 }
","  if (pCurr == NULL)
  assert(pCurr->GetTimeCode() >= 0);
  assert(m_cue_points);
  assert(m_count >= 1);
#if 0
    const size_t count = m_count + m_preload_count;
    size_t index = pCurr->m_index;
    assert(index < count);
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    assert(pp[index] == pCurr);
    ++index;
    if (index >= count)
        return NULL;
    CuePoint* const pNext = pp[index];
    assert(pNext);
    pNext->Load(m_pSegment->m_pReader);
#else
  long index = pCurr->m_index;
  assert(index < m_count);
  assert(pp);
  assert(pp[index] == pCurr);
  assert(pNext);
  assert(pNext->GetTimeCode() >= 0);
#endif
"
"long Track::GetNext(const BlockEntry* pCurrEntry,
 const BlockEntry*& pNextEntry) const {
  assert(pCurrEntry);
  assert(!pCurrEntry->EOS()); //?

 const Block* const pCurrBlock = pCurrEntry->GetBlock();
  assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
 if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
 return -1;

 const Cluster* pCluster = pCurrEntry->GetCluster();
  assert(pCluster);
  assert(!pCluster->EOS());

 long status = pCluster->GetNext(pCurrEntry, pNextEntry);

 if (status < 0) // error
 return status;

 for (int i = 0;;) {
 while (pNextEntry) {
 const Block* const pNextBlock = pNextEntry->GetBlock();
      assert(pNextBlock);

 if (pNextBlock->GetTrackNumber() == m_info.number)
 return 0;

      pCurrEntry = pNextEntry;

      status = pCluster->GetNext(pCurrEntry, pNextEntry);

 if (status < 0) // error
 return status;
 }

    pCluster = m_pSegment->GetNext(pCluster);

 if (pCluster == NULL) {
      pNextEntry = GetEOS();
 return 1;

     }
 
     if (pCluster->EOS()) {
#if 0
            if (m_pSegment->Unparsed() <= 0)   //all clusters have been loaded
            {
                pNextEntry = GetEOS();
                return 1;
            }
#else
       if (m_pSegment->DoneParsing()) {
         pNextEntry = GetEOS();
         return 1;
       }
#endif
 

      pNextEntry = NULL;
 return E_BUFFER_NOT_FULL;
 }

    status = pCluster->GetFirst(pNextEntry);

 if (status < 0) // error
 return status;

 if (pNextEntry == NULL) // empty cluster
 continue;

 ++i;

 if (i >= 100)
 break;
 }


  pNextEntry = GetEOS(); // so we can return a non-NULL value
 return 1;
}
","#if 0
            if (m_pSegment->Unparsed() <= 0)   //all clusters have been loaded
            {
                pNextEntry = GetEOS();
                return 1;
            }
#else
#endif
"
"long long mkvparser::GetUIntLength(IMkvReader* pReader, long long pos,
                                   long& len) {
  assert(pReader);
  assert(pos >= 0);
 
   long long total, available;
 
   int status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
 
   len = 1;
 
 if (pos >= available)
 return pos; // too few bytes available

 unsigned char b;

 
   status = pReader->Read(pos, 1, &b);
 
  if (status < 0)
     return status;
 
  assert(status == 0);
   if (b == 0)  // we can't handle u-int values larger than 8 bytes
     return E_FILE_FORMAT_INVALID;
 
 unsigned char m = 0x80;

 while (!(b & m)) {
    m >>= 1;
 ++len;
 }

 return 0; // success
}
","                                   long& len) {
  assert(pReader);
  assert(pos >= 0);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
  if (status < 0)
  assert(status == 0);
"
"void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision) {
   major = 1;
   minor = 0;
   build = 0;
  revision = 28;
 }
","  revision = 28;
"
"void Cues::Init() const {
   if (m_cue_points)
    return;
 
  assert(m_count == 0);
  assert(m_preload_count == 0);
 
   IMkvReader* const pReader = m_pSegment->m_pReader;
 
 const long long stop = m_start + m_size;
 long long pos = m_start;

 long cue_points_size = 0;

 while (pos < stop) {
 const long long idpos = pos;

 
     long len;
 
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);  // TODO
    assert((pos + len) <= stop);
 
     pos += len;  // consume ID
 
     const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);
 
     pos += len;  // consume Size field
    assert((pos + size) <= stop);
 
    if (id == 0x3B)  // CuePoint ID
      PreloadCuePoint(cue_points_size, idpos);
 
    pos += size;  // consume payload
    assert(pos <= stop);
   }
 }
","    return;
  assert(m_count == 0);
  assert(m_preload_count == 0);
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);  // TODO
    assert((pos + len) <= stop);
    assert(size >= 0);
    assert((pos + len) <= stop);
    assert((pos + size) <= stop);
    if (id == 0x3B)  // CuePoint ID
      PreloadCuePoint(cue_points_size, idpos);
    pos += size;  // consume payload
    assert(pos <= stop);
"
" long Segment::Load() {
  assert(m_clusters == NULL);
  assert(m_clusterSize == 0);
  assert(m_clusterCount == 0);


 const long long header_status = ParseHeaders();

 if (header_status < 0) // error
 return static_cast<long>(header_status);


   if (header_status > 0)  // underflow
     return E_BUFFER_NOT_FULL;
 
  assert(m_pInfo);
  assert(m_pTracks);
 
   for (;;) {
     const int status = LoadCluster();

 if (status < 0) // error
 return status;

 if (status >= 1) // no more clusters
 return 0;
 }
}
","  assert(m_pInfo);
  assert(m_pTracks);
"
" bool Cues::LoadCuePoint() const {
   const long long stop = m_start + m_size;
 
   if (m_pos >= stop)
     return false;  // nothing else to do
 
  Init();
 
   IMkvReader* const pReader = m_pSegment->m_pReader;
 
 while (m_pos < stop) {
 const long long idpos = m_pos;

 
     long len;
 
    const long long id = ReadUInt(pReader, m_pos, len);
    assert(id >= 0);  // TODO
    assert((m_pos + len) <= stop);
 
     m_pos += len;  // consume ID
 
     const long long size = ReadUInt(pReader, m_pos, len);
    assert(size >= 0);
    assert((m_pos + len) <= stop);
 
     m_pos += len;  // consume Size field
    assert((m_pos + size) <= stop);
 
     if (id != 0x3B) {  // CuePoint ID
       m_pos += size;  // consume payload
      assert(m_pos <= stop);
 
       continue;
     }
 
    assert(m_preload_count > 0);
    CuePoint* const pCP = m_cue_points[m_count];
    assert(pCP);
    assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
    if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
       return false;
 
    pCP->Load(pReader);
     ++m_count;
     --m_preload_count;
 
     m_pos += size;  // consume payload
    assert(m_pos <= stop);
 
     return true;  // yes, we loaded a cue point
   }
 
 }
","  Init();
    const long long id = ReadUInt(pReader, m_pos, len);
    assert(id >= 0);  // TODO
    assert((m_pos + len) <= stop);
    assert(size >= 0);
    assert((m_pos + len) <= stop);
    assert((m_pos + size) <= stop);
      assert(m_pos <= stop);
    assert(m_preload_count > 0);
    CuePoint* const pCP = m_cue_points[m_count];
    assert(pCP);
    assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
    if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
    pCP->Load(pReader);
    assert(m_pos <= stop);
"
"bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,
                      long long& val) {
  assert(pReader);
  assert(pos >= 0);
  long long total, available;
  const long status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
  if (status < 0)
     return false;
 
  long len;
 
  const long long id = ReadUInt(pReader, pos, len);
  assert(id >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
  if ((unsigned long)id != id_)
     return false;
 
   pos += len;  // consume id
 
   const long long size = ReadUInt(pReader, pos, len);
  assert(size >= 0);
  assert(size <= 8);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
   pos += len;  // consume length of size of payload
 
   val = UnserializeUInt(pReader, pos, size);
  assert(val >= 0);
 
   pos += size;  // consume size of payload
 
   return true;
 }
","                      long long& val) {
  assert(pReader);
  assert(pos >= 0);
  long long total, available;
  const long status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
  if (status < 0)
  long len;
  const long long id = ReadUInt(pReader, pos, len);
  assert(id >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
  if ((unsigned long)id != id_)
  assert(size >= 0);
  assert(size <= 8);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
  assert(val >= 0);
"
"bool mkvparser::Match(IMkvReader* pReader, long long& pos, unsigned long id_,
                      unsigned char*& buf, size_t& buflen) {
  assert(pReader);
  assert(pos >= 0);
  long long total, available;
  long status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
  if (status < 0)
     return false;
 
  long len;
  const long long id = ReadUInt(pReader, pos, len);
  assert(id >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
  if ((unsigned long)id != id_)
     return false;
 
   pos += len;  // consume id
 
  const long long size_ = ReadUInt(pReader, pos, len);
  assert(size_ >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
 
   pos += len;  // consume length of size of payload
  assert((pos + size_) <= available);
 
  const long buflen_ = static_cast<long>(size_);
 
  buf = new (std::nothrow) unsigned char[buflen_];
  assert(buf);  // TODO
 
   status = pReader->Read(pos, buflen_, buf);
  assert(status == 0);  // TODO
 
   buflen = buflen_;
 
  pos += size_;  // consume size of payload
   return true;
 }
","                      unsigned char*& buf, size_t& buflen) {
  assert(pReader);
  assert(pos >= 0);
  long long total, available;
  long status = pReader->Length(&total, &available);
  assert(status >= 0);
  assert((total < 0) || (available <= total));
  if (status < 0)
  long len;
  const long long id = ReadUInt(pReader, pos, len);
  assert(id >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
  if ((unsigned long)id != id_)
  const long long size_ = ReadUInt(pReader, pos, len);
  assert(size_ >= 0);
  assert(len > 0);
  assert(len <= 8);
  assert((pos + len) <= available);
  assert((pos + size_) <= available);
  const long buflen_ = static_cast<long>(size_);
  buf = new (std::nothrow) unsigned char[buflen_];
  assert(buf);  // TODO
  assert(status == 0);  // TODO
  pos += size_;  // consume size of payload
"
"void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,
                                     long long size_) {
   const long long stop = start_ + size_;
   long long pos = start_;

  m_track = -1;
  m_pos = -1;
  m_block = 1; // default


   while (pos < stop) {
     long len;
 
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);  // TODO
    assert((pos + len) <= stop);
 
     pos += len;  // consume ID
 
     const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);
 
     pos += len;  // consume Size field
    assert((pos + size) <= stop);
 
     if (id == 0x77)  // CueTrack ID
       m_track = UnserializeUInt(pReader, pos, size);

 else if (id == 0x71) // CueClusterPos ID
      m_pos = UnserializeUInt(pReader, pos, size);

 else if (id == 0x1378) // CueBlockNumber

       m_block = UnserializeUInt(pReader, pos, size);
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
  assert(m_pos >= 0);
  assert(m_track > 0);
 }
","    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);  // TODO
    assert((pos + len) <= stop);
    assert(size >= 0);
    assert((pos + len) <= stop);
    assert((pos + size) <= stop);
    assert(pos <= stop);
  assert(m_pos >= 0);
  assert(m_track > 0);
"
" long Chapters::Parse() {
 IMkvReader* const pReader = m_pSegment->m_pReader;

 long long pos = m_start; // payload start
 const long long stop = pos + m_size; // payload stop

 while (pos < stop) {
 long long id, size;

 long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (size == 0) // weird
 continue;

 if (id == 0x05B9) { // EditionEntry ID
      status = ParseEdition(pos, size);

 if (status < 0) // error
 return status;

     }
 
     pos += size;
    assert(pos <= stop);
   }
 
  assert(pos == stop);
   return 0;
 }
","    assert(pos <= stop);
  assert(pos == stop);
"
"long Chapters::Edition::Parse(IMkvReader* pReader, long long pos,
 long long size) {
 const long long stop = pos + size;

 while (pos < stop) {
 long long id, size;

 long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (size == 0) // weird
 continue;

 if (id == 0x36) { // Atom ID
      status = ParseAtom(pReader, pos, size);

 if (status < 0) // error
 return status;

     }
 
     pos += size;
    assert(pos <= stop);
   }
 
  assert(pos == stop);
   return 0;
 }
","    assert(pos <= stop);
  assert(pos == stop);
"
"long Chapters::Atom::Parse(IMkvReader* pReader, long long pos, long long size) {
 const long long stop = pos + size;

 while (pos < stop) {
 long long id, size;

 long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (size == 0) // weird
 continue;

 if (id == 0x00) { // Display ID
      status = ParseDisplay(pReader, pos, size);

 if (status < 0) // error
 return status;
 } else if (id == 0x1654) { // StringUID ID
      status = UnserializeString(pReader, pos, size, m_string_uid);

 if (status < 0) // error
 return status;
 } else if (id == 0x33C4) { // UID ID
 long long val;
      status = UnserializeInt(pReader, pos, size, val);

 if (status < 0) // error
 return status;

      m_uid = static_cast<unsigned long long>(val);
 } else if (id == 0x11) { // TimeStart ID
 const long long val = UnserializeUInt(pReader, pos, size);

 if (val < 0) // error
 return static_cast<long>(val);

      m_start_timecode = val;
 } else if (id == 0x12) { // TimeEnd ID
 const long long val = UnserializeUInt(pReader, pos, size);

 if (val < 0) // error
 return static_cast<long>(val);

      m_stop_timecode = val;

     }
 
     pos += size;
    assert(pos <= stop);
   }
 
  assert(pos == stop);
   return 0;
 }
","    assert(pos <= stop);
  assert(pos == stop);
"
"long Chapters::Display::Parse(IMkvReader* pReader, long long pos,
 long long size) {
 const long long stop = pos + size;

 while (pos < stop) {
 long long id, size;

 long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (size == 0) // weird
 continue;

 if (id == 0x05) { // ChapterString ID
      status = UnserializeString(pReader, pos, size, m_string);

 if (status)
 return status;
 } else if (id == 0x037C) { // ChapterLanguage ID
      status = UnserializeString(pReader, pos, size, m_language);

 if (status)
 return status;
 } else if (id == 0x037E) { // ChapterCountry ID
      status = UnserializeString(pReader, pos, size, m_country);

 if (status)
 return status;

     }
 
     pos += size;
    assert(pos <= stop);
   }
 
  assert(pos == stop);
   return 0;
 }
","    assert(pos <= stop);
  assert(pos == stop);
"
"long SegmentInfo::Parse() {
  assert(m_pMuxingAppAsUTF8 == NULL);
  assert(m_pWritingAppAsUTF8 == NULL);
  assert(m_pTitleAsUTF8 == NULL);

 IMkvReader* const pReader = m_pSegment->m_pReader;

 long long pos = m_start;
 const long long stop = m_start + m_size;

  m_timecodeScale = 1000000;
  m_duration = -1;

 while (pos < stop) {
 long long id, size;

 const long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (id == 0x0AD7B1) { // Timecode Scale
      m_timecodeScale = UnserializeUInt(pReader, pos, size);

 if (m_timecodeScale <= 0)
 return E_FILE_FORMAT_INVALID;
 } else if (id == 0x0489) { // Segment duration
 const long status = UnserializeFloat(pReader, pos, size, m_duration);

 if (status < 0)
 return status;

 if (m_duration < 0)
 return E_FILE_FORMAT_INVALID;
 } else if (id == 0x0D80) { // MuxingApp
 const long status =
 UnserializeString(pReader, pos, size, m_pMuxingAppAsUTF8);

 if (status)
 return status;
 } else if (id == 0x1741) { // WritingApp
 const long status =
 UnserializeString(pReader, pos, size, m_pWritingAppAsUTF8);

 if (status)
 return status;
 } else if (id == 0x3BA9) { // Title
 const long status = UnserializeString(pReader, pos, size, m_pTitleAsUTF8);

 if (status)
 return status;

     }
 
     pos += size;
    assert(pos <= stop);
   }
 
  assert(pos == stop);
 
   return 0;
 }
","    assert(pos <= stop);
  assert(pos == stop);
"
"long VideoTrack::Parse(Segment* pSegment, const Info& info,
 long long element_start, long long element_size,
 VideoTrack*& pResult) {
 if (pResult)
 return -1;

 if (info.type != Track::kVideo)
 return -1;

 
   long long width = 0;
   long long height = 0;
   double rate = 0.0;
 
   IMkvReader* const pReader = pSegment->m_pReader;

 const Settings& s = info.settings;
  assert(s.start >= 0);
  assert(s.size >= 0);

 long long pos = s.start;
  assert(pos >= 0);

 const long long stop = pos + s.size;

 while (pos < stop) {
 long long id, size;

 const long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (id == 0x30) { // pixel width
      width = UnserializeUInt(pReader, pos, size);

 if (width <= 0)
 return E_FILE_FORMAT_INVALID;
 } else if (id == 0x3A) { // pixel height
      height = UnserializeUInt(pReader, pos, size);

 
       if (height <= 0)
         return E_FILE_FORMAT_INVALID;
     } else if (id == 0x0383E3) {  // frame rate
       const long status = UnserializeFloat(pReader, pos, size, rate);
 
 if (status < 0)
 return status;

 if (rate <= 0)
 return E_FILE_FORMAT_INVALID;

     }
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
  assert(pos == stop);
 
   VideoTrack* const pTrack =
       new (std::nothrow) VideoTrack(pSegment, element_start, element_size);

 if (pTrack == NULL)
 return -1; // generic error

 const int status = info.Copy(pTrack->m_info);

 if (status) { // error
 delete pTrack;
 return status;
 }

 
   pTrack->m_width = width;
   pTrack->m_height = height;
   pTrack->m_rate = rate;
 
   pResult = pTrack;
 return 0; // success
}
","    assert(pos <= stop);
  assert(pos == stop);
"
"long AudioTrack::Parse(Segment* pSegment, const Info& info,
 long long element_start, long long element_size,
 AudioTrack*& pResult) {
 if (pResult)
 return -1;

 if (info.type != Track::kAudio)
 return -1;

 IMkvReader* const pReader = pSegment->m_pReader;

 const Settings& s = info.settings;
  assert(s.start >= 0);
  assert(s.size >= 0);

 long long pos = s.start;
  assert(pos >= 0);

 const long long stop = pos + s.size;

 double rate = 8000.0; // MKV default
 long long channels = 1;
 long long bit_depth = 0;

 while (pos < stop) {
 long long id, size;

 long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (id == 0x35) { // Sample Rate
      status = UnserializeFloat(pReader, pos, size, rate);

 if (status < 0)
 return status;

 if (rate <= 0)
 return E_FILE_FORMAT_INVALID;
 } else if (id == 0x1F) { // Channel Count
      channels = UnserializeUInt(pReader, pos, size);

 if (channels <= 0)
 return E_FILE_FORMAT_INVALID;
 } else if (id == 0x2264) { // Bit Depth
      bit_depth = UnserializeUInt(pReader, pos, size);

 if (bit_depth <= 0)
 return E_FILE_FORMAT_INVALID;

     }
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
  assert(pos == stop);
 
   AudioTrack* const pTrack =
       new (std::nothrow) AudioTrack(pSegment, element_start, element_size);

 if (pTrack == NULL)
 return -1; // generic error

 const int status = info.Copy(pTrack->m_info);

 if (status) {
 delete pTrack;
 return status;
 }

  pTrack->m_rate = rate;
  pTrack->m_channels = channels;
  pTrack->m_bitDepth = bit_depth;

  pResult = pTrack;
 return 0; // success
}
","    assert(pos <= stop);
  assert(pos == stop);
"
"long Tracks::Parse() {
  assert(m_trackEntries == NULL);
  assert(m_trackEntriesEnd == NULL);

 const long long stop = m_start + m_size;
 IMkvReader* const pReader = m_pSegment->m_pReader;

 int count = 0;
 long long pos = m_start;

 while (pos < stop) {
 long long id, size;

 const long status = ParseElementHeader(pReader, pos, stop, id, size);

 if (status < 0) // error
 return status;

 if (size == 0) // weird
 continue;

 if (id == 0x2E) // TrackEntry ID

       ++count;
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
  assert(pos == stop);
 
   if (count <= 0)
     return 0;  // success
 
  m_trackEntries = new (std::nothrow) Track* [count];
 
   if (m_trackEntries == NULL)
     return -1;

  m_trackEntriesEnd = m_trackEntries;

  pos = m_start;

 while (pos < stop) {
 const long long element_start = pos;

 long long id, payload_size;

 const long status =
 ParseElementHeader(pReader, pos, stop, id, payload_size);

 if (status < 0) // error
 return status;

 if (payload_size == 0) // weird
 continue;

 const long long payload_stop = pos + payload_size;
    assert(payload_stop <= stop); // checked in ParseElement

 const long long element_size = payload_stop - element_start;

 if (id == 0x2E) { // TrackEntry ID
 Track*& pTrack = *m_trackEntriesEnd;
      pTrack = NULL;

 const long status = ParseTrackEntry(pos, payload_size, element_start,
                                          element_size, pTrack);

 if (status)
 return status;

 if (pTrack)
 ++m_trackEntriesEnd;

     }
 
     pos = payload_stop;
    assert(pos <= stop);
   }
 
  assert(pos == stop);
 
   return 0;  // success
 }
","    assert(pos <= stop);
  assert(pos == stop);
  m_trackEntries = new (std::nothrow) Track* [count];
    assert(pos <= stop);
  assert(pos == stop);
"
"long ContentEncoding::ParseCompressionEntry(long long start, long long size,
 IMkvReader* pReader,
 ContentCompression* compression) {
  assert(pReader);
  assert(compression);

 long long pos = start;
 const long long stop = start + size;

 bool valid = false;

 while (pos < stop) {
 long long id, size;
 const long status = ParseElementHeader(pReader, pos, stop, id, size);
 if (status < 0) // error
 return status;

 if (id == 0x254) {
 long long algo = UnserializeUInt(pReader, pos, size);
 if (algo < 0)
 return E_FILE_FORMAT_INVALID;
      compression->algo = algo;
      valid = true;
 } else if (id == 0x255) {
 if (size <= 0)

         return E_FILE_FORMAT_INVALID;
 
       const size_t buflen = static_cast<size_t>(size);
      typedef unsigned char* buf_t;
      const buf_t buf = new (std::nothrow) unsigned char[buflen];
       if (buf == NULL)
         return -1;
 
 const int read_status =
          pReader->Read(pos, static_cast<long>(buflen), buf);
 if (read_status) {
 delete[] buf;
 return status;
 }

      compression->settings = buf;
      compression->settings_len = buflen;

     }
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
 if (!valid)
 return E_FILE_FORMAT_INVALID;

 return 0;
}
","      typedef unsigned char* buf_t;
      const buf_t buf = new (std::nothrow) unsigned char[buflen];
    assert(pos <= stop);
"
"long ContentEncoding::ParseContentEncAESSettingsEntry(
 long long start, long long size, IMkvReader* pReader,
 ContentEncAESSettings* aes) {
  assert(pReader);
  assert(aes);

 long long pos = start;
 const long long stop = start + size;

 while (pos < stop) {
 long long id, size;
 const long status = ParseElementHeader(pReader, pos, stop, id, size);
 if (status < 0) // error
 return status;

 if (id == 0x7E8) {
      aes->cipher_mode = UnserializeUInt(pReader, pos, size);
 if (aes->cipher_mode != 1)
 return E_FILE_FORMAT_INVALID;

     }
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
   return 0;
}
","    assert(pos <= stop);
"
"long Track::ParseContentEncodingsEntry(long long start, long long size) {
 IMkvReader* const pReader = m_pSegment->m_pReader;
  assert(pReader);

 long long pos = start;
 const long long stop = start + size;

 int count = 0;
 while (pos < stop) {
 long long id, size;
 const long status = ParseElementHeader(pReader, pos, stop, id, size);
 if (status < 0) // error
 return status;

 if (id == 0x2240) // ContentEncoding ID

       ++count;
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
   if (count <= 0)
     return -1;
 
  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];
   if (!content_encoding_entries_)
     return -1;
 
  content_encoding_entries_end_ = content_encoding_entries_;

  pos = start;
 while (pos < stop) {
 long long id, size;
 long status = ParseElementHeader(pReader, pos, stop, id, size);
 if (status < 0) // error
 return status;

 if (id == 0x2240) { // ContentEncoding ID
 ContentEncoding* const content_encoding =
 new (std::nothrow) ContentEncoding();
 if (!content_encoding)
 return -1;

      status = content_encoding->ParseContentEncodingEntry(pos, size, pReader);
 if (status) {
 delete content_encoding;
 return status;
 }

 *content_encoding_entries_end_++ = content_encoding;

     }
 
     pos += size;  // consume payload
    assert(pos <= stop);
   }
 
  assert(pos == stop);
 
   return 0;
 }
","    assert(pos <= stop);
  content_encoding_entries_ = new (std::nothrow) ContentEncoding* [count];
    assert(pos <= stop);
  assert(pos == stop);
"
"long mkvparser::ParseElementHeader(IMkvReader* pReader, long long& pos,
                                   long long stop, long long& id,
                                   long long& size) {
  if ((stop >= 0) && (pos >= stop))
     return E_FILE_FORMAT_INVALID;
 
   long len;
 
  id = ReadUInt(pReader, pos, len);
 
   if (id < 0)
     return E_FILE_FORMAT_INVALID;
 
   pos += len;  // consume id
 
  if ((stop >= 0) && (pos >= stop))
     return E_FILE_FORMAT_INVALID;
 
   size = ReadUInt(pReader, pos, len);
 
  if (size < 0)
     return E_FILE_FORMAT_INVALID;
 
   pos += len;  // consume length of size
 
 
  if ((stop >= 0) && ((pos + size) > stop))
     return E_FILE_FORMAT_INVALID;
 
   return 0;  // success
 }
","                                   long long stop, long long& id,
                                   long long& size) {
  if ((stop >= 0) && (pos >= stop))
  id = ReadUInt(pReader, pos, len);
  if ((stop >= 0) && (pos >= stop))
  if (size < 0)
  if ((stop >= 0) && ((pos + size) > stop))
"
" bool SeekHead::ParseEntry(IMkvReader* pReader, long long start, long long size_,
                           Entry* pEntry) {
   if (size_ <= 0)
 return false;

 long long pos = start;
 const long long stop = start + size_;

 long len;

 
 
  const long long seekIdId = ReadUInt(pReader, pos, len);
 
   if (seekIdId != 0x13AB)  // SeekID ID
     return false;

 if ((pos + len) > stop)
 return false;

  pos += len; // consume SeekID id

 const long long seekIdSize = ReadUInt(pReader, pos, len);

 if (seekIdSize <= 0)
 return false;

 if ((pos + len) > stop)
 return false;

  pos += len; // consume size of field

 if ((pos + seekIdSize) > stop)
 return false;


  pEntry->id = ReadUInt(pReader, pos, len); // payload

 if (pEntry->id <= 0)
 return false;

 if (len != seekIdSize)
 return false;

  pos += seekIdSize; // consume SeekID payload

 const long long seekPosId = ReadUInt(pReader, pos, len);

 if (seekPosId != 0x13AC) // SeekPos ID
 return false;

 if ((pos + len) > stop)
 return false;

  pos += len; // consume id

 const long long seekPosSize = ReadUInt(pReader, pos, len);

 if (seekPosSize <= 0)
 return false;

 if ((pos + len) > stop)
 return false;

  pos += len; // consume size

 if ((pos + seekPosSize) > stop)
 return false;

  pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);

 if (pEntry->pos < 0)
 return false;

  pos += seekPosSize; // consume payload

 if (pos != stop)
 return false;

 
   return true;
 }
","  const long long seekIdId = ReadUInt(pReader, pos, len);
"
"void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx) {
   assert(pCluster);
   assert(pCluster->m_index < 0);
   assert(idx >= m_clusterCount);

 const long count = m_clusterCount + m_clusterPreloadCount;

 long& size = m_clusterSize;
  assert(size >= count);


   if (count >= size) {
     const long n = (size <= 0) ? 2048 : 2 * size;
 
    Cluster** const qq = new Cluster* [n];
     Cluster** q = qq;
 
     Cluster** p = m_clusters;
 Cluster** const pp = p + count;

 while (p != pp)
 *q++ = *p++;

 delete[] m_clusters;

    m_clusters = qq;
    size = n;
 }

  assert(m_clusters);

 Cluster** const p = m_clusters + idx;

 Cluster** q = m_clusters + count;
  assert(q >= p);
  assert(q < (m_clusters + size));

 while (q > p) {
 Cluster** const qq = q - 1;
    assert((*qq)->m_index < 0);

 *q = *qq;
    q = qq;
 }

 
   m_clusters[idx] = pCluster;
   ++m_clusterPreloadCount;
 }
","    Cluster** const qq = new Cluster* [n];
"
"void Cues::PreloadCuePoint(long& cue_points_size, long long pos) const {
  assert(m_count == 0);
 
   if (m_preload_count >= cue_points_size) {
     const long n = (cue_points_size <= 0) ? 2048 : 2 * cue_points_size;
 
    CuePoint** const qq = new CuePoint* [n];
     CuePoint** q = qq;  // beginning of target
 
     CuePoint** p = m_cue_points;  // beginning of source
 CuePoint** const pp = p + m_preload_count; // end of source

 while (p != pp)
 *q++ = *p++;

 delete[] m_cue_points;

    m_cue_points = qq;

     cue_points_size = n;
   }
 
  CuePoint* const pCP = new CuePoint(m_preload_count, pos);
   m_cue_points[m_preload_count++] = pCP;
 }
","  assert(m_count == 0);
    CuePoint** const qq = new CuePoint* [n];
  CuePoint* const pCP = new CuePoint(m_preload_count, pos);
"
"long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {
  assert(pReader);
  assert(pos >= 0);
  int status;
 
   len = 1;
   unsigned char b;
  status = pReader->Read(pos, 1, &b);
 
   if (status < 0)  // error or underflow
     return status;

 if (status > 0) // interpreted as ""underflow""
 return E_BUFFER_NOT_FULL;

 if (b == 0) // we can't handle u-int values larger than 8 bytes
 return E_FILE_FORMAT_INVALID;

 unsigned char m = 0x80;

 while (!(b & m)) {
    m >>= 1;

     ++len;
   }
 
   long long result = b & (~m);
   ++pos;
 
 for (int i = 1; i < len; ++i) {
    status = pReader->Read(pos, 1, &b);

 if (status < 0) {
      len = 1;
 return status;
 }

 if (status > 0) {
      len = 1;
 return E_BUFFER_NOT_FULL;
 }

    result <<= 8;
    result |= b;

 ++pos;
 }


   return result;
 }
","  assert(pReader);
  assert(pos >= 0);
  int status;
  status = pReader->Read(pos, 1, &b);
"
"long VideoTrack::Seek(long long time_ns, const BlockEntry*& pResult) const {
 const long status = GetFirst(pResult);

 if (status < 0) // buffer underflow, etc
 return status;

  assert(pResult);

 if (pResult->EOS())
 return 0;

 const Cluster* pCluster = pResult->GetCluster();
  assert(pCluster);
  assert(pCluster->GetIndex() >= 0);

 if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
 return 0;

 Cluster** const clusters = m_pSegment->m_clusters;
  assert(clusters);

 const long count = m_pSegment->GetCount(); // loaded only, not pre-loaded
  assert(count > 0);

 Cluster** const i = clusters + pCluster->GetIndex();
  assert(i);
  assert(*i == pCluster);
  assert(pCluster->GetTime() <= time_ns);

 Cluster** const j = clusters + count;

 Cluster** lo = i;
 Cluster** hi = j;

 while (lo < hi) {

 Cluster** const mid = lo + (hi - lo) / 2;
    assert(mid < hi);

    pCluster = *mid;
    assert(pCluster);
    assert(pCluster->GetIndex() >= 0);
    assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));

 const long long t = pCluster->GetTime();

 if (t <= time_ns)
      lo = mid + 1;
 else
      hi = mid;

    assert(lo <= hi);
 }

  assert(lo == hi);
  assert(lo > i);
  assert(lo <= j);

  pCluster = *--lo;
  assert(pCluster);
  assert(pCluster->GetTime() <= time_ns);

  pResult = pCluster->GetEntry(this, time_ns);

 if ((pResult != 0) && !pResult->EOS()) // found a keyframe
 return 0;

 while (lo != i) {
    pCluster = *--lo;

     assert(pCluster);
     assert(pCluster->GetTime() <= time_ns);
 
#if 0
        pResult = pCluster->GetMaxKey(this);
#else
     pResult = pCluster->GetEntry(this, time_ns);
#endif
 
     if ((pResult != 0) && !pResult->EOS())
       return 0;
 }


  pResult = GetEOS();
 return 0;
}
","#if 0
        pResult = pCluster->GetMaxKey(this);
#else
#endif
"
"long mkvparser::UnserializeFloat(IMkvReader* pReader, long long pos,
                                 long long size_, double& result) {
  assert(pReader);
  assert(pos >= 0);
  if ((size_ != 4) && (size_ != 8))
     return E_FILE_FORMAT_INVALID;
 
   const long size = static_cast<long>(size_);

 unsigned char buf[8];

 const int status = pReader->Read(pos, size, buf);

 if (status < 0) // error
 return status;

 if (size == 4) {
 union {
 float f;
 unsigned long ff;
 };

    ff = 0;

 for (int i = 0;;) {
      ff |= buf[i];

 if (++i >= 4)
 break;

      ff <<= 8;
 }

 
     result = f;
   } else {
    assert(size == 8);
     union {
       double d;
       unsigned long long dd;
 };

    dd = 0;

 for (int i = 0;;) {
      dd |= buf[i];

 if (++i >= 8)
 break;

      dd <<= 8;
 }


     result = d;
   }
 
   return 0;
 }
","                                 long long size_, double& result) {
  assert(pReader);
  assert(pos >= 0);
  if ((size_ != 4) && (size_ != 8))
    assert(size == 8);
"
"long mkvparser::UnserializeInt(IMkvReader* pReader, long long pos, long size,
                               long long& result) {
  assert(pReader);
  assert(pos >= 0);
  assert(size > 0);
  assert(size <= 8);
 
  {
    signed char b;
 
    const long status = pReader->Read(pos, 1, (unsigned char*)&b);
 
    if (status < 0)
      return status;
    result = b;
    ++pos;
  }
 
   for (long i = 1; i < size; ++i) {
     unsigned char b;

 const long status = pReader->Read(pos, 1, &b);

 if (status < 0)
 return status;

    result <<= 8;
    result |= b;


     ++pos;
   }
 
  return 0;  // success
 }
","                               long long& result) {
  assert(pReader);
  assert(pos >= 0);
  assert(size > 0);
  assert(size <= 8);
  {
    signed char b;
    const long status = pReader->Read(pos, 1, (unsigned char*)&b);
    if (status < 0)
      return status;
    result = b;
    ++pos;
  }
  return 0;  // success
"
"long mkvparser::UnserializeString(IMkvReader* pReader, long long pos,
                                  long long size_, char*& str) {
   delete[] str;
   str = NULL;
 
  if (size_ >= LONG_MAX)  // we need (size+1) chars
     return E_FILE_FORMAT_INVALID;
 
  const long size = static_cast<long>(size_);
 
  str = new (std::nothrow) char[size + 1];
   if (str == NULL)
    return -1;
 
   unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
 
 const long status = pReader->Read(pos, size, buf);

 if (status) {
 delete[] str;
    str = NULL;


     return status;
   }
 
  str[size] = '\0';
  return 0;  // success
 }
","                                  long long size_, char*& str) {
  if (size_ >= LONG_MAX)  // we need (size+1) chars
  const long size = static_cast<long>(size_);
  str = new (std::nothrow) char[size + 1];
    return -1;
  str[size] = '\0';
  return 0;  // success
"
"long long mkvparser::UnserializeUInt(IMkvReader* pReader, long long pos,
                                     long long size) {
  assert(pReader);
  assert(pos >= 0);
  if ((size <= 0) || (size > 8))
     return E_FILE_FORMAT_INVALID;
 
   long long result = 0;

 for (long long i = 0; i < size; ++i) {
 unsigned char b;

 const long status = pReader->Read(pos, 1, &b);

 if (status < 0)
 return status;

    result <<= 8;
    result |= b;

 ++pos;
 }


   return result;
 }
","                                     long long size) {
  assert(pReader);
  assert(pos >= 0);
  if ((size <= 0) || (size > 8))
"
"Segment::~Segment() {
 const long count = m_clusterCount + m_clusterPreloadCount;

 Cluster** i = m_clusters;
 Cluster** j = m_clusters + count;

 
   while (i != j) {
     Cluster* const p = *i++;
    assert(p);
     delete p;
   }
 
 delete[] m_clusters;

 delete m_pTracks;

   delete m_pInfo;
   delete m_pCues;
   delete m_pChapters;
   delete m_pSeekHead;
 }
","    assert(p);
"
"void* H264SwDecMalloc(u32 size)
 {
 
 #if defined(CHECK_MEMORY_USAGE)
     /* Note that if the decoder has to free and reallocate some of the buffers
      * the total value will be invalid */
     static u32 numBytes = 0;
    numBytes += size;
     DEBUG((""Allocated %d bytes, total %d\n"", size, numBytes));
 #endif
 
    return malloc(size);
 }
","    numBytes += size;
    return malloc(size);
"
"void* H264SwDecMalloc(u32 size)
 {
    return malloc(size);
 }
","    return malloc(size);
"
"H264SwDecRet H264SwDecInit(H264SwDecInst *decInst, u32 noOutputReordering)
{
    u32 rv = 0;

 decContainer_t *pDecCont;

    DEC_API_TRC(""H264SwDecInit#"");

 /* check that right shift on negative numbers is performed signed */
 /*lint -save -e* following check causes multiple lint messages */
 if ( ((-1)>>1) != (-1) )
 {
        DEC_API_TRC(""H264SwDecInit# ERROR: Right shift is not signed"");
 return(H264SWDEC_INITFAIL);
 }
 /*lint -restore */

 if (decInst == NULL)
 {
        DEC_API_TRC(""H264SwDecInit# ERROR: decInst == NULL"");

         return(H264SWDEC_PARAM_ERR);
     }
 
    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));
 
     if (pDecCont == NULL)
     {
        DEC_API_TRC(""H264SwDecInit# ERROR: Memory allocation failed"");
 return(H264SWDEC_MEMFAIL);
 }

#ifdef H264DEC_TRACE
    sprintf(pDecCont->str, ""H264SwDecInit# decInst %p noOutputReordering %d"",
 (void*)decInst, noOutputReordering);
    DEC_API_TRC(pDecCont->str);
#endif

    rv = h264bsdInit(&pDecCont->storage, noOutputReordering);
 if (rv != HANTRO_OK)
 {
        H264SwDecRelease(pDecCont);
 return(H264SWDEC_MEMFAIL);
 }

    pDecCont->decStat  = INITIALIZED;
    pDecCont->picNumber = 0;

#ifdef H264DEC_TRACE
    sprintf(pDecCont->str, ""H264SwDecInit# OK: return %p"", (void*)pDecCont);
    DEC_API_TRC(pDecCont->str);
#endif

 *decInst = (decContainer_t *)pDecCont;

 return(H264SWDEC_OK);

}
","    pDecCont = (decContainer_t *)H264SwDecMalloc(sizeof(decContainer_t));
"
"void* H264SwDecMalloc(u32 size) {
    return malloc(size);
 }
","    return malloc(size);
"
"u32 h264bsdInit(storage_t *pStorage, u32 noOutputReordering)
{

/* Variables */
    u32 size;
/* Code */

    ASSERT(pStorage);

    h264bsdInitStorage(pStorage);

 /* allocate mbLayer to be next multiple of 64 to enable use of

      * specific NEON optimized ""memset"" for clearing the structure */
     size = (sizeof(macroblockLayer_t) + 63) & ~0x3F;
 
    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);
     if (!pStorage->mbLayer)
         return HANTRO_NOK;
 
 if (noOutputReordering)
        pStorage->noReordering = HANTRO_TRUE;

 return HANTRO_OK;
}
","    pStorage->mbLayer = (macroblockLayer_t*)H264SwDecMalloc(size);
"
"void OMX::binderDied(const wp<IBinder> &the_late_who) {
 OMXNodeInstance *instance;

 {

         Mutex::Autolock autoLock(mLock);
 
         ssize_t index = mLiveNodes.indexOfKey(the_late_who);
        CHECK(index >= 0);
 
         instance = mLiveNodes.editValueAt(index);
         mLiveNodes.removeItemsAt(index);

        index = mDispatchers.indexOfKey(instance->nodeID());
        CHECK(index >= 0);
        mDispatchers.removeItemsAt(index);

        invalidateNodeID_l(instance->nodeID());
 }

    instance->onObserverDied(mMaster);
}
","        CHECK(index >= 0);
"
"ssize_t NuPlayer::NuPlayerStreamListener::read(
 void *data, size_t size, sp<AMessage> *extra) {
    CHECK_GT(size, 0u);

    extra->clear();

 Mutex::Autolock autoLock(mLock);

 if (mEOS) {
 return 0;
 }

 if (mQueue.empty()) {
        mSendDataNotification = true;

 return -EWOULDBLOCK;
 }

 QueueEntry *entry = &*mQueue.begin();

 if (entry->mIsCommand) {
 switch (entry->mCommand) {
 case EOS:
 {
                mQueue.erase(mQueue.begin());
                entry = NULL;

                mEOS = true;
 return 0;
 }

 case DISCONTINUITY:
 {
 *extra = entry->mExtra;

                mQueue.erase(mQueue.begin());
                entry = NULL;

 return INFO_DISCONTINUITY;
 }

 default:
                TRESPASS();
 break;
 }
 }

 size_t copy = entry->mSize;
 if (copy > size) {

         copy = size;
     }
 
     memcpy(data,
           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
             + entry->mOffset,
            copy);
 
    entry->mOffset += copy;
    entry->mSize -= copy;

 if (entry->mSize == 0) {
        mSource->onBufferAvailable(entry->mIndex);
        mQueue.erase(mQueue.begin());
        entry = NULL;
 }

 return copy;
}
","           (const uint8_t *)mBuffers.editItemAt(entry->mIndex)->pointer()
"
"bt_status_t btif_dm_pin_reply( const bt_bdaddr_t *bd_addr, uint8_t accept,

                                uint8_t pin_len, bt_pin_code_t *pin_code)
 {
     BTIF_TRACE_EVENT(""%s: accept=%d"", __FUNCTION__, accept);
    if (pin_code == NULL)
         return BT_STATUS_FAIL;
 #if (defined(BLE_INCLUDED) && (BLE_INCLUDED == TRUE))
 
 if (pairing_cb.is_le_only)
 {
 int i;
        UINT32 passkey = 0;
 int multi[] = {100000, 10000, 1000, 100, 10,1};
        BD_ADDR remote_bd_addr;
        bdcpy(remote_bd_addr, bd_addr->address);
 for (i = 0; i < 6; i++)
 {
            passkey += (multi[i] * (pin_code->pin[i] - '0'));
 }
        BTIF_TRACE_DEBUG(""btif_dm_pin_reply: passkey: %d"", passkey);
        BTA_DmBlePasskeyReply(remote_bd_addr, accept, passkey);

 }
 else
 {
        BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);
 if (accept)
            pairing_cb.pin_code_len = pin_len;
 }
#else
    BTA_DmPinReply( (UINT8 *)bd_addr->address, accept, pin_len, pin_code->pin);

 if (accept)
        pairing_cb.pin_code_len = pin_len;
#endif
 return BT_STATUS_SUCCESS;
}
","    if (pin_code == NULL)
"
" std::string Backtrace::GetFunctionName(uintptr_t pc, uintptr_t* offset) {
   std::string func_name = GetFunctionNameRaw(pc, offset);
  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
   return func_name;
 }
","  if (!func_name.empty()) {
#if defined(__APPLE__)
    if (func_name[0] != '_') {
      return func_name;
    }
#endif
    char* name = __cxa_demangle(func_name.c_str(), 0, 0, 0);
    if (name) {
      func_name = name;
      free(name);
    }
  }
"
"char* engrave_tombstone(pid_t pid, pid_t tid, int signal, int original_si_code,
 uintptr_t abort_msg_address, bool dump_sibling_threads,
 bool* detach_failed, int* total_sleep_time_usec) {

 log_t log;

   log.current_tid = tid;
   log.crashed_tid = tid;
 
  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
   int fd = -1;
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
 
   if (fd < 0) {
     _LOG(&log, logtype::ERROR, ""Skipping tombstone write, nothing to do.\n"");
 *detach_failed = false;
 return NULL;
 }

  log.tfd = fd;
 int amfd = activity_manager_connect();
  log.amfd = amfd;
 *detach_failed = dump_crash(&log, pid, tid, signal, original_si_code, abort_msg_address,
                              dump_sibling_threads, total_sleep_time_usec);

  ALOGI(""\nTombstone written to: %s\n"", path);

  close(amfd);
  close(fd);

 return path;
}
","  if ((mkdir(TOMBSTONE_DIR, 0755) == -1) && (errno != EEXIST)) {
    _LOG(&log, logtype::ERROR, ""failed to create %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  if (chown(TOMBSTONE_DIR, AID_SYSTEM, AID_SYSTEM) == -1) {
    _LOG(&log, logtype::ERROR, ""failed to change ownership of %s: %s\n"", TOMBSTONE_DIR, strerror(errno));
  }
  char* path = NULL;
  if (selinux_android_restorecon(TOMBSTONE_DIR, 0) == 0) {
    path = find_and_open_tombstone(&fd);
  } else {
    _LOG(&log, logtype::ERROR, ""Failed to restore security context, not writing tombstone.\n"");
  }
"
" virtual status_t configureVideoTunnelMode(
            node_id node, OMX_U32 portIndex, OMX_BOOL tunneled,
            OMX_U32 audioHwSync, native_handle_t **sidebandHandle ) {
 Parcel data, reply;
        data.writeInterfaceToken(IOMX::getInterfaceDescriptor());
        data.writeInt32((int32_t)node);
        data.writeInt32(portIndex);
        data.writeInt32((int32_t)tunneled);
        data.writeInt32(audioHwSync);

         remote()->transact(CONFIGURE_VIDEO_TUNNEL_MODE, data, &reply);
 
         status_t err = reply.readInt32();
        if (sidebandHandle) {
             *sidebandHandle = (native_handle_t *)reply.readNativeHandle();
         }
         return err;
 }
","        if (sidebandHandle) {
"
"valid_length(uint8_t option, int dl, int *type)
{
 const struct dhcp_opt *opt;
 ssize_t sz;

 if (dl == 0)
 return -1;

 for (opt = dhcp_opts; opt->option; opt++) {
 if (opt->option != option)
 continue;

 
 		if (type)
 			*type = opt->type;
 		if (opt->type == 0 ||
 		    opt->type & (STRING | RFC3442 | RFC5969))
 			return 0;
 		sz = 0;
		if (opt->type & (UINT32 | IPV4))
 			sz = sizeof(uint32_t);
		if (opt->type & UINT16)
 			sz = sizeof(uint16_t);
		if (opt->type & UINT8)
 			sz = sizeof(uint8_t);
		if (opt->type & (IPV4 | ARRAY))
			return dl % sz;
		return (dl == sz ? 0 : -1);
 	}
 
 	/* unknown option, so let it pass */
 return 0;
}
","		if (opt->type & (UINT32 | IPV4))
		if (opt->type & UINT16)
		if (opt->type & UINT8)
		if (opt->type & (IPV4 | ARRAY))
			return dl % sz;
		return (dl == sz ? 0 : -1);
"
"sp<IMemoryHeap> BpMemory::getMemory(ssize_t* offset, size_t* size) const
{
 if (mHeap == 0) {
 Parcel data, reply;
        data.writeInterfaceToken(IMemory::getInterfaceDescriptor());
 if (remote()->transact(GET_MEMORY, data, &reply) == NO_ERROR) {
            sp<IBinder> heap = reply.readStrongBinder();
 ssize_t o = reply.readInt32();
 size_t s = reply.readInt32();

             if (heap != 0) {
                 mHeap = interface_cast<IMemoryHeap>(heap);
                 if (mHeap != 0) {
                    mOffset = o;
                    mSize = s;
                 }
             }
         }
     }
     if (offset) *offset = mOffset;
     if (size) *size = mSize;
    return mHeap;
 }
","                    mOffset = o;
                    mSize = s;
    return mHeap;
"
" MediaMetadataRetriever::MediaMetadataRetriever()
 {
     ALOGV(""constructor"");
    const sp<IMediaPlayerService>& service(getService());
     if (service == 0) {
         ALOGE(""failed to obtain MediaMetadataRetrieverService"");
         return;
 }
    sp<IMediaMetadataRetriever> retriever(service->createMetadataRetriever());
 if (retriever == 0) {
        ALOGE(""failed to create IMediaMetadataRetriever object from server"");
 }
    mRetriever = retriever;
}
","    const sp<IMediaPlayerService>& service(getService());
"
"static int vol_prc_lib_release(effect_handle_t handle)
{

     struct listnode *node, *temp_node_next;
     vol_listener_context_t *context = NULL;
     vol_listener_context_t *recv_contex = (vol_listener_context_t *)handle;
    int status = -1;
     bool recompute_flag = false;
     int active_stream_count = 0;
     ALOGV(""%s context %p"", __func__, handle);
     pthread_mutex_lock(&vol_listner_init_lock);
 
     list_for_each_safe(node, temp_node_next, &vol_effect_list) {
         context = node_to_item(node, struct vol_listener_context_s, effect_list_node);
        if ((memcmp(&(context->desc->uuid), &(recv_contex->desc->uuid), sizeof(effect_uuid_t)) == 0)
            && (context->session_id == recv_contex->session_id)
            && (context->stream_type == recv_contex->stream_type)) {
             ALOGV(""--- Found something to remove ---"");
            list_remove(&context->effect_list_node);
             PRINT_STREAM_TYPE(context->stream_type);
             if (context->dev_id && AUDIO_DEVICE_OUT_SPEAKER) {
                 recompute_flag = true;
 }
            free(context);
            status = 0;
 } else {
 ++active_stream_count;
 }
 }

 
     if (status != 0) {
         ALOGE(""something wrong ... <<<--- Found NOTHING to remove ... ???? --->>>>>"");
     }
 
 if (active_stream_count == 0) {
        current_gain_dep_cal_level = -1;
        current_vol = 0.0;
 }

 if (recompute_flag) {
        check_and_set_gain_dep_cal();
 }

 if (dumping_enabled) {
        dump_list_l();
 }
    pthread_mutex_unlock(&vol_listner_init_lock);
 return status;
}
","    int status = -1;
        if ((memcmp(&(context->desc->uuid), &(recv_contex->desc->uuid), sizeof(effect_uuid_t)) == 0)
            && (context->session_id == recv_contex->session_id)
            && (context->stream_type == recv_contex->stream_type)) {
            list_remove(&context->effect_list_node);
"
" void btif_config_flush(void) {
  assert(config != NULL);
  assert(alarm_timer != NULL);

 
   alarm_cancel(alarm_timer);
 
  pthread_mutex_lock(&lock);
  config_save(config, CONFIG_FILE_PATH);
  pthread_mutex_unlock(&lock);
 }
","  pthread_mutex_lock(&lock);
  config_save(config, CONFIG_FILE_PATH);
  pthread_mutex_unlock(&lock);
"
"void btif_config_save(void) {

   assert(alarm_timer != NULL);
   assert(config != NULL);
 
  alarm_set(alarm_timer, CONFIG_SETTLE_PERIOD_MS, timer_config_save, NULL);
 }
","  alarm_set(alarm_timer, CONFIG_SETTLE_PERIOD_MS, timer_config_save, NULL);
"
"static void timer_config_save(UNUSED_ATTR void *data) {
   assert(config != NULL);
   assert(alarm_timer != NULL);
 
  static const size_t CACHE_MAX = 256;
  const char *keys[CACHE_MAX];
  size_t num_keys = 0;
  size_t total_candidates = 0;
 
   pthread_mutex_lock(&lock);
  for (const config_section_node_t *snode = config_section_begin(config); snode != config_section_end(config); snode = config_section_next(snode)) {
    const char *section = config_section_name(snode);
    if (!string_is_bdaddr(section))
      continue;
    if (config_has_key(config, section, ""LinkKey"") ||
        config_has_key(config, section, ""LE_KEY_PENC"") ||
        config_has_key(config, section, ""LE_KEY_PID"") ||
        config_has_key(config, section, ""LE_KEY_PCSRK"") ||
        config_has_key(config, section, ""LE_KEY_LENC"") ||
        config_has_key(config, section, ""LE_KEY_LCSRK""))
      continue;
    if (num_keys < CACHE_MAX)
      keys[num_keys++] = section;
    ++total_candidates;
  }
  if (total_candidates > CACHE_MAX * 2)
    while (num_keys > 0)
      config_remove_section(config, keys[--num_keys]);
   config_save(config, CONFIG_FILE_PATH);
   pthread_mutex_unlock(&lock);
 }
","  static const size_t CACHE_MAX = 256;
  const char *keys[CACHE_MAX];
  size_t num_keys = 0;
  size_t total_candidates = 0;
  for (const config_section_node_t *snode = config_section_begin(config); snode != config_section_end(config); snode = config_section_next(snode)) {
    const char *section = config_section_name(snode);
    if (!string_is_bdaddr(section))
      continue;
    if (config_has_key(config, section, ""LinkKey"") ||
        config_has_key(config, section, ""LE_KEY_PENC"") ||
        config_has_key(config, section, ""LE_KEY_PID"") ||
        config_has_key(config, section, ""LE_KEY_PCSRK"") ||
        config_has_key(config, section, ""LE_KEY_LENC"") ||
        config_has_key(config, section, ""LE_KEY_LCSRK""))
      continue;
    if (num_keys < CACHE_MAX)
      keys[num_keys++] = section;
    ++total_candidates;
  }
  if (total_candidates > CACHE_MAX * 2)
    while (num_keys > 0)
      config_remove_section(config, keys[--num_keys]);
"
"INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)

 {
     stream_t *ps_stream = (stream_t *)pv_ctxt;
 
    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
     return;
 }
","    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)
"
"INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)
{
    UWORD32     u4_bit,u4_offset,u4_temp;
    UWORD32     u4_curr_bit;

    u4_offset               = ps_stream->u4_offset;
    u4_curr_bit             = u4_offset & 0x1F;
    u4_bit                  = ps_stream->u4_buf;

 /* Move the current bit read from the current word to the
       least significant bit positions of 'c'.*/
    u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;

    u4_offset++;

 /* If the last bit of the last word of the buffer has been read update
       the currrent buf with next, and read next buf from bit stream buffer */

     if (u4_curr_bit == 31)
     {
         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;
        u4_temp             = *(ps_stream->pu4_buf_aligned)++;
 
        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
     }
     ps_stream->u4_offset          = u4_offset;
 
 return (u4_bit & 0x1);
}
","        u4_temp             = *(ps_stream->pu4_buf_aligned)++;
        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)
"
"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while ( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case QUANT_MATRIX_EXT_ID:
                impeg2d_dec_quant_matrix_ext(ps_dec);
 break;
 case COPYRIGHT_EXT_ID:
                impeg2d_dec_copyright_ext(ps_dec);
 break;
 case PIC_DISPLAY_EXT_ID:
                impeg2d_dec_pic_disp_ext(ps_dec);
 break;
 case CAMERA_PARAM_EXT_ID:
                impeg2d_dec_cam_param_ext(ps_dec);
 break;
 case ITU_T_EXT_ID:
                impeg2d_dec_itu_t_ext(ps_dec);
 break;
 case PIC_SPATIAL_SCALABLE_EXT_ID:
 case PIC_TEMPORAL_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABLITY_NOT_SUP;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
","            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
"
"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    UWORD32     u4_start_code;
    IMPEG2D_ERROR_CODES_T e_error;

    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;

    ps_stream      = &ps_dec->s_bit_stream;

     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
     while( (u4_start_code == EXTENSION_START_CODE ||
             u4_start_code == USER_DATA_START_CODE) &&
            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
     {
         if(u4_start_code == USER_DATA_START_CODE)
         {
            impeg2d_dec_user_data(ps_dec);
 }
 else
 {
            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);
 switch(u4_start_code)
 {
 case SEQ_DISPLAY_EXT_ID:
                impeg2d_dec_seq_disp_ext(ps_dec);
 break;
 case SEQ_SCALABLE_EXT_ID:
                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;
 break;
 default:
 /* In case its a reserved extension code */
                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);
                impeg2d_peek_next_start_code(ps_dec);
 break;
 }
 }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
 return e_error;
}
","            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)
"
"void impeg2d_dec_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;

    ps_stream    = &ps_dec->s_bit_stream;
    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);


     while(u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
","        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
"
"void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)
{
    UWORD32 u4_start_code;
 stream_t *ps_stream;


     ps_stream    = &ps_dec->s_bit_stream;
     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 
    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
         {
             impeg2d_bit_stream_flush(ps_stream,8);
         }
        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);
 }
}
","    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)
        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
"
"void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)
{
 stream_t *ps_stream;

     ps_stream = &ps_dec->s_bit_stream;
     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
     {
 
         if (impeg2d_bit_stream_get(ps_stream,8) != 0)
 {
 /* Ignore stuffing bit errors. */
 }

 }
 return;
}
","    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
"
"void impeg2d_peek_next_start_code(dec_state_t *ps_dec)
{
 stream_t *ps_stream;
    ps_stream = &ps_dec->s_bit_stream;

     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);
 
     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)
        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
     {
         impeg2d_bit_stream_get(ps_stream,8);
     }
 return;
}
","        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))
"
" UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)
 {
     UWORD16 u2_mb_addr_incr = 0;
    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)
     {
         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);
         u2_mb_addr_incr += 33;
 }
    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +
        MB_ADDR_INCR_OFFSET;
 return(u2_mb_addr_incr);
}
","    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)
"
"void SoundPool::doLoad(sp<Sample>& sample)
{
    ALOGV(""doLoad: loading sample sampleID=%d"", sample->sampleID());
    sample->startLoad();
    mDecodeThread->loadSample(sample->sampleID());
 }
","{
    ALOGV(""doLoad: loading sample sampleID=%d"", sample->sampleID());
    sample->startLoad();
    mDecodeThread->loadSample(sample->sampleID());
"
" int SoundPool::load(const char* path, int priority __unused)
 {
     ALOGV(""load: path=%s, priority=%d"", path, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, path);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
 }
","    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, path);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
"
" int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)
 {
     ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
             fd, offset, length, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}
","    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}
"
"int SoundPool::play(int sampleID, float leftVolume, float rightVolume,
 int priority, int loop, float rate)

 {
     ALOGV(""play sampleID=%d, leftVolume=%f, rightVolume=%f, priority=%d, loop=%d, rate=%f"",
             sampleID, leftVolume, rightVolume, priority, loop, rate);
    sp<Sample> sample;
     SoundChannel* channel;
     int channelID;
 
 Mutex::Autolock lock(&mLock);

 if (mQuit) {

         return 0;
     }
    sample = findSample(sampleID);
     if ((sample == 0) || (sample->state() != Sample::READY)) {
         ALOGW(""  sample %d not READY"", sampleID);
         return 0;
 }

    dump();

    channel = allocateChannel_l(priority);

 if (!channel) {
        ALOGV(""No channel allocated"");
 return 0;
 }

    channelID = ++mNextChannelID;

    ALOGV(""play channel %p state = %d"", channel, channel->state());
    channel->play(sample, channelID, leftVolume, rightVolume, priority, loop, rate);
 return channelID;
}
","    sp<Sample> sample;
    sample = findSample(sampleID);
"
"void wifi_cleanup(wifi_handle handle, wifi_cleaned_up_handler handler)
{
    hal_info *info = getHalInfo(handle);
 char buf[64];

    info->cleaned_up_handler = handler;
 if (write(info->cleanup_socks[0], ""Exit"", 4) < 1) {
        ALOGE(""could not write to the cleanup socket"");
 } else {
        memset(buf, 0, sizeof(buf));
 int result = read(info->cleanup_socks[0], buf, sizeof(buf));
        ALOGE(""%s: Read after POLL returned %d, error no = %d"", __FUNCTION__, result, errno);
 if (strncmp(buf, ""Done"", 4) == 0) {
            ALOGE(""Event processing terminated"");
 } else {
            ALOGD(""Rx'ed %s"", buf);
 }
 }
    info->clean_up = true;
    pthread_mutex_lock(&info->cb_lock);

 int bad_commands = 0;

 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGI(""Command left in event_cb %p:%s"", cmd, (cmd ? cmd->getType(): """"));
 }

 while (info->num_cmd > bad_commands) {
 int num_cmd = info->num_cmd;
        cmd_info *cmdi = &(info->cmd[bad_commands]);
 WifiCommand *cmd = cmdi->cmd;
 if (cmd != NULL) {
            ALOGI(""Cancelling command %p:%s"", cmd, cmd->getType());

             pthread_mutex_unlock(&info->cb_lock);
             cmd->cancel();
             pthread_mutex_lock(&info->cb_lock);
            /* release reference added when command is saved */
            cmd->releaseRef();
             if (num_cmd == info->num_cmd) {
                 ALOGI(""Cancelling command %p:%s did not work"", cmd, (cmd ? cmd->getType(): """"));
                 bad_commands++;
             }
         }
     }
 
 for (int i = 0; i < info->num_event_cb; i++) {
        cb_info *cbi = &(info->event_cb[i]);
 WifiCommand *cmd = (WifiCommand *)cbi->cb_arg;
        ALOGE(""Leaked command %p"", cmd);
 }
    pthread_mutex_unlock(&info->cb_lock);
    internal_cleaned_up_handler(handle);
}
","            /* release reference added when command is saved */
            cmd->releaseRef();
"
"static bool getCoverageFormat12(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
 const size_t kNGroupsOffset = 12;
 const size_t kFirstGroupOffset = 16;

     const size_t kGroupSize = 12;
     const size_t kStartCharCodeOffset = 0;
     const size_t kEndCharCodeOffset = 4;
     if (kFirstGroupOffset > size) {
         return false;
     }
     uint32_t nGroups = readU32(data, kNGroupsOffset);
    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
         return false;
     }
     for (uint32_t i = 0; i < nGroups; i++) {
 uint32_t groupOffset = kFirstGroupOffset + i * kGroupSize;
 uint32_t start = readU32(data, groupOffset + kStartCharCodeOffset);
 uint32_t end = readU32(data, groupOffset + kEndCharCodeOffset);
        addRange(coverage, start, end + 1); // file is inclusive, vector is exclusive
 }
 return true;
}
","    if (kFirstGroupOffset + nGroups * kGroupSize > size) {
"
" static uint32_t readU16(const uint8_t* data, size_t offset) {
    return data[offset] << 8 | data[offset + 1];
 }
","    return data[offset] << 8 | data[offset + 1];
"
" static uint32_t readU32(const uint8_t* data, size_t offset) {
    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
 }
","    return data[offset] << 24 | data[offset + 1] << 16 | data[offset + 2] << 8 | data[offset + 3];
"
"static bool get_build_id(
 Backtrace* backtrace, uintptr_t base_addr, uint8_t* e_ident, std::string* build_id) {
 HdrType hdr;

  memcpy(&hdr.e_ident[0], e_ident, EI_NIDENT);

 if (backtrace->Read(base_addr + EI_NIDENT, reinterpret_cast<uint8_t*>(&hdr) + EI_NIDENT,
 sizeof(HdrType) - EI_NIDENT) != sizeof(HdrType) - EI_NIDENT) {
 return false;
 }

 for (size_t i = 0; i < hdr.e_phnum; i++) {
 PhdrType phdr;
 if (backtrace->Read(base_addr + hdr.e_phoff + i * hdr.e_phentsize,
 reinterpret_cast<uint8_t*>(&phdr), sizeof(phdr)) != sizeof(phdr)) {
 return false;
 }
 if (phdr.p_type == PT_NOTE) {
 size_t hdr_size = phdr.p_filesz;
 uintptr_t addr = base_addr + phdr.p_offset;
 while (hdr_size >= sizeof(NhdrType)) {
 NhdrType nhdr;
 if (backtrace->Read(addr, reinterpret_cast<uint8_t*>(&nhdr), sizeof(nhdr)) != sizeof(nhdr)) {
 return false;
 }
        addr += sizeof(nhdr);

         if (nhdr.n_type == NT_GNU_BUILD_ID) {
           addr += NOTE_ALIGN(nhdr.n_namesz);
          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
             return false;
           }
           if (backtrace->Read(addr, build_id_data, nhdr.n_descsz) != nhdr.n_descsz) {
 return false;
 }

          build_id->clear();
 for (size_t bytes = 0; bytes < nhdr.n_descsz; bytes++) {
 *build_id += android::base::StringPrintf(""%02x"", build_id_data[bytes]);
 }

 return true;
 } else {
          hdr_size -= sizeof(nhdr);
 size_t skip_bytes = NOTE_ALIGN(nhdr.n_namesz) + NOTE_ALIGN(nhdr.n_descsz);
          addr += skip_bytes;
 if (hdr_size < skip_bytes) {
 break;
 }
          hdr_size -= skip_bytes;
 }
 }
 }
 }
 return false;
}
","          uint8_t build_id_data[128];
          if (nhdr.n_namesz > sizeof(build_id_data)) {
            ALOGE(""Possible corrupted note, name size value is too large: %u"",
                  nhdr.n_namesz);
"
"static int prctl_set_vma_anon_name(unsigned long start, unsigned long end,
 unsigned long arg)
{
 unsigned long tmp;
 struct vm_area_struct * vma, *prev;
 int unmapped_error = 0;
 int error = -EINVAL;

 /*
	 * If the interval [start,end) covers some unmapped address
	 * ranges, just ignore them, but return -ENOMEM at the end.
	 * - this matches the handling in madvise.
	 */
	vma = find_vma_prev(current->mm, start, &prev);
 if (vma && start > vma->vm_start)
		prev = vma;

 for (;;) {
 /* Still start < end. */
		error = -ENOMEM;
 if (!vma)
 return error;

 /* Here start < (end|vma->vm_end). */
 if (start < vma->vm_start) {
			unmapped_error = -ENOMEM;
			start = vma->vm_start;
 if (start >= end)
 return error;
 }

 /* Here vma->vm_start <= start < (end|vma->vm_end) */
		tmp = vma->vm_end;
 if (end < tmp)

 			tmp = end;
 
 		/* Here vma->vm_start <= start < tmp <= (end|vma->vm_end). */
		error = prctl_update_vma_anon_name(vma, &prev, start, end,
 				(const char __user *)arg);
 		if (error)
 			return error;
		start = tmp;
 if (prev && start < prev->vm_end)
			start = prev->vm_end;
		error = unmapped_error;
 if (start >= end)
 return error;
 if (prev)
			vma = prev->vm_next;
 else /* madvise_remove dropped mmap_sem */
			vma = find_vma(current->mm, start);
 }
}
","		error = prctl_update_vma_anon_name(vma, &prev, start, end,
"
"OMX_ERRORTYPE SimpleSoftOMXComponent::useBuffer(
        OMX_BUFFERHEADERTYPE **header,
        OMX_U32 portIndex,
        OMX_PTR appPrivate,
        OMX_U32 size,
        OMX_U8 *ptr) {

     Mutex::Autolock autoLock(mLock);
     CHECK_LT(portIndex, mPorts.size());
 
     *header = new OMX_BUFFERHEADERTYPE;
     (*header)->nSize = sizeof(OMX_BUFFERHEADERTYPE);
     (*header)->nVersion.s.nVersionMajor = 1;
 (*header)->nVersion.s.nVersionMinor = 0;
 (*header)->nVersion.s.nRevision = 0;
 (*header)->nVersion.s.nStep = 0;
 (*header)->pBuffer = ptr;
 (*header)->nAllocLen = size;
 (*header)->nFilledLen = 0;
 (*header)->nOffset = 0;
 (*header)->pAppPrivate = appPrivate;
 (*header)->pPlatformPrivate = NULL;
 (*header)->pInputPortPrivate = NULL;
 (*header)->pOutputPortPrivate = NULL;
 (*header)->hMarkTargetComponent = NULL;
 (*header)->pMarkData = NULL;
 (*header)->nTickCount = 0;
 (*header)->nTimeStamp = 0;
 (*header)->nFlags = 0;

     (*header)->nOutputPortIndex = portIndex;
     (*header)->nInputPortIndex = portIndex;
 
    PortInfo *port = &mPorts.editItemAt(portIndex);
     CHECK(mState == OMX_StateLoaded || port->mDef.bEnabled == OMX_FALSE);
 
     CHECK_LT(port->mBuffers.size(), port->mDef.nBufferCountActual);

    port->mBuffers.push();

 BufferInfo *buffer =
 &port->mBuffers.editItemAt(port->mBuffers.size() - 1);

    buffer->mHeader = *header;
    buffer->mOwnedByUs = false;

 if (port->mBuffers.size() == port->mDef.nBufferCountActual) {
        port->mDef.bPopulated = OMX_TRUE;
        checkTransitions();
 }

 return OMX_ErrorNone;
}
","    PortInfo *port = &mPorts.editItemAt(portIndex);
"
"static int decode_map(codebook *s, oggpack_buffer *b, ogg_int32_t *v, int point){
 ogg_uint32_t entry = decode_packed_entry_number(s,b);
 int i;
 if(oggpack_eop(b))return(-1);

 /* 1 used by test file 0 */

 /* according to decode type */
 switch(s->dec_type){
 case 1:{
 /* packed vector of values */
 int mask=(1<<s->q_bits)-1;
 for(i=0;i<s->dim;i++){
      v[i]=entry&mask;
      entry>>=s->q_bits;
 }
 break;
 }
 case 2:{
 /* packed vector of column offsets */

     int mask=(1<<s->q_pack)-1;
     for(i=0;i<s->dim;i++){
       if(s->q_bits<=8)
	v[i]=((unsigned char *)(s->q_val))[entry&mask];
       else
	v[i]=((ogg_uint16_t *)(s->q_val))[entry&mask];
       entry>>=s->q_pack;
     }
     break;
 }
 case 3:{
 /* offset into array */
 void *ptr=((char *)s->q_val)+entry*s->q_pack;

 
     if(s->q_bits<=8){
       for(i=0;i<s->dim;i++)
	v[i]=((unsigned char *)ptr)[i];
     }else{
       for(i=0;i<s->dim;i++)
	v[i]=((ogg_uint16_t *)ptr)[i];
     }
     break;
   }
 default:
 return -1;
 }

 /* we have the unpacked multiplicands; compute final vals */
 {
 int         shiftM = point-s->q_delp;
 ogg_int32_t add    = point-s->q_minp;
 int         mul    = s->q_del;

 if(add>0)
      add= s->q_min >> add;
 else
      add= s->q_min << -add;
 if (shiftM<0)
 {
      mul <<= -shiftM;
      shiftM = 0;
 }
    add <<= shiftM;

 for(i=0;i<s->dim;i++)
      v[i]= ((add + v[i] * mul) >> shiftM);

 
     if(s->q_seq)
       for(i=1;i<s->dim;i++)
	v[i]+=v[i-1];
   }
 
   return 0;
}
","	v[i]=((unsigned char *)(s->q_val))[entry&mask];
	v[i]=((ogg_uint16_t *)(s->q_val))[entry&mask];
	v[i]=((unsigned char *)ptr)[i];
	v[i]=((ogg_uint16_t *)ptr)[i];
	v[i]+=v[i-1];
"
" static ogg_uint32_t decpack(long entry,long used_entry,long quantvals,
			    codebook *b,oggpack_buffer *opb,int maptype){
   ogg_uint32_t ret=0;
   int j;
 
 switch(b->dec_type){

 case 0:
 return (ogg_uint32_t)entry;

 case 1:

     if(maptype==1){
       /* vals are already read into temporary column vector here */
       for(j=0;j<b->dim;j++){
	ogg_uint32_t off=entry%quantvals;
	entry/=quantvals;
	ret|=((ogg_uint16_t *)(b->q_val))[off]<<(b->q_bits*j);
       }
     }else{
       for(j=0;j<b->dim;j++)
	ret|=oggpack_read(opb,b->q_bits)<<(b->q_bits*j);
     }
     return ret;
 
 case 2:
 for(j=0;j<b->dim;j++){
 ogg_uint32_t off=entry%quantvals;
      entry/=quantvals;
      ret|=off<<(b->q_pack*j);
 }
 return ret;

 case 3:
 return (ogg_uint32_t)used_entry;

 }
 return 0; /* silence compiler */
}
","			    codebook *b,oggpack_buffer *opb,int maptype){
	ogg_uint32_t off=entry%quantvals;
	entry/=quantvals;
	ret|=((ogg_uint16_t *)(b->q_val))[off]<<(b->q_bits*j);
	ret|=oggpack_read(opb,b->q_bits)<<(b->q_bits*j);
"
" long vorbis_book_decodev_add(codebook *book,ogg_int32_t *a,
			     oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
     ogg_int32_t *v = book->dec_buf;//(ogg_int32_t *)alloca(sizeof(*v)*book->dim);
     int i,j;


     if (!v) return -1;
     for(i=0;i<n;){
       if(decode_map(book,b,v,point))return -1;
      for (j=0;j<book->dim;j++)
	a[i++]+=v[j];
     }
   }
   return 0;
 }
","			     oggpack_buffer *b,int n,int point){
      for (j=0;j<book->dim;j++)
	a[i++]+=v[j];
"
" long vorbis_book_decodev_set(codebook *book,ogg_int32_t *a,
			     oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
     ogg_int32_t *v = book->dec_buf;//(ogg_int32_t *)alloca(sizeof(*v)*book->dim);
     int i,j;


     if (!v) return -1;
     for(i=0;i<n;){
       if(decode_map(book,b,v,point))return -1;
      for (j=0;j<book->dim;j++)
	a[i++]=v[j];
     }
   }else{
     int i,j;
 
     for(i=0;i<n;){
      for (j=0;j<book->dim;j++)
	a[i++]=0;
     }
   }
 
 return 0;
}
","			     oggpack_buffer *b,int n,int point){
      for (j=0;j<book->dim;j++)
	a[i++]=v[j];
      for (j=0;j<book->dim;j++)
	a[i++]=0;
"
" long vorbis_book_decodevs_add(codebook *book,ogg_int32_t *a,
			      oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
     int step=n/book->dim;
     ogg_int32_t *v = book->dec_buf;//(ogg_int32_t *)alloca(sizeof(*v)*book->dim);
 int i,j,o;
 if (!v) return -1;


     for (j=0;j<step;j++){
       if(decode_map(book,b,v,point))return -1;
       for(i=0,o=j;i<book->dim;i++,o+=step)
	a[o]+=v[i];
     }
   }
   return 0;
 }
","			      oggpack_buffer *b,int n,int point){
	a[o]+=v[i];
"
" long vorbis_book_decodevv_add(codebook *book,ogg_int32_t **a,
			      long offset,int ch,
			      oggpack_buffer *b,int n,int point){
   if(book->used_entries>0){
 
     ogg_int32_t *v = book->dec_buf;//(ogg_int32_t *)alloca(sizeof(*v)*book->dim);
 long i,j;
 int chptr=0;


     if (!v) return -1;
     for(i=offset;i<offset+n;){
       if(decode_map(book,b,v,point))return -1;
      for (j=0;j<book->dim;j++){
	a[chptr++][i]+=v[j];
	if(chptr==ch){
	  chptr=0;
	  i++;
	}
       }
     }
   }

 return 0;
}
","			      long offset,int ch,
			      oggpack_buffer *b,int n,int point){
      for (j=0;j<book->dim;j++){
	a[chptr++][i]+=v[j];
	if(chptr==ch){
	  chptr=0;
	  i++;
	}
"
"int res_unpack(vorbis_info_residue *info,
                vorbis_info *vi,oggpack_buffer *opb){
 int j,k;
  codec_setup_info     *ci=(codec_setup_info *)vi->codec_setup;
  memset(info,0,sizeof(*info));

  info->type=oggpack_read(opb,16);

   if(info->type>2 || info->type<0)goto errout;
   info->begin=oggpack_read(opb,24);
   info->end=oggpack_read(opb,24);
  info->grouping=oggpack_read(opb,24)+1;
  info->partitions=(char)(oggpack_read(opb,6)+1);
  info->groupbook=(unsigned char)oggpack_read(opb,8);
   if(info->groupbook>=ci->books)goto errout;
 
   info->stagemasks=_ogg_malloc(info->partitions*sizeof(*info->stagemasks));
  info->stagebooks=_ogg_malloc(info->partitions*8*sizeof(*info->stagebooks));

 for(j=0;j<info->partitions;j++){
 int cascade=oggpack_read(opb,3);
 if(oggpack_read(opb,1))
      cascade|=(oggpack_read(opb,5)<<3);
    info->stagemasks[j]=cascade;
 }

 for(j=0;j<info->partitions;j++){
 for(k=0;k<8;k++){
 if((info->stagemasks[j]>>k)&1){
 unsigned char book=(unsigned char)oggpack_read(opb,8);
 if(book>=ci->books)goto errout;
        info->stagebooks[j*8+k]=book;
 if(k+1>info->stages)info->stages=k+1;
 }else
        info->stagebooks[j*8+k]=0xff;
 }
 }

 
   if(oggpack_eop(opb))goto errout;
 
   return 0;
  errout:
   res_clear_info(info);
 return 1;
}
","  info->grouping=oggpack_read(opb,24)+1;
  info->partitions=(char)(oggpack_read(opb,6)+1);
  info->groupbook=(unsigned char)oggpack_read(opb,8);
"
"status_t SampleTable::setSyncSampleParams(off64_t data_offset, size_t data_size) {
 if (mSyncSampleOffset >= 0 || data_size < 8) {
 return ERROR_MALFORMED;
 }

 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;
 }

 uint32_t numSyncSamples = U32_AT(&header[4]);

 if (numSyncSamples < 2) {
        ALOGV(""Table of sync samples is empty or has only a single entry!"");
 }

 uint64_t allocSize = (uint64_t)numSyncSamples * sizeof(uint32_t);
 if (allocSize > kMaxTotalSize) {
        ALOGE(""Sync sample table size too large."");
 return ERROR_OUT_OF_RANGE;
 }

    mTotalSize += allocSize;
 if (mTotalSize > kMaxTotalSize) {
        ALOGE(""Sync sample table size would make sample table too large.\n""
 ""    Requested sync sample table size = %llu\n""
 ""    Eventual sample table size >= %llu\n""
 ""    Allowed sample table size = %llu\n"",
 (unsigned long long)allocSize,
 (unsigned long long)mTotalSize,
 (unsigned long long)kMaxTotalSize);
 return ERROR_OUT_OF_RANGE;
 }

    mSyncSamples = new (std::nothrow) uint32_t[numSyncSamples];
 if (!mSyncSamples) {
        ALOGE(""Cannot allocate sync sample table with %llu entries."",
 (unsigned long long)numSyncSamples);
 return ERROR_OUT_OF_RANGE;
 }

 
     if (mDataSource->readAt(data_offset + 8, mSyncSamples,
             (size_t)allocSize) != (ssize_t)allocSize) {
        delete mSyncSamples;
         mSyncSamples = NULL;
         return ERROR_IO;
     }

 for (size_t i = 0; i < numSyncSamples; ++i) {
 if (mSyncSamples[i] == 0) {
            ALOGE(""b/32423862, unexpected zero value in stss"");
 continue;
 }
        mSyncSamples[i] = ntohl(mSyncSamples[i]) - 1;
 }

    mSyncSampleOffset = data_offset;
    mNumSyncSamples = numSyncSamples;

 return OK;
}
","        delete mSyncSamples;
"
"sp<ABuffer> decodeBase64(const AString &s) {
 size_t n = s.size();
 if ((n % 4) != 0) {
 return NULL;
 }

 size_t padding = 0;
 if (n >= 1 && s.c_str()[n - 1] == '=') {
        padding = 1;

 if (n >= 2 && s.c_str()[n - 2] == '=') {
            padding = 2;

 if (n >= 3 && s.c_str()[n - 3] == '=') {
                padding = 3;
 }
 }
 }

 size_t outLen = (n / 4) * 3 - padding;

    sp<ABuffer> buffer = new ABuffer(outLen);

 uint8_t *out = buffer->data();
 if (out == NULL || buffer->size() < outLen) {
 return NULL;
 }
 size_t j = 0;
 uint32_t accum = 0;
 for (size_t i = 0; i < n; ++i) {
 char c = s.c_str()[i];
 unsigned value;
 if (c >= 'A' && c <= 'Z') {
            value = c - 'A';
 } else if (c >= 'a' && c <= 'z') {
            value = 26 + c - 'a';
 } else if (c >= '0' && c <= '9') {
            value = 52 + c - '0';
 } else if (c == '+') {
            value = 62;
 } else if (c == '/') {
            value = 63;
 } else if (c != '=') {
 return NULL;
 } else {
 if (i < n - padding) {
 return NULL;
 }

            value = 0;
 }


         accum = (accum << 6) | value;
 
         if (((i + 1) % 4) == 0) {
            out[j++] = (accum >> 16);
             if (j < outLen) { out[j++] = (accum >> 8) & 0xff; }
             if (j < outLen) { out[j++] = accum & 0xff; }
 
            accum = 0;
 }
 }

 return buffer;
}
","            out[j++] = (accum >> 16);
"
"bool NuMediaExtractor::getTotalBitrate(int64_t *bitrate) const {
 if (mTotalBitrate >= 0) {
 *bitrate = mTotalBitrate;
 return true;

     }
 
     off64_t size;
    if (mDurationUs >= 0 && mDataSource->getSize(&size) == OK) {
         *bitrate = size * 8000000ll / mDurationUs;  // in bits/sec
         return true;
     }

 return false;
}
","    if (mDurationUs >= 0 && mDataSource->getSize(&size) == OK) {
"
" SoftAACEncoder::~SoftAACEncoder() {
    delete[] mInputFrame;
    mInputFrame = NULL;
 
     if (mEncoderHandle) {
         CHECK_EQ(VO_ERR_NONE, mApiHandle->Uninit(mEncoderHandle));
        mEncoderHandle = NULL;
 }

 delete mApiHandle;
    mApiHandle = NULL;

 delete mMemOperator;
    mMemOperator = NULL;
}
","    delete[] mInputFrame;
    mInputFrame = NULL;
"
" SoftAACEncoder2::~SoftAACEncoder2() {
     aacEncClose(&mAACEncoder);
 
    delete[] mInputFrame;
    mInputFrame = NULL;
 }
","    delete[] mInputFrame;
    mInputFrame = NULL;
"
" OMX_ERRORTYPE SoftMPEG4Encoder::releaseEncoder() {
    if (!mStarted) {
        return OMX_ErrorNone;
     }
 
    PVCleanUpVideoEncoder(mHandle);
    free(mInputFrameData);
    mInputFrameData = NULL;
    delete mEncParams;
    mEncParams = NULL;
    delete mHandle;
    mHandle = NULL;
    mStarted = false;
 
     return OMX_ErrorNone;
 }
","    if (!mStarted) {
        return OMX_ErrorNone;
    PVCleanUpVideoEncoder(mHandle);
    free(mInputFrameData);
    mInputFrameData = NULL;
    delete mEncParams;
    mEncParams = NULL;
    delete mHandle;
    mHandle = NULL;
    mStarted = false;
"
"FLACParser::FLACParser(
 const sp<DataSource> &dataSource,
 const sp<MetaData> &fileMetadata,
 const sp<MetaData> &trackMetadata)
 : mDataSource(dataSource),
      mFileMetadata(fileMetadata),
      mTrackMetadata(trackMetadata),
      mInitCheck(false),
      mMaxBufferSize(0),
      mGroup(NULL),
      mCopy(copyTrespass),
      mDecoder(NULL),
      mCurrentPos(0LL),
      mEOF(false),

       mStreamInfoValid(false),
       mWriteRequested(false),
       mWriteCompleted(false),
      mWriteBuffer(NULL),
       mErrorStatus((FLAC__StreamDecoderErrorStatus) -1)
 {
     ALOGV(""FLACParser::FLACParser"");
    memset(&mStreamInfo, 0, sizeof(mStreamInfo));
    memset(&mWriteHeader, 0, sizeof(mWriteHeader));
    mInitCheck = init();
}
","      mWriteBuffer(NULL),
"
" static void copyMono16(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i];
 }
}
","        const int *const *src,
"
" static void copyMono24(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] >> 8;
 }
}
","        const int *const *src,
"
" static void copyMono8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 }
}
","        const int *const *src,
"
" static void copyStereo16(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i];
 *dst++ = src[1][i];

     }
 }
","        const int *const *src,
"
" static void copyStereo24(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] >> 8;
 *dst++ = src[1][i] >> 8;

     }
 }
","        const int *const *src,
"
" static void copyStereo8(
         short *dst,
        const int *const *src,
         unsigned nSamples,
         unsigned /* nChannels */) {
     for (unsigned i = 0; i < nSamples; ++i) {
 *dst++ = src[0][i] << 8;
 *dst++ = src[1][i] << 8;

     }
 }
","        const int *const *src,
"
" static void copyTrespass(
         short * /* dst */,
        const int *const * /* src */,
         unsigned /* nSamples */,
         unsigned /* nChannels */) {
     TRESPASS();
}
","        const int *const * /* src */,
"
"FLAC__StreamDecoderWriteStatus FLACParser::writeCallback(
 const FLAC__Frame *frame, const FLAC__int32 * const buffer[])
{
 if (mWriteRequested) {

         mWriteRequested = false;
         mWriteHeader = frame->header;
        mWriteBuffer = buffer;
         mWriteCompleted = true;
         return FLAC__STREAM_DECODER_WRITE_STATUS_CONTINUE;
     } else {
        ALOGE(""FLACParser::writeCallback unexpected"");
 return FLAC__STREAM_DECODER_WRITE_STATUS_ABORT;
 }
}
","        mWriteBuffer = buffer;
"
"bool ID3::removeUnsynchronizationV2_4(bool iTunesHack) {
 size_t oldSize = mSize;

 size_t offset = 0;
 while (mSize >= 10 && offset <= mSize - 10) {
 if (!memcmp(&mData[offset], ""\0\0\0\0"", 4)) {
 break;
 }

 size_t dataSize;
 if (iTunesHack) {
            dataSize = U32_AT(&mData[offset + 4]);
 } else if (!ParseSyncsafeInteger(&mData[offset + 4], &dataSize)) {
 return false;
 }

 if (dataSize > mSize - 10 - offset) {
 return false;
 }

 uint16_t flags = U16_AT(&mData[offset + 8]);
 uint16_t prevFlags = flags;

 if (flags & 1) {

 if (mSize < 14 || mSize - 14 < offset || dataSize < 4) {
 return false;
 }
            memmove(&mData[offset + 10], &mData[offset + 14], mSize - offset - 14);
            mSize -= 4;
            dataSize -= 4;


             flags &= ~1;
         }
 
        if (flags & 2) {
 
 size_t readOffset = offset + 11;
 size_t writeOffset = offset + 11;
 for (size_t i = 0; i + 1 < dataSize; ++i) {
 if (mData[readOffset - 1] == 0xff
 && mData[readOffset] == 0x00) {
 ++readOffset;
 --mSize;
 --dataSize;
 }

                 mData[writeOffset++] = mData[readOffset++];
             }
            memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
 
            flags &= ~2;
         }
         if (flags != prevFlags || iTunesHack) {
             WriteSyncsafeInteger(&mData[offset + 4], dataSize);
             mData[offset + 8] = flags >> 8;
            mData[offset + 9] = flags & 0xff;
 }

        offset += 10 + dataSize;
 }

    memset(&mData[mSize], 0, oldSize - mSize);

 return true;
}
","        if (flags & 2) {
            memmove(&mData[writeOffset], &mData[readOffset], oldSize - readOffset);
            flags &= ~2;
"
"static EAS_RESULT PushcdlStack (EAS_U32 *pStack, EAS_INT *pStackPtr, EAS_U32 value)

 {
 
     /* stack overflow, return an error */
    if (*pStackPtr >= CDL_STACK_SIZE)
         return EAS_ERROR_FILE_FORMAT;
 
     /* push the value onto the stack */
     *pStackPtr = *pStackPtr + 1;
    pStack[*pStackPtr] = value;
 return EAS_SUCCESS;
}
","    if (*pStackPtr >= CDL_STACK_SIZE)
"
"UWORD32 ihevcd_cabac_decode_bypass_bins_egk(cab_ctxt_t *ps_cabac,
 bitstrm_t *ps_bitstrm,
                                            WORD32 k)
{

    UWORD32 u4_sym;
    WORD32 numones;
    WORD32 bin;

 /* Sanity checks */
    ASSERT((k >= 0));


     numones = k;
     bin = 1;
     u4_sym = 0;
    while(bin)
     {
         IHEVCD_CABAC_DECODE_BYPASS_BIN(bin, ps_cabac, ps_bitstrm);
         u4_sym += bin << numones++;
     }
 
     numones -= 1;
    numones = CLIP3(numones, 0, 16);
 
     if(numones)
     {
        UWORD32 u4_suffix;

        IHEVCD_CABAC_DECODE_BYPASS_BINS(u4_suffix, ps_cabac, ps_bitstrm, numones);
        u4_sym += u4_suffix;
 }
 return (u4_sym);
}
","    while(bin)
    numones = CLIP3(numones, 0, 16);
"
"int Equalizer_setParameter (EffectContext *pContext, void *pParam, void *pValue){
 int status = 0;
 int32_t preset;
 int32_t band;
 int32_t level;
 int32_t *pParamTemp = (int32_t *)pParam;
 int32_t param = *pParamTemp++;


 switch (param) {
 case EQ_PARAM_CUR_PRESET:
        preset = (int32_t)(*(uint16_t *)pValue);

 if ((preset >= EqualizerGetNumPresets())||(preset < 0)) {
            status = -EINVAL;
 break;
 }
 EqualizerSetPreset(pContext, preset);
 break;
 case EQ_PARAM_BAND_LEVEL:

         band =  *pParamTemp;
         level = (int32_t)(*(int16_t *)pValue);
        if (band >= FIVEBAND_NUMBANDS) {
             status = -EINVAL;
             break;
         }
         EqualizerSetBandLevel(pContext, band, level);
 break;
 case EQ_PARAM_PROPERTIES: {
 int16_t *p = (int16_t *)pValue;
 if ((int)p[0] >= EqualizerGetNumPresets()) {
            status = -EINVAL;
 break;
 }
 if (p[0] >= 0) {
 EqualizerSetPreset(pContext, (int)p[0]);
 } else {
 if ((int)p[1] != FIVEBAND_NUMBANDS) {
                status = -EINVAL;
 break;
 }
 for (int i = 0; i < FIVEBAND_NUMBANDS; i++) {
 EqualizerSetBandLevel(pContext, i, (int)p[2 + i]);
 }
 }
 } break;
 default:
        ALOGV(""\tLVM_ERROR : Equalizer_setParameter() invalid param %d"", param);
        status = -EINVAL;
 break;
 }

 return status;
} /* end Equalizer_setParameter */
","        if (band >= FIVEBAND_NUMBANDS) {
"
"static size_t StringSize(const uint8_t *start, uint8_t encoding) {
//// return includes terminator;  if unterminated, returns > limit
     if (encoding == 0x00 || encoding == 0x03) {
        return strlen((const char *)start) + 1;
     }
 
     size_t n = 0;
    while (start[n] != '\0' || start[n + 1] != '\0') {
         n += 2;
     }
    return n + 2;
 }
","        return strlen((const char *)start) + 1;
    while (start[n] != '\0' || start[n + 1] != '\0') {
    return n + 2;
"
"ID3::getAlbumArt(size_t *length, String8 *mime) const {
 *length = 0;
    mime->setTo("""");

 Iterator it(
 *this,
 (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) ? ""APIC"" : ""PIC"");

 while (!it.done()) {
 size_t size;
 const uint8_t *data = it.getData(&size);
 if (!data) {
 return NULL;
 }

 
         if (mVersion == ID3_V2_3 || mVersion == ID3_V2_4) {
             uint8_t encoding = data[0];
            mime->setTo((const char *)&data[1]);
            size_t mimeLen = strlen((const char *)&data[1]) + 1;
 
 #if 0
            uint8_t picType = data[1 + mimeLen];
             if (picType != 0x03) {
                 it.next();
 continue;

             }
 #endif
 
            size_t descLen = StringSize(&data[2 + mimeLen], encoding);
            if (size < 2 ||
                    size - 2 < mimeLen ||
                    size - 2 - mimeLen < descLen) {
                ALOGW(""bogus album art sizes"");
                 return NULL;
             }
            *length = size - 2 - mimeLen - descLen;
 
            return &data[2 + mimeLen + descLen];
         } else {
             uint8_t encoding = data[0];
 
             if (!memcmp(&data[1], ""PNG"", 3)) {
                 mime->setTo(""image/png"");
             } else if (!memcmp(&data[1], ""JPG"", 3)) {
                mime->setTo(""image/jpeg"");
 } else if (!memcmp(&data[1], ""-->"", 3)) {
                mime->setTo(""text/plain"");
 } else {
 return NULL;
 }

#if 0
 uint8_t picType = data[4];
 if (picType != 0x03) {
                it.next();
 continue;

             }
 #endif
 
            size_t descLen = StringSize(&data[5], encoding);
 
             *length = size - 5 - descLen;
 
 return &data[5 + descLen];
 }
 }

 return NULL;
}
","            mime->setTo((const char *)&data[1]);
            size_t mimeLen = strlen((const char *)&data[1]) + 1;
            uint8_t picType = data[1 + mimeLen];
            size_t descLen = StringSize(&data[2 + mimeLen], encoding);
            if (size < 2 ||
                    size - 2 < mimeLen ||
                    size - 2 - mimeLen < descLen) {
                ALOGW(""bogus album art sizes"");
            *length = size - 2 - mimeLen - descLen;
            return &data[2 + mimeLen + descLen];
            size_t descLen = StringSize(&data[5], encoding);
"
"int vp8_remove_decoder_instances(struct frame_buffers *fb)
{
 if(!fb->use_frame_threads)
 {
        VP8D_COMP *pbi = fb->pbi[0];


         if (!pbi)
             return VPX_CODEC_ERROR;
 #if CONFIG_MULTITHREAD
        if (pbi->b_multithreaded_rd)
            vp8mt_de_alloc_temp_buffers(pbi, pbi->common.mb_rows);
         vp8_decoder_remove_threads(pbi);
 #endif
 
 /* decoder instance for single thread mode */
        remove_decompressor(pbi);
 }
 else
 {
 /* TODO : remove frame threads and decoder instances for each
         * thread here */
 }

 return VPX_CODEC_OK;
}
","        if (pbi->b_multithreaded_rd)
            vp8mt_de_alloc_temp_buffers(pbi, pbi->common.mb_rows);
"
"void vp8_decoder_remove_threads(VP8D_COMP *pbi)
{
    /* shutdown MB Decoding thread; */
    if (pbi->b_multithreaded_rd)
    {
        int i;
 
        pbi->b_multithreaded_rd = 0;
        /* allow all threads to exit */
        for (i = 0; i < pbi->allocated_decoding_thread_count; i++)
        {
            sem_post(&pbi->h_event_start_decoding[i]);
            pthread_join(pbi->h_decoding_thread[i], NULL);
        }
        for (i = 0; i < pbi->allocated_decoding_thread_count; i++)
        {
            sem_destroy(&pbi->h_event_start_decoding[i]);
        }
        sem_destroy(&pbi->h_event_end_decoding);
            vpx_free(pbi->h_decoding_thread);
            pbi->h_decoding_thread = NULL;
            vpx_free(pbi->h_event_start_decoding);
            pbi->h_event_start_decoding = NULL;
            vpx_free(pbi->mb_row_di);
            pbi->mb_row_di = NULL ;
            vpx_free(pbi->de_thread_data);
            pbi->de_thread_data = NULL;
     }
 }
","{
    /* shutdown MB Decoding thread; */
    if (pbi->b_multithreaded_rd)
    {
        int i;
        pbi->b_multithreaded_rd = 0;
        /* allow all threads to exit */
        for (i = 0; i < pbi->allocated_decoding_thread_count; i++)
        {
            sem_post(&pbi->h_event_start_decoding[i]);
            pthread_join(pbi->h_decoding_thread[i], NULL);
        }
        for (i = 0; i < pbi->allocated_decoding_thread_count; i++)
        {
            sem_destroy(&pbi->h_event_start_decoding[i]);
        }
        sem_destroy(&pbi->h_event_end_decoding);
            vpx_free(pbi->h_decoding_thread);
            pbi->h_decoding_thread = NULL;
            vpx_free(pbi->h_event_start_decoding);
            pbi->h_event_start_decoding = NULL;
            vpx_free(pbi->mb_row_di);
            pbi->mb_row_di = NULL ;
            vpx_free(pbi->de_thread_data);
            pbi->de_thread_data = NULL;
"
"netdutils::Status XfrmController::ipSecSetEncapSocketOwner(const android::base::unique_fd& socket,
 int newUid, uid_t callerUid) {
    ALOGD(""XfrmController:%s, line=%d"", __FUNCTION__, __LINE__);

 const int fd = socket.get();
 struct stat info;
 if (fstat(fd, &info)) {
 return netdutils::statusFromErrno(errno, ""Failed to stat socket file descriptor"");
 }
 if (info.st_uid != callerUid) {
 return netdutils::statusFromErrno(EPERM, ""fchown disabled for non-owner calls"");
 }
 if (S_ISSOCK(info.st_mode) == 0) {
 return netdutils::statusFromErrno(EINVAL, ""File descriptor was not a socket"");

     }
 
     int optval;
    socklen_t optlen;
     netdutils::Status status =
         getSyscallInstance().getsockopt(Fd(socket), IPPROTO_UDP, UDP_ENCAP, &optval, &optlen);
     if (status != netdutils::status::ok) {
 return status;
 }
 if (optval != UDP_ENCAP_ESPINUDP && optval != UDP_ENCAP_ESPINUDP_NON_IKE) {
 return netdutils::statusFromErrno(EINVAL, ""Socket did not have UDP-encap sockopt set"");
 }
 if (fchown(fd, newUid, -1)) {
 return netdutils::statusFromErrno(errno, ""Failed to fchown socket file descriptor"");
 }

 return netdutils::status::ok;
}
","    socklen_t optlen;
"
"void smp_process_keypress_notification(tSMP_CB* p_cb, tSMP_INT_DATA* p_data) {
 uint8_t* p = (uint8_t*)p_data;

   uint8_t reason = SMP_INVALID_PARAMETERS;
 
   SMP_TRACE_DEBUG(""%s"", __func__);
  p_cb->status = *(uint8_t*)p_data;
 
   if (smp_command_has_invalid_parameters(p_cb)) {
     smp_sm_event(p_cb, SMP_AUTH_CMPL_EVT, &reason);
     return;
   }
 
   if (p != NULL) {
     STREAM_TO_UINT8(p_cb->peer_keypress_notification, p);
   } else {
    p_cb->peer_keypress_notification = BTM_SP_KEY_OUT_OF_RANGE;
 }
  p_cb->cb_evt = SMP_PEER_KEYPR_NOT_EVT;
}
","  p_cb->status = *(uint8_t*)p_data;
"
" void BnCrypto::readVector(const Parcel &data, Vector<uint8_t> &vector) const {
     uint32_t size = data.readInt32();
    vector.insertAt((size_t)0, size);
    data.read(vector.editArray(), size);
 }
","    vector.insertAt((size_t)0, size);
    data.read(vector.editArray(), size);
"
"VOID ixheaacd_shiftrountine_with_rnd_hq(WORD32 *qmf_real, WORD32 *qmf_imag,
                                        WORD32 *filter_states, WORD32 len,
                                        WORD32 shift) {
  WORD32 *filter_states_rev = filter_states + len;
  WORD32 treal, timag;
  WORD32 j;

 for (j = (len - 1); j >= 0; j -= 2) {
    WORD32 r1, r2, i1, i2;
    i2 = qmf_imag[j];
    r2 = qmf_real[j];

     r1 = *qmf_real++;
     i1 = *qmf_imag++;
 
    timag = ixheaacd_add32(i1, r1);
     timag = (ixheaacd_shl32_sat(timag, shift));
     filter_states_rev[j] = timag;
 
    treal = ixheaacd_sub32(i2, r2);
     treal = (ixheaacd_shl32_sat(treal, shift));
     filter_states[j] = treal;
 
    treal = ixheaacd_sub32(i1, r1);
     treal = (ixheaacd_shl32_sat(treal, shift));
     *filter_states++ = treal;
 
    timag = ixheaacd_add32(i2, r2);
     timag = (ixheaacd_shl32_sat(timag, shift));
     *filter_states_rev++ = timag;
   }
}
","    timag = ixheaacd_add32(i1, r1);
    treal = ixheaacd_sub32(i2, r2);
    treal = ixheaacd_sub32(i1, r1);
    timag = ixheaacd_add32(i2, r2);
"
"AMediaCodecCryptoInfo *AMediaCodecCryptoInfo_new(
 int numsubsamples,
 uint8_t key[16],
 uint8_t iv[16],
 cryptoinfo_mode_t mode,
 size_t *clearbytes,

         size_t *encryptedbytes) {
 
    size_t cryptosize = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2;
     AMediaCodecCryptoInfo *ret = (AMediaCodecCryptoInfo*) malloc(cryptosize);
     if (!ret) {
         ALOGE(""couldn't allocate %zu bytes"", cryptosize);
 return NULL;
 }
    ret->numsubsamples = numsubsamples;
    memcpy(ret->key, key, 16);
    memcpy(ret->iv, iv, 16);
    ret->mode = mode;
    ret->pattern.encryptBlocks = 0;
    ret->pattern.skipBlocks = 0;

    ret->clearbytes = (size_t*) (ret + 1); // point immediately after the struct
    ret->encryptedbytes = ret->clearbytes + numsubsamples; // point after the clear sizes

    memcpy(ret->clearbytes, clearbytes, numsubsamples * sizeof(size_t));
    memcpy(ret->encryptedbytes, encryptedbytes, numsubsamples * sizeof(size_t));

 return ret;
}
","    size_t cryptosize = sizeof(AMediaCodecCryptoInfo) + sizeof(size_t) * numsubsamples * 2;
"
" static Maybe<bool> CollectValuesOrEntriesImpl(

       Isolate* isolate, Handle<JSObject> object,
       Handle<FixedArray> values_or_entries, bool get_entries, int* nof_items,
       PropertyFilter filter) {
    int count = 0;
     KeyAccumulator accumulator(isolate, KeyCollectionMode::kOwnOnly,
                                ALL_PROPERTIES);
     Subclass::CollectElementIndicesImpl(
         object, handle(object->elements(), isolate), &accumulator);
     Handle<FixedArray> keys = accumulator.GetKeys();
 
    for (int i = 0; i < keys->length(); ++i) {
       Handle<Object> key(keys->get(i), isolate);
      Handle<Object> value;
       uint32_t index;
       if (!key->ToUint32(&index)) continue;
 
       uint32_t entry = Subclass::GetEntryForIndexImpl(
           isolate, *object, object->elements(), index, filter);
       if (entry == kMaxUInt32) continue;
 
       PropertyDetails details = Subclass::GetDetailsImpl(*object, entry);
 
       if (details.kind() == kData) {
         value = Subclass::GetImpl(isolate, object->elements(), entry);
       } else {
         LookupIterator it(isolate, object, index, LookupIterator::OWN);
         ASSIGN_RETURN_ON_EXCEPTION_VALUE(
             isolate, value, Object::GetProperty(&it), Nothing<bool>());
       }
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
       }
       values_or_entries->set(count++, *value);
     }
 
 *nof_items = count;
 return Just(true);
 }
","    int count = 0;
    for (int i = 0; i < keys->length(); ++i) {
      Handle<Object> value;
      if (get_entries) {
        value = MakeEntryPair(isolate, index, value);
"
"   explicit ElementsAccessorBase(const char* name)
      : ElementsAccessor(name) { }
","      : ElementsAccessor(name) { }
"
" static Maybe<bool> IncludesValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                        Handle<Object> value,
                                        uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map = handle(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
     bool search_for_hole = value->IsUndefined(isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 if (search_for_hole) return Just(true);
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<bool>());

 if (value->SameValueZero(*element_k)) return Just(true);

 if (object->map() != *original_map) {
 return IncludesValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->SameValueZero(*element_k)) {
 return Just(true);
 }
 }
 return Just(false);
 }
","    Handle<Map> original_map = handle(object->map(), isolate);
"
" static Maybe<int64_t> IndexOfValueImpl(Isolate* isolate,
 Handle<JSObject> object,

                                          Handle<Object> value,
                                          uint32_t start_from, uint32_t length) {
     DCHECK(JSObject::PrototypeHasNoElements(isolate, *object));
    Handle<Map> original_map = handle(object->map(), isolate);
     Handle<FixedArray> parameter_map(FixedArray::cast(object->elements()),
                                      isolate);
 
     for (uint32_t k = start_from; k < length; ++k) {
       uint32_t entry = GetEntryForIndexImpl(isolate, *object, *parameter_map, k,
                                             ALL_PROPERTIES);
       if (entry == kMaxUInt32) {
 continue;
 }

 Handle<Object> element_k =
 Subclass::GetImpl(isolate, *parameter_map, entry);

 if (element_k->IsAccessorPair()) {
 LookupIterator it(isolate, object, k, LookupIterator::OWN);
        DCHECK(it.IsFound());
        DCHECK_EQ(it.state(), LookupIterator::ACCESSOR);
        ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, element_k,
 Object::GetPropertyWithAccessor(&it),
 Nothing<int64_t>());

 if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }

 if (object->map() != *original_map) {
 return IndexOfValueSlowPath(isolate, object, value, k + 1, length);
 }
 } else if (value->StrictEquals(*element_k)) {
 return Just<int64_t>(k);
 }
 }
 return Just<int64_t>(-1);
 }
","    Handle<Map> original_map = handle(object->map(), isolate);
"
"WORD32 ih264d_parse_sei_message(dec_struct_t *ps_dec,
 dec_bit_stream_t *ps_bitstrm)
{
    UWORD32 ui4_payload_type, ui4_payload_size;
    UWORD32 u4_bits;
    WORD32 i4_status = 0;

 do
 {

         ui4_payload_type = 0;
 
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
        while(0xff == u4_bits)
         {
             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
             ui4_payload_type += 255;
 }
        ui4_payload_type += u4_bits;

 
         ui4_payload_size = 0;
         u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
        while(0xff == u4_bits)
         {
             u4_bits = ih264d_get_bits_h264(ps_bitstrm, 8);
             ui4_payload_size += 255;
 }
        ui4_payload_size += u4_bits;

        i4_status = ih264d_parse_sei_payload(ps_bitstrm, ui4_payload_type,
                                             ui4_payload_size, ps_dec);
 if(i4_status == -1)
 {
            i4_status = 0;
 break;
 }

 if(i4_status != OK)
 return i4_status;

 if(ih264d_check_byte_aligned(ps_bitstrm) == 0)
 {
            u4_bits = ih264d_get_bit_h264(ps_bitstrm);
 if(0 == u4_bits)

             {
                 H264_DEC_DEBUG_PRINT(""\nError in parsing SEI message"");
             }
            while(0 == ih264d_check_byte_aligned(ps_bitstrm))
             {
                 u4_bits = ih264d_get_bit_h264(ps_bitstrm);
                 if(u4_bits)
 {
                    H264_DEC_DEBUG_PRINT(""\nError in parsing SEI message"");
 }
 }
 }
 }
 while(ps_bitstrm->u4_ofst < ps_bitstrm->u4_max_ofst);
 return (i4_status);
}
","        while(0xff == u4_bits)
        while(0xff == u4_bits)
            while(0 == ih264d_check_byte_aligned(ps_bitstrm))
"
"WORD32 ihevcd_create(iv_obj_t *ps_codec_obj,

                            void *pv_api_ip,
                            void *pv_api_op)
 {
     ihevcd_cxa_create_op_t *ps_create_op;
 
     WORD32 ret;
     codec_t *ps_codec;
     ps_create_op = (ihevcd_cxa_create_op_t *)pv_api_op;
 
     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;
     ret = ihevcd_allocate_static_bufs(&ps_codec_obj, pv_api_ip, pv_api_op);
 
     /* If allocation of some buffer fails, then free buffers allocated till then */
    if((IV_FAIL == ret) && (NULL != ps_codec_obj))
     {
        ihevcd_free_static_bufs(ps_codec_obj);
         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;
         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;
 
 return IV_FAIL;
 }
    ps_codec = (codec_t *)ps_codec_obj->pv_codec_handle;
    ret = ihevcd_init(ps_codec);

    TRACE_INIT(NULL);
    STATS_INIT();

 return ret;
}
","    if((IV_FAIL == ret) && (NULL != ps_codec_obj))
        ihevcd_free_static_bufs(ps_codec_obj);
"
" WORD32 ih264d_create(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)
 {
     ih264d_create_op_t *ps_create_op;
 
     WORD32 ret;
 
     ps_create_op = (ih264d_create_op_t *)pv_api_op;
 
     ps_create_op->s_ivd_create_op_t.u4_error_code = 0;
     ret = ih264d_allocate_static_bufs(&dec_hdl, pv_api_ip, pv_api_op);
 
     /* If allocation of some buffer fails, then free buffers allocated till then */
    if((IV_FAIL == ret) && (NULL != dec_hdl))
     {
        ih264d_free_static_bufs(dec_hdl);
         ps_create_op->s_ivd_create_op_t.u4_error_code = IVD_MEM_ALLOC_FAILED;
         ps_create_op->s_ivd_create_op_t.u4_error_code = 1 << IVD_FATALERROR;
 
 return IV_FAIL;
 }

 return IV_SUCCESS;
}
","    if((IV_FAIL == ret) && (NULL != dec_hdl))
        ih264d_free_static_bufs(dec_hdl);
"
"xmlParse3986Port(xmlURIPtr uri, const char **str)
{
 const char *cur = *str;
 unsigned port = 0; /* unsigned for defined overflow behavior */

 if (ISA_DIGIT(cur)) {
 while (ISA_DIGIT(cur)) {
	    port = port * 10 + (*cur - '0');


 	    cur++;
 	}
 	if (uri != NULL)
	    uri->port = port & INT_MAX; /* port value modulo INT_MAX+1 */
 	*str = cur;
 	return(0);
     }
 return(1);
}
","	    uri->port = port & INT_MAX; /* port value modulo INT_MAX+1 */
"
"static jlong Region_createFromParcel(JNIEnv* env, jobject clazz, jobject parcel)
{
 if (parcel == NULL) {
 return NULL;
 }

    android::Parcel* p = android::parcelForJavaObject(env, parcel);

 const size_t size = p->readInt32();
 const void* regionData = p->readInplace(size);
 if (regionData == NULL) {

         return NULL;
     }
     SkRegion* region = new SkRegion;
    region->readFromMemory(regionData, size);
 
     return reinterpret_cast<jlong>(region);
 }
","    region->readFromMemory(regionData, size);
"
" native_handle_t* native_handle_create(int numFds, int numInts)
 {
    native_handle_t* h = malloc(
            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));
 
     if (h) {
         h->version = sizeof(native_handle_t);
         h->numFds = numFds;
        h->numInts = numInts;
 }
 return h;
}
","    native_handle_t* h = malloc(
            sizeof(native_handle_t) + sizeof(int)*(numFds+numInts));
"
"    BufferMeta(const sp<IMemory> &mem, OMX_U32 portIndex, bool is_backup = false)
         : mMem(mem),
          mIsBackup(is_backup),
          mPortIndex(portIndex) {
     }
","          mIsBackup(is_backup),
          mPortIndex(portIndex) {
"
"     BufferMeta(size_t size, OMX_U32 portIndex)
         : mSize(size),
          mIsBackup(false),
          mPortIndex(portIndex) {
     }
","          mIsBackup(false),
          mPortIndex(portIndex) {
"
"     BufferMeta(const sp<GraphicBuffer> &graphicBuffer, OMX_U32 portIndex)
         : mGraphicBuffer(graphicBuffer),
          mIsBackup(false),
          mPortIndex(portIndex) {
     }
","          mIsBackup(false),
          mPortIndex(portIndex) {
"
"     void CopyFromOMX(const OMX_BUFFERHEADERTYPE *header) {
        if (!mIsBackup) {
             return;
         }
 
        sp<ABuffer> codec = getBuffer(header, false /* backup */, true /* limit */);

        memcpy((OMX_U8 *)mMem->pointer() + header->nOffset, codec->data(), codec->size());

     }
","        if (!mIsBackup) {
"
"     void CopyToOMX(const OMX_BUFFERHEADERTYPE *header) {
        if (!mIsBackup) {
             return;
         }
 
        memcpy(header->pBuffer + header->nOffset,
 (const OMX_U8 *)mMem->pointer() + header->nOffset,
                header->nFilledLen);
 }
","        if (!mIsBackup) {
"
"status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;

     }
 
     Mutex::Autolock autoLock(mLock);
    if (allottedSize > params->size()) {
         return BAD_VALUE;
     }
 
    BufferMeta *buffer_meta = new BufferMeta(params, portIndex, true);
 
     OMX_BUFFERHEADERTYPE *header;
 
    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
 
     *buffer = makeBufferID(header);
 
    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
","    if (allottedSize > params->size()) {
    BufferMeta *buffer_meta = new BufferMeta(params, portIndex, true);
"
"status_t OMXNodeInstance::createGraphicBufferSource(

         OMX_U32 portIndex, sp<IGraphicBufferConsumer> bufferConsumer, MetadataBufferType *type) {
     status_t err;
 
    const sp<GraphicBufferSource>& surfaceCheck = getGraphicBufferSource();
     if (surfaceCheck != NULL) {
         if (portIndex < NELEM(mMetadataType) && type != NULL) {
             *type = mMetadataType[portIndex];
 }
 return ALREADY_EXISTS;
 }

 if (type != NULL) {
 *type = kMetadataBufferTypeANWBuffer;
 }
    err = storeMetaDataInBuffers_l(portIndex, OMX_TRUE, type);
 if (err != OK) {
 return err;
 }

    OMX_PARAM_PORTDEFINITIONTYPE def;
 InitOMXParams(&def);
    def.nPortIndex = portIndex;
    OMX_ERRORTYPE oerr = OMX_GetParameter(
            mHandle, OMX_IndexParamPortDefinition, &def);
 if (oerr != OMX_ErrorNone) {
        OMX_INDEXTYPE index = OMX_IndexParamPortDefinition;
        CLOG_ERROR(getParameter, oerr, ""%s(%#x): %s:%u"",
                asString(index), index, portString(portIndex), portIndex);
 return UNKNOWN_ERROR;
 }

 if (def.format.video.eColorFormat != OMX_COLOR_FormatAndroidOpaque) {
        CLOGW(""createInputSurface requires COLOR_FormatSurface ""
 ""(AndroidOpaque) color format instead of %s(%#x)"",
                asString(def.format.video.eColorFormat), def.format.video.eColorFormat);
 return INVALID_OPERATION;
 }

 uint32_t usageBits;
    oerr = OMX_GetParameter(
            mHandle, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits, &usageBits);
 if (oerr != OMX_ErrorNone) {
        usageBits = 0;
 }

    sp<GraphicBufferSource> bufferSource = new GraphicBufferSource(this,
            def.format.video.nFrameWidth,
            def.format.video.nFrameHeight,
            def.nBufferCountActual,
            usageBits,
            bufferConsumer);

 if ((err = bufferSource->initCheck()) != OK) {
 return err;
 }
    setGraphicBufferSource(bufferSource);

 return OK;
}
","    const sp<GraphicBufferSource>& surfaceCheck = getGraphicBufferSource();
"
" status_t OMXNodeInstance::sendCommand(
         OMX_COMMANDTYPE cmd, OMX_S32 param) {
    const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());
     if (bufferSource != NULL && cmd == OMX_CommandStateSet) {
         if (param == OMX_StateIdle) {
            bufferSource->omxIdle();
 } else if (param == OMX_StateLoaded) {
            bufferSource->omxLoaded();
            setGraphicBufferSource(NULL);
 }

 }

 Mutex::Autolock autoLock(mLock);

 {
 Mutex::Autolock _l(mDebugLock);
        bumpDebugLevel_l(2 /* numInputBuffers */, 2 /* numOutputBuffers */);
 }

 const char *paramString =
        cmd == OMX_CommandStateSet ? asString((OMX_STATETYPE)param) : portString(param);
    CLOG_STATE(sendCommand, ""%s(%d), %s(%d)"", asString(cmd), cmd, paramString, param);
    OMX_ERRORTYPE err = OMX_SendCommand(mHandle, cmd, param, NULL);
    CLOG_IF_ERROR(sendCommand, err, ""%s(%d), %s(%d)"", asString(cmd), cmd, paramString, param);

     return StatusFromOMXError(err);
 }
","    const sp<GraphicBufferSource>& bufferSource(getGraphicBufferSource());
"
"status_t OMXNodeInstance::updateGraphicBufferInMeta(
        OMX_U32 portIndex, const sp<GraphicBuffer>& graphicBuffer,
        OMX::buffer_id buffer) {
 Mutex::Autolock autoLock(mLock);
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);

     return updateGraphicBufferInMeta_l(
             portIndex, graphicBuffer, buffer, header,
            portIndex == kPortIndexOutput /* updateCodecBuffer */);
 }
","            portIndex == kPortIndexOutput /* updateCodecBuffer */);
"
" status_t OMXNodeInstance::updateNativeHandleInMeta(
        OMX_U32 portIndex, const sp<NativeHandle>& nativeHandle, OMX::buffer_id buffer) {
 Mutex::Autolock autoLock(mLock);
    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer, portIndex);
 if (header == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 if (portIndex != kPortIndexInput && portIndex != kPortIndexOutput) {
 return BAD_VALUE;
 }


     BufferMeta *bufferMeta = (BufferMeta *)(header->pAppPrivate);
     sp<ABuffer> data = bufferMeta->getBuffer(
            header, portIndex == kPortIndexInput /* backup */, false /* limit */);
     bufferMeta->setNativeHandle(nativeHandle);
     if (mMetadataType[portIndex] == kMetadataBufferTypeNativeHandleSource
             && data->capacity() >= sizeof(VideoNativeHandleMetadata)) {
 VideoNativeHandleMetadata &metadata = *(VideoNativeHandleMetadata *)(data->data());
        metadata.eType = mMetadataType[portIndex];
        metadata.pHandle =
            nativeHandle == NULL ? NULL : const_cast<native_handle*>(nativeHandle->handle());
 } else {
        CLOG_ERROR(updateNativeHandleInMeta, BAD_VALUE, ""%s:%u, %#x bad type (%d) or size (%zu)"",
            portString(portIndex), portIndex, buffer, mMetadataType[portIndex], data->capacity());
 return BAD_VALUE;
 }

    CLOG_BUFFER(updateNativeHandleInMeta, ""%s:%u, %#x := %p"",
            portString(portIndex), portIndex, buffer,
            nativeHandle == NULL ? NULL : nativeHandle->handle());
 return OK;
}
","            header, portIndex == kPortIndexInput /* backup */, false /* limit */);
"
"status_t OMXNodeInstance::useBuffer(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;

     }
 
     Mutex::Autolock autoLock(mLock);
    if (allottedSize > params->size()) {
         return BAD_VALUE;
     }
 
    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);
 
     OMX_BUFFERHEADERTYPE *header;
 
     OMX_ERRORTYPE err = OMX_UseBuffer(
             mHandle, &header, portIndex, buffer_meta,
            allottedSize, static_cast<OMX_U8 *>(params->pointer()));
 
     if (err != OMX_ErrorNone) {
         CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(
                portIndex, (size_t)allottedSize, params->pointer()));
 
         delete buffer_meta;
         buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pAppPrivate, buffer_meta);

 *buffer = makeBufferID(header);

    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(
 *buffer, portIndex, ""%u(%zu)@%p"", allottedSize, params->size(), params->pointer()));
 return OK;
}
","    if (allottedSize > params->size()) {
    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);
            allottedSize, static_cast<OMX_U8 *>(params->pointer()));
                portIndex, (size_t)allottedSize, params->pointer()));
"
"status_t OMXNodeInstance::allocateBufferWithBackup(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
 return BAD_VALUE;
 }

 bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;

 BufferMeta *buffer_meta = new BufferMeta(
            params, portIndex,
 (portIndex == kPortIndexInput) && copy /* copyToOmx */,
 (portIndex == kPortIndexOutput) && copy /* copyFromOmx */,
            NULL /* data */);

    OMX_BUFFERHEADERTYPE *header;

    OMX_ERRORTYPE err = OMX_AllocateBuffer(
            mHandle, &header, portIndex, buffer_meta, allottedSize);
 if (err != OMX_ErrorNone) {
        CLOG_ERROR(allocateBufferWithBackup, err,
                SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);

     }
 
     CHECK_EQ(header->pAppPrivate, buffer_meta);
    memset(header->pBuffer, 0, header->nAllocLen);
 
     *buffer = makeBufferID(header);
 
    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
            params->size(), params->pointer(), allottedSize, header->pBuffer));

 return OK;
}
","    memset(header->pBuffer, 0, header->nAllocLen);
"
"status_t OMXNodeInstance::useBuffer(
        OMX_U32 portIndex, const sp<IMemory> &params,
        OMX::buffer_id *buffer, OMX_U32 allottedSize) {
 if (params == NULL || buffer == NULL) {
        ALOGE(""b/25884056"");
 return BAD_VALUE;
 }

 Mutex::Autolock autoLock(mLock);
 if (allottedSize > params->size() || portIndex >= NELEM(mNumPortBuffers)) {
 return BAD_VALUE;
 }

 BufferMeta *buffer_meta;
 bool useBackup = mMetadataType[portIndex] != kMetadataBufferTypeInvalid;
    OMX_U8 *data = static_cast<OMX_U8 *>(params->pointer());
 if (useBackup) {
        data = new (std::nothrow) OMX_U8[allottedSize];
 if (data == NULL) {
 return NO_MEMORY;
 }
        memset(data, 0, allottedSize);

 if (allottedSize != params->size()) {
            CLOG_ERROR(useBuffer, BAD_VALUE, SIMPLE_BUFFER(portIndex, (size_t)allottedSize, data));
 delete[] data;
 return BAD_VALUE;
 }

        buffer_meta = new BufferMeta(

                 params, portIndex, false /* copyToOmx */, false /* copyFromOmx */, data);
     } else {
         buffer_meta = new BufferMeta(
                params, portIndex, false /* copyFromOmx */, false /* copyToOmx */, NULL);
     }
 
     OMX_BUFFERHEADERTYPE *header;

    OMX_ERRORTYPE err = OMX_UseBuffer(
            mHandle, &header, portIndex, buffer_meta,
            allottedSize, data);

 if (err != OMX_ErrorNone) {
        CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(
                portIndex, (size_t)allottedSize, data));

 delete buffer_meta;
        buffer_meta = NULL;

 *buffer = 0;

 return StatusFromOMXError(err);
 }

    CHECK_EQ(header->pAppPrivate, buffer_meta);

 *buffer = makeBufferID(header);

    addActiveBuffer(portIndex, *buffer);

    sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
 if (bufferSource != NULL && portIndex == kPortIndexInput) {
        bufferSource->addCodecBuffer(header);
 }

    CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(
 *buffer, portIndex, ""%u(%zu)@%p"", allottedSize, params->size(), params->pointer()));
 return OK;
}
","                params, portIndex, false /* copyFromOmx */, false /* copyToOmx */, NULL);
"
"void close_all_sockets(atransport* t) {
    asocket* s;


     /* this is a little gross, but since s->close() *will* modify
     ** the list out from under you, your options are limited.
     */
    adb_mutex_lock(&socket_list_lock);
 restart:
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close_locked(s);
             goto restart;
         }
     }
    adb_mutex_unlock(&socket_list_lock);
 }
","    adb_mutex_lock(&socket_list_lock);
            local_socket_close_locked(s);
    adb_mutex_unlock(&socket_list_lock);
"
"asocket* find_local_socket(unsigned local_id, unsigned peer_id) {

     asocket* s;
     asocket* result = NULL;
 
    adb_mutex_lock(&socket_list_lock);
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->id != local_id) {
             continue;
 }
 if (peer_id == 0 || (s->peer && s->peer->id == peer_id)) {
            result = s;

         }
         break;
     }
    adb_mutex_unlock(&socket_list_lock);
 
     return result;
 }
","    adb_mutex_lock(&socket_list_lock);
    adb_mutex_unlock(&socket_list_lock);
"
" void install_local_socket(asocket* s) {
    adb_mutex_lock(&socket_list_lock);
 
     s->id = local_socket_next_id++;
 
     if (local_socket_next_id == 0) {
        local_socket_next_id = 1;
     }
 
     insert_local_socket(s, &local_socket_list);
    adb_mutex_unlock(&socket_list_lock);
 }
","    adb_mutex_lock(&socket_list_lock);
        local_socket_next_id = 1;
    adb_mutex_unlock(&socket_list_lock);
"
"static void local_socket_close(asocket* s) {
    adb_mutex_lock(&socket_list_lock);
    local_socket_close_locked(s);
    adb_mutex_unlock(&socket_list_lock);
}
","    adb_mutex_lock(&socket_list_lock);
    local_socket_close_locked(s);
    adb_mutex_unlock(&socket_list_lock);
}
"
"static void local_socket_close_locked(asocket* s) {
    D(""entered local_socket_close_locked. LS(%d) fd=%d"", s->id, s->fd);
     if (s->peer) {
         D(""LS(%d): closing peer. peer->id=%d peer->fd=%d"", s->id, s->peer->id, s->peer->fd);
         /* Note: it's important to call shutdown before disconnecting from
         * the peer, this ensures that remote sockets can still get the id
         * of the local socket they're connected to, to send a CLOSE()
         * protocol event. */

         if (s->peer->shutdown) {
             s->peer->shutdown(s->peer);
         }
        s->peer->peer = 0;
        if (s->peer->close == local_socket_close) {
            local_socket_close_locked(s->peer);
        } else {
            s->peer->close(s->peer);
        }
        s->peer = 0;
     }
 
     /* If we are already closing, or if there are no
    ** pending packets, destroy immediately
    */
 if (s->closing || s->has_write_error || s->pkt_first == NULL) {
 int id = s->id;
        local_socket_destroy(s);
        D(""LS(%d): closed"", id);
 return;
 }

 /* otherwise, put on the closing list
    */
    D(""LS(%d): closing"", s->id);
    s->closing = 1;
    fdevent_del(&s->fde, FDE_READ);
    remove_socket(s);
    D(""LS(%d): put on socket_closing_list fd=%d"", s->id, s->fd);
    insert_local_socket(s, &local_socket_closing_list);
    CHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);
}
","    D(""entered local_socket_close_locked. LS(%d) fd=%d"", s->id, s->fd);
        s->peer->peer = 0;
        if (s->peer->close == local_socket_close) {
            local_socket_close_locked(s->peer);
        } else {
            s->peer->close(s->peer);
        }
        s->peer = 0;
"
" void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
","        ALOGE(""memset buffer too small: got %lu, expected %zu"", (unsigned long)outHeader->nAllocLen, len);
"
" void *SoftMP3::memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len) {
     if (len > outHeader->nAllocLen) {
        ALOGE(""memset buffer too small: got %lu, expected %zu"", outHeader->nAllocLen, len);
         android_errorWriteLog(0x534e4554, ""29422022"");
         notify(OMX_EventError, OMX_ErrorUndefined, OUTPUT_BUFFER_TOO_SMALL, NULL);
         mSignalledError = true;
 return NULL;
 }
 return memset(outHeader->pBuffer, c, len);
}
","        ALOGE(""memset buffer too small: got %lu, expected %zu"", outHeader->nAllocLen, len);
"
"status_t Parcel::readUtf8FromUtf16(std::string* str) const {
 size_t utf16Size = 0;
 const char16_t* src = readString16Inplace(&utf16Size);
 if (!src) {
 return UNEXPECTED_NULL;
 }

 if (utf16Size == 0u) {
        str->clear();

        return NO_ERROR;
     }
 
    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);
    if (utf8Size < 0) {
         return BAD_VALUE;
     }
    str->resize(utf8Size + 1);
    utf16_to_utf8(src, utf16Size, &((*str)[0]));
     str->resize(utf8Size);
     return NO_ERROR;
 }
","    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size);
    if (utf8Size < 0) {
    str->resize(utf8Size + 1);
    utf16_to_utf8(src, utf16Size, &((*str)[0]));
"
"void unmarshallAudioAttributes(const Parcel& parcel, audio_attributes_t *attributes)
{
    attributes->usage = (audio_usage_t) parcel.readInt32();
    attributes->content_type = (audio_content_type_t) parcel.readInt32();
    attributes->source = (audio_source_t) parcel.readInt32();
    attributes->flags = (audio_flags_mask_t) parcel.readInt32();
 const bool hasFlattenedTag = (parcel.readInt32() == kAudioAttributesMarshallTagFlattenTags);
 if (hasFlattenedTag) {
 String16 tags = parcel.readString16();
 ssize_t realTagSize = utf16_to_utf8_length(tags.string(), tags.size());
 if (realTagSize <= 0) {
            strcpy(attributes->tags, """");
 } else {

             size_t tagSize = realTagSize > AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 ?
                     AUDIO_ATTRIBUTES_TAGS_MAX_SIZE - 1 : realTagSize;
            utf16_to_utf8(tags.string(), tagSize, attributes->tags);
         }
     } else {
         ALOGE(""unmarshallAudioAttributes() received unflattened tags, ignoring tag values"");
        strcpy(attributes->tags, """");
 }
}
","            utf16_to_utf8(tags.string(), tagSize, attributes->tags);
"
"std::string utf16ToUtf8(const StringPiece16& utf16) {
 ssize_t utf8Length = utf16_to_utf8_length(utf16.data(), utf16.length());
 if (utf8Length <= 0) {
 return {};

     }
 
     std::string utf8;
     utf8.resize(utf8Length);
    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());
     return utf8;
 }
","    utf16_to_utf8(utf16.data(), utf16.length(), &*utf8.begin());
"
"static jboolean enableNative(JNIEnv* env, jobject obj) {
     ALOGV(""%s:"",__FUNCTION__);
 
     jboolean result = JNI_FALSE;
     if (!sBluetoothInterface) return result;
    int ret = sBluetoothInterface->enable();
     result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
     return result;
 }
","    int ret = sBluetoothInterface->enable();
"
" status_t NuPlayer::GenericSource::setBuffers(
         bool audio, Vector<MediaBuffer *> &buffers) {
    if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {
         return mVideoTrack.mSource->setBuffers(buffers);
     }
     return INVALID_OPERATION;
}
","    if (mIsWidevine && !audio && mVideoTrack.mSource != NULL) {
"
" bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {
    return x >= frameLeft && x <= frameRight
            && y >= frameTop && y <= frameBottom;
 }
","    return x >= frameLeft && x <= frameRight
            && y >= frameTop && y <= frameBottom;
"
"SampleTable::SampleTable(const sp<DataSource> &source)
 : mDataSource(source),
      mChunkOffsetOffset(-1),
      mChunkOffsetType(0),
      mNumChunkOffsets(0),
      mSampleToChunkOffset(-1),
      mNumSampleToChunkOffsets(0),
      mSampleSizeOffset(-1),
      mSampleSizeFieldSize(0),

       mDefaultSampleSize(0),
       mNumSampleSizes(0),
       mTimeToSampleCount(0),
      mTimeToSample(NULL),
       mSampleTimeEntries(NULL),
       mCompositionTimeDeltaEntries(NULL),
       mNumCompositionTimeDeltaEntries(0),
      mCompositionDeltaLookup(new CompositionDeltaLookup),
      mSyncSampleOffset(-1),
      mNumSyncSamples(0),
      mSyncSamples(NULL),
      mLastSyncSampleIndex(0),
      mSampleToChunkEntries(NULL) {
    mSampleIterator = new SampleIterator(this);
}
","      mTimeToSample(NULL),
"
"bool SampleTable::isValid() const {

     return mChunkOffsetOffset >= 0
         && mSampleToChunkOffset >= 0
         && mSampleSizeOffset >= 0
        && mTimeToSample != NULL;
 }
","        && mTimeToSample != NULL;
"
" status_t SampleTable::setTimeToSampleParams(
         off64_t data_offset, size_t data_size) {
    if (mTimeToSample != NULL || data_size < 8) {
         return ERROR_MALFORMED;
     }
 
 uint8_t header[8];
 if (mDataSource->readAt(
                data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
 return ERROR_IO;
 }

 if (U32_AT(header) != 0) {
 return ERROR_MALFORMED;

     }
 
     mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = (uint64_t)mTimeToSampleCount * 2 * sizeof(uint32_t);
    if (allocSize > UINT32_MAX) {
         return ERROR_OUT_OF_RANGE;
     }
    mTimeToSample = new (std::nothrow) uint32_t[mTimeToSampleCount * 2];
    if (!mTimeToSample)
        return ERROR_OUT_OF_RANGE;
 
    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
    if (mDataSource->readAt(
                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
         return ERROR_IO;
     }
 
    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
        mTimeToSample[i] = ntohl(mTimeToSample[i]);
     }
     return OK;
 }
","    if (mTimeToSample != NULL || data_size < 8) {
    uint64_t allocSize = (uint64_t)mTimeToSampleCount * 2 * sizeof(uint32_t);
    if (allocSize > UINT32_MAX) {
    mTimeToSample = new (std::nothrow) uint32_t[mTimeToSampleCount * 2];
    if (!mTimeToSample)
        return ERROR_OUT_OF_RANGE;
    size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
    if (mDataSource->readAt(
                data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
    for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
        mTimeToSample[i] = ntohl(mTimeToSample[i]);
"
"SampleTable::~SampleTable() {
 delete[] mSampleToChunkEntries;
    mSampleToChunkEntries = NULL;

 delete[] mSyncSamples;
    mSyncSamples = NULL;

 delete mCompositionDeltaLookup;
    mCompositionDeltaLookup = NULL;

 delete[] mCompositionTimeDeltaEntries;
    mCompositionTimeDeltaEntries = NULL;


     delete[] mSampleTimeEntries;
     mSampleTimeEntries = NULL;
 
    delete[] mTimeToSample;
    mTimeToSample = NULL;
     delete mSampleIterator;
     mSampleIterator = NULL;
 }
","    delete[] mTimeToSample;
    mTimeToSample = NULL;
"
" void SoftAVC::drainAllOutputBuffers(bool eos) {
 List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);
    H264SwDecPicture decodedPicture;

 if (mHeadersDecoded) {
 while (!outQueue.empty()
 && H264SWDEC_PIC_RDY == H264SwDecNextPicture(

                     mHandle, &decodedPicture, eos /* flush */)) {
             int32_t picId = decodedPicture.picId;
             uint8_t *data = (uint8_t *) decodedPicture.pOutputPicture;
            drainOneOutputBuffer(picId, data);
         }
     }
 
 if (!eos) {
 return;
 }

 while (!outQueue.empty()) {
 BufferInfo *outInfo = *outQueue.begin();
        outQueue.erase(outQueue.begin());
        OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;

        outHeader->nTimeStamp = 0;
        outHeader->nFilledLen = 0;
        outHeader->nFlags = OMX_BUFFERFLAG_EOS;

        outInfo->mOwnedByUs = false;
        notifyFillBufferDone(outHeader);

        mEOSStatus = OUTPUT_FRAMES_FLUSHED;
 }
}
","            drainOneOutputBuffer(picId, data);
"
"void SoftAVC::drainOneOutputBuffer(int32_t picId, uint8_t* data) {
     List<BufferInfo *> &outQueue = getPortQueue(kOutputPortIndex);
     BufferInfo *outInfo = *outQueue.begin();
    outQueue.erase(outQueue.begin());
     OMX_BUFFERHEADERTYPE *outHeader = outInfo->mHeader;
     OMX_BUFFERHEADERTYPE *header = mPicToHeaderMap.valueFor(picId);
     outHeader->nTimeStamp = header->nTimeStamp;
     outHeader->nFlags = header->nFlags;
    outHeader->nFilledLen = mWidth * mHeight * 3 / 2;
 
     uint8_t *dst = outHeader->pBuffer + outHeader->nOffset;
     const uint8_t *srcY = data;
 const uint8_t *srcU = srcY + mWidth * mHeight;
 const uint8_t *srcV = srcU + mWidth * mHeight / 4;
 size_t srcYStride = mWidth;
 size_t srcUStride = mWidth / 2;
 size_t srcVStride = srcUStride;
    copyYV12FrameToOutputBuffer(dst, srcY, srcU, srcV, srcYStride, srcUStride, srcVStride);

    mPicToHeaderMap.removeItem(picId);

     delete header;
     outInfo->mOwnedByUs = false;
     notifyFillBufferDone(outHeader);
 }
","    outQueue.erase(outQueue.begin());
    outHeader->nFilledLen = mWidth * mHeight * 3 / 2;
"
"void SoftAVC::setDecodeArgs(
         ivd_video_decode_ip_t *ps_dec_ip,
         ivd_video_decode_op_t *ps_dec_op,
         OMX_BUFFERHEADERTYPE *inHeader,
        OMX_BUFFERHEADERTYPE *outHeader,

         size_t timeStampIx) {
     size_t sizeY = outputBufferWidth() * outputBufferHeight();
     size_t sizeUV;
    uint8_t *pBuf;
 
     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);
     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);

    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;

 /* When in flush and after EOS with zero byte input,
     * inHeader is set to zero. Hence check for non-null */
 if (inHeader) {
        ps_dec_ip->u4_ts = timeStampIx;
        ps_dec_ip->pv_stream_buffer =
            inHeader->pBuffer + inHeader->nOffset;
        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;
 } else {
        ps_dec_ip->u4_ts = 0;
        ps_dec_ip->pv_stream_buffer = NULL;

         ps_dec_ip->u4_num_Bytes = 0;
     }
 
    if (outHeader) {
        pBuf = outHeader->pBuffer;
    } else {
        pBuf = mFlushOutBuffer;
    }
     sizeUV = sizeY / 4;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;
 
     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;
     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;
     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;
     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;
    return;
 }
","    uint8_t *pBuf;
    if (outHeader) {
        pBuf = outHeader->pBuffer;
    } else {
        pBuf = mFlushOutBuffer;
    }
    return;
"
"void SoftHEVC::setDecodeArgs(ivd_video_decode_ip_t *ps_dec_ip,
         ivd_video_decode_op_t *ps_dec_op,
         OMX_BUFFERHEADERTYPE *inHeader,
         OMX_BUFFERHEADERTYPE *outHeader,
         size_t timeStampIx) {
     size_t sizeY = outputBufferWidth() * outputBufferHeight();
     size_t sizeUV;
    uint8_t *pBuf;
 
     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);
     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);

    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;

 /* When in flush and after EOS with zero byte input,
     * inHeader is set to zero. Hence check for non-null */
 if (inHeader) {
        ps_dec_ip->u4_ts = timeStampIx;
        ps_dec_ip->pv_stream_buffer = inHeader->pBuffer
 + inHeader->nOffset;
        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;
 } else {
        ps_dec_ip->u4_ts = 0;
        ps_dec_ip->pv_stream_buffer = NULL;

         ps_dec_ip->u4_num_Bytes = 0;
     }
 
    if (outHeader) {
        pBuf = outHeader->pBuffer;
    } else {
        pBuf = mFlushOutBuffer;
    }
     sizeUV = sizeY / 4;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;
 
     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;
     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;
     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;
     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;
    return;
 }
","    uint8_t *pBuf;
    if (outHeader) {
        pBuf = outHeader->pBuffer;
    } else {
        pBuf = mFlushOutBuffer;
    }
    return;
"
"void SoftMPEG2::setDecodeArgs(
         ivd_video_decode_ip_t *ps_dec_ip,
         ivd_video_decode_op_t *ps_dec_op,
         OMX_BUFFERHEADERTYPE *inHeader,
        OMX_BUFFERHEADERTYPE *outHeader,

         size_t timeStampIx) {
     size_t sizeY = outputBufferWidth() * outputBufferHeight();
     size_t sizeUV;
    uint8_t *pBuf;
 
     ps_dec_ip->u4_size = sizeof(ivd_video_decode_ip_t);
     ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);

    ps_dec_ip->e_cmd = IVD_CMD_VIDEO_DECODE;

 /* When in flush and after EOS with zero byte input,
     * inHeader is set to zero. Hence check for non-null */
 if (inHeader) {
        ps_dec_ip->u4_ts = timeStampIx;
        ps_dec_ip->pv_stream_buffer = inHeader->pBuffer
 + inHeader->nOffset;
        ps_dec_ip->u4_num_Bytes = inHeader->nFilledLen;
 } else {
        ps_dec_ip->u4_ts = 0;
        ps_dec_ip->pv_stream_buffer = NULL;

         ps_dec_ip->u4_num_Bytes = 0;
     }
 
    if (outHeader) {
        pBuf = outHeader->pBuffer;
    } else {
        pBuf = mFlushOutBuffer;
    }
     sizeUV = sizeY / 4;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[0] = sizeY;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[1] = sizeUV;
     ps_dec_ip->s_out_buffer.u4_min_out_buf_size[2] = sizeUV;
 
     ps_dec_ip->s_out_buffer.pu1_bufs[0] = pBuf;
     ps_dec_ip->s_out_buffer.pu1_bufs[1] = pBuf + sizeY;
     ps_dec_ip->s_out_buffer.pu1_bufs[2] = pBuf + sizeY + sizeUV;
     ps_dec_ip->s_out_buffer.u4_num_bufs = 3;
    return;
 }
","    uint8_t *pBuf;
    if (outHeader) {
        pBuf = outHeader->pBuffer;
    } else {
        pBuf = mFlushOutBuffer;
    }
    return;
"
"OMX_ERRORTYPE SoftAVC::internalSetParameter(OMX_INDEXTYPE index, const OMX_PTR params) {
 int32_t indexFull = index;


     switch (indexFull) {
         case OMX_IndexParamVideoBitrate:
         {
            return internalSetBitrateParams(
                    (const OMX_VIDEO_PARAM_BITRATETYPE *)params);
         }
 
         case OMX_IndexParamVideoAvc:
         {
             OMX_VIDEO_PARAM_AVCTYPE *avcType = (OMX_VIDEO_PARAM_AVCTYPE *)params;
 
             if (avcType->nPortIndex != 1) {
                 return OMX_ErrorUndefined;
             }

            mEntropyMode = 0;

 if (OMX_TRUE == avcType->bEntropyCodingCABAC)
                mEntropyMode = 1;

 if ((avcType->nAllowedPictureTypes & OMX_VIDEO_PictureTypeB) &&
                    avcType->nPFrames) {
                mBframes = avcType->nBFrames / avcType->nPFrames;
 }

            mIInterval = avcType->nPFrames + avcType->nBFrames;

 if (OMX_VIDEO_AVCLoopFilterDisable == avcType->eLoopFilterMode)
                mDisableDeblkLevel = 4;

 if (avcType->nRefFrames != 1
 || avcType->bUseHadamard != OMX_TRUE
 || avcType->nRefIdx10ActiveMinus1 != 0
 || avcType->nRefIdx11ActiveMinus1 != 0
 || avcType->bWeightedPPrediction != OMX_FALSE
 || avcType->bconstIpred != OMX_FALSE
 || avcType->bDirect8x8Inference != OMX_FALSE
 || avcType->bDirectSpatialTemporal != OMX_FALSE
 || avcType->nCabacInitIdc != 0) {
 return OMX_ErrorUndefined;
 }

 if (OK != ConvertOmxAvcLevelToAvcSpecLevel(avcType->eLevel, &mAVCEncLevel)) {
 return OMX_ErrorUndefined;
 }

 return OMX_ErrorNone;
 }

 default:
 return SoftVideoEncoderOMXComponent::internalSetParameter(index, params);
 }
}
","            return internalSetBitrateParams(
                    (const OMX_VIDEO_PARAM_BITRATETYPE *)params);
"
"OMX_ERRORTYPE SoftVPXEncoder::internalSetParameter(OMX_INDEXTYPE index,
 const OMX_PTR param) {

     const int32_t indexFull = index;
 
     switch (indexFull) {
        case OMX_IndexParamVideoBitrate:
            return internalSetBitrateParams(
                (const OMX_VIDEO_PARAM_BITRATETYPE *)param);
 
        case OMX_IndexParamVideoVp8:
            return internalSetVp8Params(
                (const OMX_VIDEO_PARAM_VP8TYPE *)param);
 
        case OMX_IndexParamVideoAndroidVp8Encoder:
            return internalSetAndroidVp8Params(
                (const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *)param);
 
         default:
             return SoftVideoEncoderOMXComponent::internalSetParameter(index, param);
 }
}
","        case OMX_IndexParamVideoBitrate:
            return internalSetBitrateParams(
                (const OMX_VIDEO_PARAM_BITRATETYPE *)param);
        case OMX_IndexParamVideoVp8:
            return internalSetVp8Params(
                (const OMX_VIDEO_PARAM_VP8TYPE *)param);
        case OMX_IndexParamVideoAndroidVp8Encoder:
            return internalSetAndroidVp8Params(
                (const OMX_VIDEO_PARAM_ANDROID_VP8ENCODERTYPE *)param);
"
"long ParseElementHeader(IMkvReader* pReader, long long& pos,
 long long stop, long long& id,
 long long& size) {
 if (stop >= 0 && pos >= stop)
 return E_FILE_FORMAT_INVALID;

 long len;

  id = ReadID(pReader, pos, len);

 if (id < 0)
 return E_FILE_FORMAT_INVALID;

  pos += len; // consume id

 if (stop >= 0 && pos >= stop)
 return E_FILE_FORMAT_INVALID;

  size = ReadUInt(pReader, pos, len);

 if (size < 0 || len < 1 || len > 8) {
 return E_FILE_FORMAT_INVALID;
 }

 const unsigned long long rollover_check =
 static_cast<unsigned long long>(pos) + len;
 if (rollover_check > LONG_LONG_MAX)
 return E_FILE_FORMAT_INVALID;

  pos += len; // consume length of size

 
 
  if (stop >= 0 && pos >= stop)
     return E_FILE_FORMAT_INVALID;
 
   return 0;  // success
}
","  if (stop >= 0 && pos >= stop)
"
" void BufferQueueConsumer::dump(String8& result, const char* prefix) const {
    mCore->dump(result, prefix);
 }
","    mCore->dump(result, prefix);
"
" static bool getCoverageFormat4(vector<uint32_t>& coverage, const uint8_t* data, size_t size) {
     const size_t kSegCountOffset = 6;
     const size_t kEndCountOffset = 14;
 const size_t kHeaderSize = 16;
 const size_t kSegmentSize = 8; // total size of array elements for one segment
 if (kEndCountOffset > size) {
 return false;
 }
 size_t segCount = readU16(data, kSegCountOffset) >> 1;
 if (kHeaderSize + segCount * kSegmentSize > size) {

         return false;
     }
     for (size_t i = 0; i < segCount; i++) {
        int end = readU16(data, kEndCountOffset + 2 * i);
        int start = readU16(data, kHeaderSize + 2 * (segCount + i));
        int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));
         if (rangeOffset == 0) {
            int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));
             if (((end + delta) & 0xffff) > end - start) {
                 addRange(coverage, start, end + 1);
             } else {
                for (int j = start; j < end + 1; j++) {
                     if (((j + delta) & 0xffff) != 0) {
                         addRange(coverage, j, j + 1);
                     }
                 }
             }
         } else {
            for (int j = start; j < end + 1; j++) {
                 uint32_t actualRangeOffset = kHeaderSize + 6 * segCount + rangeOffset +
                     (i + j - start) * 2;
                 if (actualRangeOffset + 2 > size) {
                     return false;
                 }
                int glyphId = readU16(data, actualRangeOffset);
                 if (glyphId != 0) {
                     addRange(coverage, j, j + 1);
                 }
 }
 }
 }
 return true;
}
","        int end = readU16(data, kEndCountOffset + 2 * i);
        int start = readU16(data, kHeaderSize + 2 * (segCount + i));
        int rangeOffset = readU16(data, kHeaderSize + 2 * (3 * segCount + i));
            int delta = readU16(data, kHeaderSize + 2 * (2 * segCount + i));
                for (int j = start; j < end + 1; j++) {
            for (int j = start; j < end + 1; j++) {
                int glyphId = readU16(data, actualRangeOffset);
"
"void Segment::AppendCluster(Cluster* pCluster)
{
    assert(pCluster);
    assert(pCluster->m_index >= 0);
 
    const long count = m_clusterCount + m_clusterPreloadCount;
 
    long& size = m_clusterSize;
    assert(size >= count);
 
    const long idx = pCluster->m_index;
    assert(idx == m_clusterCount);
 
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
 
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
 
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
 
        while (p != pp)
            *q++ = *p++;
 
        delete[] m_clusters;
 
        m_clusters = qq;
        size = n;
    }
    if (m_clusterPreloadCount > 0)
    {
        assert(m_clusters);
        Cluster** const p = m_clusters + m_clusterCount;
        assert(*p);
        assert((*p)->m_index < 0);
        Cluster** q = p + m_clusterPreloadCount;
        assert(q < (m_clusters + size));
        for (;;)
        {
            Cluster** const qq = q - 1;
            assert((*qq)->m_index < 0);
            *q = *qq;
            q = qq;
            if (q == p)
                break;
        }
    }
    m_clusters[idx] = pCluster;
    ++m_clusterCount;
}
","{
    assert(pCluster);
    assert(pCluster->m_index >= 0);
    const long count = m_clusterCount + m_clusterPreloadCount;
    long& size = m_clusterSize;
    assert(size >= count);
    const long idx = pCluster->m_index;
    assert(idx == m_clusterCount);
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
        while (p != pp)
            *q++ = *p++;
        delete[] m_clusters;
        m_clusters = qq;
        size = n;
    }
    if (m_clusterPreloadCount > 0)
    {
        assert(m_clusters);
        Cluster** const p = m_clusters + m_clusterCount;
        assert(*p);
        assert((*p)->m_index < 0);
        Cluster** q = p + m_clusterPreloadCount;
        assert(q < (m_clusters + size));
        for (;;)
        {
            Cluster** const qq = q - 1;
            assert((*qq)->m_index < 0);
            *q = *qq;
            q = qq;
            if (q == p)
                break;
        }
    }
    m_clusters[idx] = pCluster;
    ++m_clusterCount;
}
"
"Chapters::Atom::Atom()
{
 }
","{
"
"AudioTrack::AudioTrack(
    Segment* pSegment,
    long long element_start,
    long long element_size) :
    Track(pSegment, element_start, element_size)
{
}
","    Segment* pSegment,
    long long element_start,
    long long element_size) :
    Track(pSegment, element_start, element_size)
{
}
"
"Block::Block(long long start, long long size_, long long discard_padding) :
    m_start(start),
    m_size(size_),
    m_track(0),
    m_timecode(-1),
    m_flags(0),
    m_frames(NULL),
    m_frame_count(-1),
    m_discard_padding(discard_padding)
{
}
","    m_start(start),
    m_size(size_),
    m_track(0),
    m_timecode(-1),
    m_flags(0),
    m_frames(NULL),
    m_frame_count(-1),
    m_discard_padding(discard_padding)
{
}
"
"BlockEntry::BlockEntry(Cluster* p, long idx) :
    m_pCluster(p),
    m_index(idx)
{
 }
","    m_pCluster(p),
    m_index(idx)
{
"
"BlockGroup::BlockGroup(
    Cluster* pCluster,
    long idx,
    long long block_start,
    long long block_size,
    long long prev,
    long long next,
    long long duration,
    long long discard_padding) :
    BlockEntry(pCluster, idx),
    m_block(block_start, block_size, discard_padding),
    m_prev(prev),
    m_next(next),
    m_duration(duration)
{
}
","    Cluster* pCluster,
    long idx,
    long long block_start,
    long long block_size,
    long long prev,
    long long next,
    long long duration,
    long long discard_padding) :
    BlockEntry(pCluster, idx),
    m_block(block_start, block_size, discard_padding),
    m_prev(prev),
    m_next(next),
    m_duration(duration)
{
}
"
"Chapters::Chapters(
    Segment* pSegment,
    long long payload_start,
    long long payload_size,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(payload_start),
    m_size(payload_size),
    m_element_start(element_start),
    m_element_size(element_size),
    m_editions(NULL),
    m_editions_size(0),
    m_editions_count(0)
{
}
","    Segment* pSegment,
    long long payload_start,
    long long payload_size,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(payload_start),
    m_size(payload_size),
    m_element_start(element_start),
    m_element_size(element_size),
    m_editions(NULL),
    m_editions_size(0),
    m_editions_count(0)
{
}
"
"void Chapters::Edition::Clear()
{
    while (m_atoms_count > 0)
    {
        Atom& a = m_atoms[--m_atoms_count];
        a.Clear();
     }
 
    delete[] m_atoms;
    m_atoms = NULL;
 
    m_atoms_size = 0;
 }
","{
    while (m_atoms_count > 0)
    {
        Atom& a = m_atoms[--m_atoms_count];
        a.Clear();
    delete[] m_atoms;
    m_atoms = NULL;
    m_atoms_size = 0;
"
"void Chapters::Atom::Clear()
{
    delete[] m_string_uid;
    m_string_uid = NULL;
    while (m_displays_count > 0)
    {
        Display& d = m_displays[--m_displays_count];
        d.Clear();
    }
    delete[] m_displays;
    m_displays = NULL;
    m_displays_size = 0;
}
","{
    delete[] m_string_uid;
    m_string_uid = NULL;
    while (m_displays_count > 0)
    {
        Display& d = m_displays[--m_displays_count];
        d.Clear();
    }
    delete[] m_displays;
    m_displays = NULL;
    m_displays_size = 0;
}
"
"void Chapters::Display::Clear()
{
    delete[] m_string;
    m_string = NULL;
    delete[] m_language;
    m_language = NULL;
    delete[] m_country;
    m_country = NULL;
}
","{
    delete[] m_string;
    m_string = NULL;
    delete[] m_language;
    m_language = NULL;
    delete[] m_country;
    m_country = NULL;
}
"
"void Track::Info::Clear()
{
    delete[] nameAsUTF8;
    nameAsUTF8 = NULL;
 
    delete[] language;
    language = NULL;
 
    delete[] codecId;
    codecId = NULL;
    delete[] codecPrivate;
    codecPrivate = NULL;
    codecPrivateSize = 0;
    delete[] codecNameAsUTF8;
    codecNameAsUTF8 = NULL;
}
","{
    delete[] nameAsUTF8;
    nameAsUTF8 = NULL;
    delete[] language;
    language = NULL;
    delete[] codecId;
    codecId = NULL;
    delete[] codecPrivate;
    codecPrivate = NULL;
    codecPrivateSize = 0;
    delete[] codecNameAsUTF8;
    codecNameAsUTF8 = NULL;
}
"
"Cluster::Cluster() :
    m_pSegment(NULL),
    m_element_start(0),
    m_index(0),
    m_pos(0),
    m_element_size(0),
    m_timecode(0),
    m_entries(NULL),
    m_entries_size(0),
    m_entries_count(0)  //means ""no entries""
{
}
","    m_pSegment(NULL),
    m_element_start(0),
    m_index(0),
    m_pos(0),
    m_element_size(0),
    m_timecode(0),
    m_entries(NULL),
    m_entries_size(0),
    m_entries_count(0)  //means ""no entries""
{
}
"
"Cluster::Cluster(
    Segment* pSegment,
    long idx,
    long long element_start
    /* long long element_size */ ) :
    m_pSegment(pSegment),
    m_element_start(element_start),
    m_index(idx),
    m_pos(element_start),
    m_element_size(-1 /* element_size */ ),
    m_timecode(-1),
    m_entries(NULL),
    m_entries_size(0),
    m_entries_count(-1)  //means ""has not been parsed yet""
{
}
","    Segment* pSegment,
    long idx,
    long long element_start
    /* long long element_size */ ) :
    m_pSegment(pSegment),
    m_element_start(element_start),
    m_index(idx),
    m_pos(element_start),
    m_element_size(-1 /* element_size */ ),
    m_timecode(-1),
    m_entries(NULL),
    m_entries_size(0),
    m_entries_count(-1)  //means ""has not been parsed yet""
{
}
"
" ContentEncoding::ContentCompression::ContentCompression()
    : algo(0),
      settings(NULL),
      settings_len(0) {
}
","    : algo(0),
      settings(NULL),
      settings_len(0) {
}
"
" ContentEncoding::ContentEncoding()
 : compression_entries_(NULL),
      compression_entries_end_(NULL),
      encryption_entries_(NULL),

       encryption_entries_end_(NULL),
       encoding_order_(0),
       encoding_scope_(1),
      encoding_type_(0) {
}
","      encoding_type_(0) {
}
"
" ContentEncoding::ContentEncryption::ContentEncryption()
 : algo(0),
      key_id(NULL),
      key_id_len(0),
      signature(NULL),
      signature_len(0),

       sig_key_id(NULL),
       sig_key_id_len(0),
       sig_algo(0),
      sig_hash_algo(0) {
}
","      sig_hash_algo(0) {
}
"
"int Track::Info::Copy(Info& dst) const
{
    if (&dst == this)
        return 0;
 
    dst.type = type;
    dst.number = number;
    dst.defaultDuration = defaultDuration;
    dst.codecDelay = codecDelay;
    dst.seekPreRoll = seekPreRoll;
    dst.uid = uid;
    dst.lacing = lacing;
    dst.settings = settings;
 
 
    if (int status = CopyStr(&Info::nameAsUTF8, dst))
        return status;
 
    if (int status = CopyStr(&Info::language, dst))
        return status;
 
    if (int status = CopyStr(&Info::codecId, dst))
        return status;
 
    if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
        return status;
 
    if (codecPrivateSize > 0)
    {
        if (codecPrivate == NULL)
            return -1;
 
        if (dst.codecPrivate)
            return -1;
 
        if (dst.codecPrivateSize != 0)
            return -1;
 
        dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
 
        if (dst.codecPrivate == NULL)
            return -1;
 
        memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
        dst.codecPrivateSize = codecPrivateSize;
     }
 
    return 0;
}
","{
    if (&dst == this)
        return 0;
    dst.type = type;
    dst.number = number;
    dst.defaultDuration = defaultDuration;
    dst.codecDelay = codecDelay;
    dst.seekPreRoll = seekPreRoll;
    dst.uid = uid;
    dst.lacing = lacing;
    dst.settings = settings;
    if (int status = CopyStr(&Info::nameAsUTF8, dst))
        return status;
    if (int status = CopyStr(&Info::language, dst))
        return status;
    if (int status = CopyStr(&Info::codecId, dst))
        return status;
    if (int status = CopyStr(&Info::codecNameAsUTF8, dst))
        return status;
    if (codecPrivateSize > 0)
    {
        if (codecPrivate == NULL)
            return -1;
        if (dst.codecPrivate)
            return -1;
        if (dst.codecPrivateSize != 0)
            return -1;
        dst.codecPrivate = new (std::nothrow) unsigned char[codecPrivateSize];
        if (dst.codecPrivate == NULL)
            return -1;
        memcpy(dst.codecPrivate, codecPrivate, codecPrivateSize);
        dst.codecPrivateSize = codecPrivateSize;
    return 0;
}
"
"int Track::Info::CopyStr(char* Info::*str, Info& dst_) const
{
    if (str == static_cast<char* Info::*>(NULL))
        return -1;
    char*& dst = dst_.*str;
    if (dst)  //should be NULL already
        return -1;
    const char* const src = this->*str;
    if (src == NULL)
        return 0;
    const size_t len = strlen(src);
    dst = new (std::nothrow) char[len+1];
    if (dst == NULL)
        return -1;
    strcpy(dst, src);
     return 0;
 }
","{
    if (str == static_cast<char* Info::*>(NULL))
        return -1;
    char*& dst = dst_.*str;
    if (dst)  //should be NULL already
        return -1;
    const char* const src = this->*str;
    if (src == NULL)
        return 0;
    const size_t len = strlen(src);
    dst = new (std::nothrow) char[len+1];
    if (dst == NULL)
        return -1;
    strcpy(dst, src);
"
"long Track::Create(
    Segment* pSegment,
    const Info& info,
    long long element_start,
    long long element_size,
    Track*& pResult)
{
    if (pResult)
        return -1;
 
    Track* const pTrack = new (std::nothrow) Track(pSegment,
                                                   element_start,
                                                   element_size);
 
    if (pTrack == NULL)
        return -1;  //generic error
 
    const int status = info.Copy(pTrack->m_info);
 
    if (status)  // error
    {
        delete pTrack;
        return status;
    }
 
    pResult = pTrack;
    return 0;  //success
 }
","    Segment* pSegment,
    const Info& info,
    long long element_start,
    long long element_size,
    Track*& pResult)
{
    if (pResult)
        return -1;
    Track* const pTrack = new (std::nothrow) Track(pSegment,
                                                   element_start,
                                                   element_size);
    if (pTrack == NULL)
        return -1;  //generic error
    const int status = info.Copy(pTrack->m_info);
    if (status)  // error
    {
        delete pTrack;
        return status;
    }
    pResult = pTrack;
    return 0;  //success
"
"Cluster* Cluster::Create(
    Segment* pSegment,
    long idx,
    long long off)
{
    assert(pSegment);
    assert(off >= 0);
    const long long element_start = pSegment->m_start + off;
    Cluster* const pCluster = new Cluster(pSegment,
                                          idx,
                                          element_start);
    assert(pCluster);
    return pCluster;
}
","    Segment* pSegment,
    long idx,
    long long off)
{
    assert(pSegment);
    assert(off >= 0);
    const long long element_start = pSegment->m_start + off;
    Cluster* const pCluster = new Cluster(pSegment,
                                          idx,
                                          element_start);
    assert(pCluster);
    return pCluster;
}
"
"long Cluster::CreateBlock(
    long long id,
    long long pos,   //absolute pos of payload
    long long size,
    long long discard_padding)
{
    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock
    if (m_entries_count < 0)  //haven't parsed anything yet
    {
        assert(m_entries == NULL);
        assert(m_entries_size == 0);
        m_entries_size = 1024;
        m_entries = new BlockEntry*[m_entries_size];
        m_entries_count = 0;
    }
    else
    {
        assert(m_entries);
        assert(m_entries_size > 0);
        assert(m_entries_count <= m_entries_size);
        if (m_entries_count >= m_entries_size)
        {
            const long entries_size = 2 * m_entries_size;
            BlockEntry** const entries = new BlockEntry*[entries_size];
            assert(entries);
            BlockEntry** src = m_entries;
            BlockEntry** const src_end = src + m_entries_count;
            BlockEntry** dst = entries;
            while (src != src_end)
                *dst++ = *src++;
            delete[] m_entries;
            m_entries = entries;
            m_entries_size = entries_size;
        }
     }
 
    if (id == 0x20)  //BlockGroup ID
        return CreateBlockGroup(pos, size, discard_padding);
    else  //SimpleBlock ID
        return CreateSimpleBlock(pos, size);
 }
","    long long id,
    long long pos,   //absolute pos of payload
    long long size,
    long long discard_padding)
{
    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock
    if (m_entries_count < 0)  //haven't parsed anything yet
    {
        assert(m_entries == NULL);
        assert(m_entries_size == 0);
        m_entries_size = 1024;
        m_entries = new BlockEntry*[m_entries_size];
        m_entries_count = 0;
    }
    else
    {
        assert(m_entries);
        assert(m_entries_size > 0);
        assert(m_entries_count <= m_entries_size);
        if (m_entries_count >= m_entries_size)
        {
            const long entries_size = 2 * m_entries_size;
            BlockEntry** const entries = new BlockEntry*[entries_size];
            assert(entries);
            BlockEntry** src = m_entries;
            BlockEntry** const src_end = src + m_entries_count;
            BlockEntry** dst = entries;
            while (src != src_end)
                *dst++ = *src++;
            delete[] m_entries;
            m_entries = entries;
            m_entries_size = entries_size;
        }
    if (id == 0x20)  //BlockGroup ID
        return CreateBlockGroup(pos, size, discard_padding);
    else  //SimpleBlock ID
        return CreateSimpleBlock(pos, size);
"
"long Cluster::CreateSimpleBlock(
    long long st,
    long long sz)
{
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count >= 0);
    assert(m_entries_count < m_entries_size);
    const long idx = m_entries_count;
    BlockEntry** const ppEntry = m_entries + idx;
    BlockEntry*& pEntry = *ppEntry;
    pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);
    if (pEntry == NULL)
        return -1;  //generic error
    SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);
    const long status = p->Parse();
    if (status == 0)
    {
        ++m_entries_count;
        return 0;
    }
    delete pEntry;
    pEntry = 0;
    return status;
}
","    long long st,
    long long sz)
{
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count >= 0);
    assert(m_entries_count < m_entries_size);
    const long idx = m_entries_count;
    BlockEntry** const ppEntry = m_entries + idx;
    BlockEntry*& pEntry = *ppEntry;
    pEntry = new (std::nothrow) SimpleBlock(this, idx, st, sz);
    if (pEntry == NULL)
        return -1;  //generic error
    SimpleBlock* const p = static_cast<SimpleBlock*>(pEntry);
    const long status = p->Parse();
    if (status == 0)
    {
        ++m_entries_count;
        return 0;
    }
    delete pEntry;
    pEntry = 0;
    return status;
}
"
"CuePoint::CuePoint(long idx, long long pos) :
    m_element_start(0),
    m_element_size(0),
    m_index(idx),
    m_timecode(-1 * pos),
    m_track_positions(NULL),
    m_track_positions_count(0)
{
    assert(pos > 0);
 }
","    m_element_start(0),
    m_element_size(0),
    m_index(idx),
    m_timecode(-1 * pos),
    m_track_positions(NULL),
    m_track_positions_count(0)
{
    assert(pos > 0);
"
"Cues::Cues(
    Segment* pSegment,
    long long start_,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start_),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_cue_points(NULL),
    m_count(0),
    m_preload_count(0),
    m_pos(start_)
{
 }
","    Segment* pSegment,
    long long start_,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start_),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_cue_points(NULL),
    m_count(0),
    m_preload_count(0),
    m_pos(start_)
{
"
"Chapters::Display::Display()
{
}
","{
}
"
"bool Cues::DoneParsing() const
{
    const long long stop = m_start + m_size;
    return (m_pos >= stop);
}
","{
    const long long stop = m_start + m_size;
    return (m_pos >= stop);
}
"
"bool Segment::DoneParsing() const
{
    if (m_size < 0)
    {
        long long total, avail;
 
        const int status = m_pReader->Length(&total, &avail);
 
        if (status < 0)  //error
            return true;  //must assume done
 
        if (total < 0)
            return false;  //assume live stream
 
        return (m_pos >= total);
    }
 
    const long long stop = m_start + m_size;
 
    return (m_pos >= stop);
 }
","{
    if (m_size < 0)
    {
        long long total, avail;
        const int status = m_pReader->Length(&total, &avail);
        if (status < 0)  //error
            return true;  //must assume done
        if (total < 0)
            return false;  //assume live stream
        return (m_pos >= total);
    }
    const long long stop = m_start + m_size;
    return (m_pos >= stop);
"
"EBMLHeader::EBMLHeader() :
    m_docType(NULL)
{
    Init();
}
","    m_docType(NULL)
{
    Init();
}
"
"bool Cluster::EOS() const
//// long long element_size)
 {
    return (m_pSegment == NULL);
 }
","    return (m_pSegment == NULL);
"
"bool BlockEntry::EOS() const
{
    return (GetKind() == kBlockEOS);
}
","{
    return (GetKind() == kBlockEOS);
}
"
"Track::EOSBlock::EOSBlock() :
    BlockEntry(NULL, LONG_MIN)
{
}
","    BlockEntry(NULL, LONG_MIN)
{
}
"
"Chapters::Edition::Edition()
{
 }
","{
"
"bool Chapters::Edition::ExpandAtomsArray()
{
    if (m_atoms_size > m_atoms_count)
        return true;  // nothing else to do
 
    const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;
 
    Atom* const atoms = new (std::nothrow) Atom[size];
 
    if (atoms == NULL)
        return false;
 
    for (int idx = 0; idx < m_atoms_count; ++idx)
    {
        m_atoms[idx].ShallowCopy(atoms[idx]);
     }
 
    delete[] m_atoms;
    m_atoms = atoms;
 
    m_atoms_size = size;
    return true;
 }
","{
    if (m_atoms_size > m_atoms_count)
        return true;  // nothing else to do
    const int size = (m_atoms_size == 0) ? 1 : 2 * m_atoms_size;
    Atom* const atoms = new (std::nothrow) Atom[size];
    if (atoms == NULL)
        return false;
    for (int idx = 0; idx < m_atoms_count; ++idx)
    {
        m_atoms[idx].ShallowCopy(atoms[idx]);
    delete[] m_atoms;
    m_atoms = atoms;
    m_atoms_size = size;
    return true;
"
"bool Chapters::Atom::ExpandDisplaysArray()
{
    if (m_displays_size > m_displays_count)
        return true;  // nothing else to do
    const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;
    Display* const displays = new (std::nothrow) Display[size];
    if (displays == NULL)
        return false;
    for (int idx = 0; idx < m_displays_count; ++idx)
    {
        m_displays[idx].ShallowCopy(displays[idx]);
    }
    delete[] m_displays;
    m_displays = displays;
    m_displays_size = size;
    return true;
}
","{
    if (m_displays_size > m_displays_count)
        return true;  // nothing else to do
    const int size = (m_displays_size == 0) ? 1 : 2 * m_displays_size;
    Display* const displays = new (std::nothrow) Display[size];
    if (displays == NULL)
        return false;
    for (int idx = 0; idx < m_displays_count; ++idx)
    {
        m_displays[idx].ShallowCopy(displays[idx]);
    }
    delete[] m_displays;
    m_displays = displays;
    m_displays_size = size;
    return true;
}
"
"bool Chapters::ExpandEditionsArray()
{
    if (m_editions_size > m_editions_count)
        return true;  // nothing else to do
 
    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;
 
    Edition* const editions = new (std::nothrow) Edition[size];
 
    if (editions == NULL)
        return false;
 
    for (int idx = 0; idx < m_editions_count; ++idx)
    {
        m_editions[idx].ShallowCopy(editions[idx]);
     }
 
    delete[] m_editions;
    m_editions = editions;
 
    m_editions_size = size;
    return true;
 }
","{
    if (m_editions_size > m_editions_count)
        return true;  // nothing else to do
    const int size = (m_editions_size == 0) ? 1 : 2 * m_editions_size;
    Edition* const editions = new (std::nothrow) Edition[size];
    if (editions == NULL)
        return false;
    for (int idx = 0; idx < m_editions_count; ++idx)
    {
        m_editions[idx].ShallowCopy(editions[idx]);
    delete[] m_editions;
    m_editions = editions;
    m_editions_size = size;
    return true;
"
"const CuePoint::TrackPosition* CuePoint::Find(const Track* pTrack) const
{
    assert(pTrack);
 
    const long long n = pTrack->GetNumber();
 
    const TrackPosition* i = m_track_positions;
    const TrackPosition* const j = i + m_track_positions_count;
 
    while (i != j)
    {
        const TrackPosition& p = *i++;
 
        if (p.m_track == n)
            return &p;
    }
    return NULL;  //no matching track number found
 }
","{
    assert(pTrack);
    const long long n = pTrack->GetNumber();
    const TrackPosition* i = m_track_positions;
    const TrackPosition* const j = i + m_track_positions_count;
    while (i != j)
    {
        const TrackPosition& p = *i++;
        if (p.m_track == n)
            return &p;
    }
    return NULL;  //no matching track number found
"
"const Cluster* Segment::FindCluster(long long time_ns) const
{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
        return &m_eos;
 
    {
        Cluster* const pCluster = m_clusters[0];
        assert(pCluster);
        assert(pCluster->m_index == 0);
 
        if (time_ns <= pCluster->GetTime())
            return pCluster;
    }
 
 
    long i = 0;
    long j = m_clusterCount;
 
    while (i < j)
    {
        const long k = i + (j - i) / 2;
        assert(k < m_clusterCount);
        Cluster* const pCluster = m_clusters[k];
        assert(pCluster);
        assert(pCluster->m_index == k);
        const long long t = pCluster->GetTime();
        if (t <= time_ns)
            i = k + 1;
        else
            j = k;
        assert(i <= j);
    }
    assert(i == j);
    assert(i > 0);
    assert(i <= m_clusterCount);
    const long k = i - 1;
 
     Cluster* const pCluster = m_clusters[k];
     assert(pCluster);
     assert(pCluster->m_index == k);
    assert(pCluster->GetTime() <= time_ns);
 
    return pCluster;
 }
","{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
        return &m_eos;
    {
        Cluster* const pCluster = m_clusters[0];
        assert(pCluster);
        assert(pCluster->m_index == 0);
        if (time_ns <= pCluster->GetTime())
            return pCluster;
    }
    long i = 0;
    long j = m_clusterCount;
    while (i < j)
    {
        const long k = i + (j - i) / 2;
        assert(k < m_clusterCount);
        Cluster* const pCluster = m_clusters[k];
        assert(pCluster);
        assert(pCluster->m_index == k);
        const long long t = pCluster->GetTime();
        if (t <= time_ns)
            i = k + 1;
        else
            j = k;
        assert(i <= j);
    }
    assert(i == j);
    assert(i > 0);
    assert(i <= m_clusterCount);
    const long k = i - 1;
    assert(pCluster->GetTime() <= time_ns);
    return pCluster;
"
"const Cluster* Segment::FindOrPreloadCluster(long long requested_pos)
{
    if (requested_pos < 0)
        return 0;
 
    Cluster** const ii = m_clusters;
    Cluster** i = ii;
 
    const long count = m_clusterCount + m_clusterPreloadCount;
 
    Cluster** const jj = ii + count;
    Cluster** j = jj;
 
    while (i < j)
    {
 
        Cluster** const k = i + (j - i) / 2;
        assert(k < jj);
        Cluster* const pCluster = *k;
        assert(pCluster);
        const long long pos = pCluster->GetPosition();
        assert(pos >= 0);
        if (pos < requested_pos)
            i = k + 1;
        else if (pos > requested_pos)
            j = k;
        else
            return pCluster;
    }
    assert(i == j);
    Cluster* const pCluster = Cluster::Create(
                                this,
                                -1,
                                requested_pos);
     assert(pCluster);
 
    const ptrdiff_t idx = i - m_clusters;
 
    PreloadCluster(pCluster, idx);
    assert(m_clusters);
    assert(m_clusterPreloadCount > 0);
    assert(m_clusters[idx] == pCluster);
 
    return pCluster;
 }
","{
    if (requested_pos < 0)
        return 0;
    Cluster** const ii = m_clusters;
    Cluster** i = ii;
    const long count = m_clusterCount + m_clusterPreloadCount;
    Cluster** const jj = ii + count;
    Cluster** j = jj;
    while (i < j)
    {
        Cluster** const k = i + (j - i) / 2;
        assert(k < jj);
        Cluster* const pCluster = *k;
        assert(pCluster);
        const long long pos = pCluster->GetPosition();
        assert(pos >= 0);
        if (pos < requested_pos)
            i = k + 1;
        else if (pos > requested_pos)
            j = k;
        else
            return pCluster;
    }
    assert(i == j);
    Cluster* const pCluster = Cluster::Create(
                                this,
                                -1,
                                requested_pos);
    const ptrdiff_t idx = i - m_clusters;
    PreloadCluster(pCluster, idx);
    assert(m_clusters);
    assert(m_clusterPreloadCount > 0);
    assert(m_clusters[idx] == pCluster);
    return pCluster;
"
"const Chapters::Atom* Chapters::Edition::GetAtom(int index) const
{
    if (index < 0)
        return NULL;
 
    if (index >= m_atoms_count)
        return NULL;
 
    return m_atoms + index;
 }
","{
    if (index < 0)
        return NULL;
    if (index >= m_atoms_count)
        return NULL;
    return m_atoms + index;
"
"int Chapters::Edition::GetAtomCount() const
{
    return m_atoms_count;
 }
","{
    return m_atoms_count;
"
"long long AudioTrack::GetBitDepth() const
{
    return m_bitDepth;
}
","{
    return m_bitDepth;
}
"
"const Block* Track::EOSBlock::GetBlock() const
{
    return NULL;
}
","{
    return NULL;
}
"
"const Block* SimpleBlock::GetBlock() const
{
    return &m_block;
}
","{
    return &m_block;
}
"
"const Block* BlockGroup::GetBlock() const
{
    return &m_block;
}
","{
    return &m_block;
}
"
"const BlockEntry* Cues::GetBlock(
    const CuePoint* pCP,
    const CuePoint::TrackPosition* pTP) const
{
    if (pCP == NULL)
        return NULL;
 
    if (pTP == NULL)
        return NULL;
    return m_pSegment->GetBlock(*pCP, *pTP);
 }
","    const CuePoint* pCP,
    const CuePoint::TrackPosition* pTP) const
{
    if (pCP == NULL)
        return NULL;
    if (pTP == NULL)
        return NULL;
    return m_pSegment->GetBlock(*pCP, *pTP);
"
"const BlockEntry* Segment::GetBlock(
    const CuePoint& cp,
    const CuePoint::TrackPosition& tp)
{
    Cluster** const ii = m_clusters;
    Cluster** i = ii;
 
    const long count = m_clusterCount + m_clusterPreloadCount;
 
    Cluster** const jj = ii + count;
    Cluster** j = jj;
 
    while (i < j)
    {
 
        Cluster** const k = i + (j - i) / 2;
        assert(k < jj);
        Cluster* const pCluster = *k;
        assert(pCluster);
        const long long pos = pCluster->GetPosition();
        assert(pos >= 0);
        if (pos < tp.m_pos)
            i = k + 1;
        else if (pos > tp.m_pos)
            j = k;
        else
            return pCluster->GetEntry(cp, tp);
    }
    assert(i == j);
    Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos); //, -1);
     assert(pCluster);
 
    const ptrdiff_t idx = i - m_clusters;
 
    PreloadCluster(pCluster, idx);
    assert(m_clusters);
    assert(m_clusterPreloadCount > 0);
    assert(m_clusters[idx] == pCluster);
 
    return pCluster->GetEntry(cp, tp);
 }
","    const CuePoint& cp,
    const CuePoint::TrackPosition& tp)
{
    Cluster** const ii = m_clusters;
    Cluster** i = ii;
    const long count = m_clusterCount + m_clusterPreloadCount;
    Cluster** const jj = ii + count;
    Cluster** j = jj;
    while (i < j)
    {
        Cluster** const k = i + (j - i) / 2;
        assert(k < jj);
        Cluster* const pCluster = *k;
        assert(pCluster);
        const long long pos = pCluster->GetPosition();
        assert(pos >= 0);
        if (pos < tp.m_pos)
            i = k + 1;
        else if (pos > tp.m_pos)
            j = k;
        else
            return pCluster->GetEntry(cp, tp);
    }
    assert(i == j);
    Cluster* const pCluster = Cluster::Create(this, -1, tp.m_pos); //, -1);
    const ptrdiff_t idx = i - m_clusters;
    PreloadCluster(pCluster, idx);
    assert(m_clusters);
    assert(m_clusterPreloadCount > 0);
    assert(m_clusters[idx] == pCluster);
    return pCluster->GetEntry(cp, tp);
"
"long long AudioTrack::GetChannels() const
{
    return m_channels;
 }
","{
    return m_channels;
"
"const Chapters* Segment::GetChapters() const
{
  return m_pChapters;
}
","{
  return m_pChapters;
}
"
"const Cluster* BlockEntry::GetCluster() const
{
    return m_pCluster;
}
","{
    return m_pCluster;
}
"
"unsigned long long Track::GetCodecDelay() const
{
    return m_info.codecDelay;
}
","{
    return m_info.codecDelay;
}
"
"const char* Track::GetCodecId() const
{
    return m_info.codecId;
}
","{
    return m_info.codecId;
}
"
"const char* Track::GetCodecNameAsUTF8() const
{
    return m_info.codecNameAsUTF8;
}
","{
    return m_info.codecNameAsUTF8;
}
"
"const unsigned char* Track::GetCodecPrivate(size_t& size) const
{
    size = m_info.codecPrivateSize;
    return m_info.codecPrivate;
}
","{
    size = m_info.codecPrivateSize;
    return m_info.codecPrivate;
}
"
"int SeekHead::GetCount() const
{
    return m_entry_count;
 }
","{
    return m_entry_count;
"
"long Cues::GetCount() const
{
    if (m_cue_points == NULL)
        return -1;
 
    return m_count;  //TODO: really ignore preload count?
}
","{
    if (m_cue_points == NULL)
        return -1;
    return m_count;  //TODO: really ignore preload count?
}
"
"unsigned long Segment::GetCount() const
{
    return m_clusterCount;
}
","{
    return m_clusterCount;
}
"
"const char* Chapters::Display::GetCountry() const
{
    return m_country;
}
","{
    return m_country;
}
"
"const Cues* Segment::GetCues() const
{
    return m_pCues;
}
","{
    return m_pCues;
}
"
"unsigned long long Track::GetDefaultDuration() const
{
    return m_info.defaultDuration;
}
","{
    return m_info.defaultDuration;
}
"
"long long Block::GetDiscardPadding() const
{
    return m_discard_padding;
}
","{
    return m_discard_padding;
}
"
"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}
","{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}
"
"int Chapters::Atom::GetDisplayCount() const
{
    return m_displays_count;
}
","{
    return m_displays_count;
}
"
"long long Segment::GetDuration() const
{
    assert(m_pInfo);
    return m_pInfo->GetDuration();
}
","{
    assert(m_pInfo);
    return m_pInfo->GetDuration();
}
"
"long long SegmentInfo::GetDuration() const
{
    if (m_duration < 0)
        return -1;
    assert(m_timecodeScale >= 1);
    const double dd = double(m_duration) * double(m_timecodeScale);
    const long long d = static_cast<long long>(dd);
    return d;
}
","{
    if (m_duration < 0)
        return -1;
    assert(m_timecodeScale >= 1);
    const double dd = double(m_duration) * double(m_timecodeScale);
    const long long d = static_cast<long long>(dd);
    return d;
}
"
"long long BlockGroup::GetDurationTimeCode() const
{
    return m_duration;
}
","{
    return m_duration;
}
"
"const BlockEntry* Track::GetEOS() const
{
    return &m_eos;
}
","{
    return &m_eos;
}
"
"const Chapters::Edition* Chapters::GetEdition(int idx) const
{
    if (idx < 0)
        return NULL;
 
    if (idx >= m_editions_count)
        return NULL;
 
    return m_editions + idx;
 }
","{
    if (idx < 0)
        return NULL;
    if (idx >= m_editions_count)
        return NULL;
    return m_editions + idx;
"
"int Chapters::GetEditionCount() const
{
    return m_editions_count;
 }
","{
    return m_editions_count;
"
"long long Cluster::GetElementSize() const
{
    return m_element_size;
}
","{
    return m_element_size;
}
"
"long Cluster::GetEntry(long index, const mkvparser::BlockEntry*& pEntry) const
{
    assert(m_pos >= m_element_start);
    pEntry = NULL;
    if (index < 0)
        return -1;  //generic error
    if (m_entries_count < 0)
        return E_BUFFER_NOT_FULL;
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count <= m_entries_size);
    if (index < m_entries_count)
    {
        pEntry = m_entries[index];
        assert(pEntry);
        return 1;  //found entry
     }
 
    if (m_element_size < 0)        //we don't know cluster end yet
        return E_BUFFER_NOT_FULL;  //underflow
 
    const long long element_stop = m_element_start + m_element_size;
 
    if (m_pos >= element_stop)
        return 0;  //nothing left to parse
    return E_BUFFER_NOT_FULL;  //underflow, since more remains to be parsed
}
","{
    assert(m_pos >= m_element_start);
    pEntry = NULL;
    if (index < 0)
        return -1;  //generic error
    if (m_entries_count < 0)
        return E_BUFFER_NOT_FULL;
    assert(m_entries);
    assert(m_entries_size > 0);
    assert(m_entries_count <= m_entries_size);
    if (index < m_entries_count)
    {
        pEntry = m_entries[index];
        assert(pEntry);
        return 1;  //found entry
    if (m_element_size < 0)        //we don't know cluster end yet
        return E_BUFFER_NOT_FULL;  //underflow
    const long long element_stop = m_element_start + m_element_size;
    if (m_pos >= element_stop)
        return 0;  //nothing left to parse
    return E_BUFFER_NOT_FULL;  //underflow, since more remains to be parsed
}
"
"const SeekHead::Entry* SeekHead::GetEntry(int idx) const
{
    if (idx < 0)
        return 0;
    if (idx >= m_entry_count)
        return 0;
    return m_entries + idx;
}
","{
    if (idx < 0)
        return 0;
    if (idx >= m_entry_count)
        return 0;
    return m_entries + idx;
}
"
"long Cluster::GetEntryCount() const
{
    return m_entries_count;
}
","{
    return m_entries_count;
}
"
"long Track::GetFirst(const BlockEntry*& pBlockEntry) const
{
    const Cluster* pCluster = m_pSegment->GetFirst();
    for (int i = 0; ; )
    {
        if (pCluster == NULL)
        {
            pBlockEntry = GetEOS();
            return 1;
        }
        if (pCluster->EOS())
        {
 #if 0
            if (m_pSegment->Unparsed() <= 0)  //all clusters have been loaded
            {
                 pBlockEntry = GetEOS();
                 return 1;
             }
 #else
            if (m_pSegment->DoneParsing())
            {
                pBlockEntry = GetEOS();
                return 1;
            }
 #endif
 
            pBlockEntry = 0;
            return E_BUFFER_NOT_FULL;
        }
        long status = pCluster->GetFirst(pBlockEntry);
        if (status < 0)  //error
            return status;
        if (pBlockEntry == 0)  //empty cluster
        {
            pCluster = m_pSegment->GetNext(pCluster);
            continue;
        }
        for (;;)
        {
            const Block* const pBlock = pBlockEntry->GetBlock();
            assert(pBlock);
            const long long tn = pBlock->GetTrackNumber();
            if ((tn == m_info.number) && VetEntry(pBlockEntry))
                return 0;
            const BlockEntry* pNextEntry;
            status = pCluster->GetNext(pBlockEntry, pNextEntry);
            if (status < 0)  //error
                return status;
            if (pNextEntry == 0)
                break;
            pBlockEntry = pNextEntry;
        }
        ++i;
        if (i >= 100)
            break;
        pCluster = m_pSegment->GetNext(pCluster);
     }
 
 
    pBlockEntry = GetEOS();  //so we can return a non-NULL value
    return 1;
}
","{
    const Cluster* pCluster = m_pSegment->GetFirst();
    for (int i = 0; ; )
    {
        if (pCluster == NULL)
        {
            pBlockEntry = GetEOS();
            return 1;
        }
        if (pCluster->EOS())
        {
            if (m_pSegment->Unparsed() <= 0)  //all clusters have been loaded
            {
            if (m_pSegment->DoneParsing())
            {
                pBlockEntry = GetEOS();
                return 1;
            }
            pBlockEntry = 0;
            return E_BUFFER_NOT_FULL;
        }
        long status = pCluster->GetFirst(pBlockEntry);
        if (status < 0)  //error
            return status;
        if (pBlockEntry == 0)  //empty cluster
        {
            pCluster = m_pSegment->GetNext(pCluster);
            continue;
        }
        for (;;)
        {
            const Block* const pBlock = pBlockEntry->GetBlock();
            assert(pBlock);
            const long long tn = pBlock->GetTrackNumber();
            if ((tn == m_info.number) && VetEntry(pBlockEntry))
                return 0;
            const BlockEntry* pNextEntry;
            status = pCluster->GetNext(pBlockEntry, pNextEntry);
            if (status < 0)  //error
                return status;
            if (pNextEntry == 0)
                break;
            pBlockEntry = pNextEntry;
        }
        ++i;
        if (i >= 100)
            break;
        pCluster = m_pSegment->GetNext(pCluster);
    pBlockEntry = GetEOS();  //so we can return a non-NULL value
    return 1;
}
"
"long Cluster::GetFirst(const BlockEntry*& pFirst) const
{
    if (m_entries_count <= 0)
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pFirst = NULL;
            return status;
        }
        if (m_entries_count <= 0)  //empty cluster
        {
            pFirst = NULL;
            return 0;
        }
    }
    assert(m_entries);
    pFirst = m_entries[0];
    assert(pFirst);
    return 0;  //success
}
","{
    if (m_entries_count <= 0)
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pFirst = NULL;
            return status;
        }
        if (m_entries_count <= 0)  //empty cluster
        {
            pFirst = NULL;
            return 0;
        }
    }
    assert(m_entries);
    pFirst = m_entries[0];
    assert(pFirst);
    return 0;  //success
}
"
"const CuePoint* Cues::GetFirst() const
{
    if (m_cue_points == NULL)
        return NULL;
    if (m_count == 0)
        return NULL;
 
 #if 0
     LoadCuePoint();  //init cues

 const size_t count = m_count + m_preload_count;

 if (count == 0) //weird

         return NULL;
 #endif
 
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
 
    CuePoint* const pCP = pp[0];
    assert(pCP);
    assert(pCP->GetTimeCode() >= 0);
 
    return pCP;
 }
","{
    if (m_cue_points == NULL)
        return NULL;
    if (m_count == 0)
        return NULL;
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    CuePoint* const pCP = pp[0];
    assert(pCP);
    assert(pCP->GetTimeCode() >= 0);
    return pCP;
"
"const Cluster* Segment::GetFirst() const
{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
       return &m_eos;
 
    Cluster* const pCluster = m_clusters[0];
    assert(pCluster);
    return pCluster;
 }
","{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
       return &m_eos;
    Cluster* const pCluster = m_clusters[0];
    assert(pCluster);
    return pCluster;
"
"long long Cluster::GetFirstTime() const
{
    const BlockEntry* pEntry;
    const long status = GetFirst(pEntry);
    if (status < 0)  //error
        return status;
    if (pEntry == NULL)  //empty cluster
        return GetTime();
    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);
    return pBlock->GetTime(this);
}
","{
    const BlockEntry* pEntry;
    const long status = GetFirst(pEntry);
    if (status < 0)  //error
        return status;
    if (pEntry == NULL)  //empty cluster
        return GetTime();
    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);
    return pBlock->GetTime(this);
}
"
"const Block::Frame& Block::GetFrame(int idx) const
{
    assert(idx >= 0);
    assert(idx < m_frame_count);
    const Frame& f = m_frames[idx];
    assert(f.pos > 0);
    assert(f.len > 0);
    return f;
}
","{
    assert(idx >= 0);
    assert(idx < m_frame_count);
    const Frame& f = m_frames[idx];
    assert(f.pos > 0);
    assert(f.len > 0);
    return f;
}
"
"int Block::GetFrameCount() const
{
    return m_frame_count;
}
","{
    return m_frame_count;
}
"
"double VideoTrack::GetFrameRate() const
{
    return m_rate;
}
","{
    return m_rate;
}
"
"long long VideoTrack::GetHeight() const
{
    return m_height;
}
","{
    return m_height;
}
"
"long Cluster::GetIndex() const
{
    return m_index;
 }
","{
    return m_index;
"
"long BlockEntry::GetIndex() const
{
    return m_index;
}
","{
    return m_index;
}
"
"const SegmentInfo* Segment::GetInfo() const
{
    return m_pInfo;
 }
","{
    return m_pInfo;
"
"BlockEntry::Kind Track::EOSBlock::GetKind() const
{
    return kBlockEOS;
}
","{
    return kBlockEOS;
}
"
"BlockEntry::Kind SimpleBlock::GetKind() const
{
    return kBlockSimple;
}
","{
    return kBlockSimple;
}
"
"BlockEntry::Kind BlockGroup::GetKind() const
{
    return kBlockGroup;
}
","{
    return kBlockGroup;
}
"
"bool Track::GetLacing() const
{
    return m_info.lacing;
}
","{
    return m_info.lacing;
}
"
"Block::Lacing Block::GetLacing() const
{
    const int value = int(m_flags & 0x06) >> 1;
    return static_cast<Lacing>(value);
 }
","{
    const int value = int(m_flags & 0x06) >> 1;
    return static_cast<Lacing>(value);
"
"const char* Chapters::Display::GetLanguage() const
{
    return m_language;
}
","{
    return m_language;
}
"
"const char* Track::GetLanguage() const
{
    return m_info.language;
}
","{
    return m_info.language;
}
"
"long Cluster::GetLast(const BlockEntry*& pLast) const
{
    for (;;)
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pLast = NULL;
            return status;
        }
        if (status > 0)  //no new block
            break;
    }
    if (m_entries_count <= 0)
    {
        pLast = NULL;
        return 0;
    }
    assert(m_entries);
    const long idx = m_entries_count - 1;
    pLast = m_entries[idx];
    assert(pLast);
     return 0;
 }
","{
    for (;;)
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pLast = NULL;
            return status;
        }
        if (status > 0)  //no new block
            break;
    }
    if (m_entries_count <= 0)
    {
        pLast = NULL;
        return 0;
    }
    assert(m_entries);
    const long idx = m_entries_count - 1;
    pLast = m_entries[idx];
    assert(pLast);
"
"const CuePoint* Cues::GetLast() const
{
    if (m_cue_points == NULL)
        return NULL;
    if (m_count <= 0)
        return NULL;
 
 #if 0
     LoadCuePoint();  //init cues

 const size_t count = m_count + m_preload_count;

 if (count == 0) //weird
 return NULL;

 const size_t index = count - 1;

 CuePoint* const* const pp = m_cue_points;
    assert(pp);

 CuePoint* const pCP = pp[index];
    assert(pCP);


     pCP->Load(m_pSegment->m_pReader);
     assert(pCP->GetTimeCode() >= 0);
 #else
    const long index = m_count - 1;
 
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
 
    CuePoint* const pCP = pp[index];
    assert(pCP);
    assert(pCP->GetTimeCode() >= 0);
 #endif
 
    return pCP;
 }
","{
    if (m_cue_points == NULL)
        return NULL;
    if (m_count <= 0)
        return NULL;
    const long index = m_count - 1;
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    CuePoint* const pCP = pp[index];
    assert(pCP);
    assert(pCP->GetTimeCode() >= 0);
    return pCP;
"
"const Cluster* Segment::GetLast() const
{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
        return &m_eos;
 
    const long idx = m_clusterCount - 1;
 
    Cluster* const pCluster = m_clusters[idx];
    assert(pCluster);
    return pCluster;
 }
","{
    if ((m_clusters == NULL) || (m_clusterCount <= 0))
        return &m_eos;
    const long idx = m_clusterCount - 1;
    Cluster* const pCluster = m_clusters[idx];
    assert(pCluster);
    return pCluster;
"
"long long Cluster::GetLastTime() const
{
    const BlockEntry* pEntry;
    const long status = GetLast(pEntry);
    if (status < 0)  //error
        return status;
    if (pEntry == NULL)  //empty cluster
        return GetTime();
    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);
    return pBlock->GetTime(this);
}
","{
    const BlockEntry* pEntry;
    const long status = GetLast(pEntry);
    if (status < 0)  //error
        return status;
    if (pEntry == NULL)  //empty cluster
        return GetTime();
    const Block* const pBlock = pEntry->GetBlock();
    assert(pBlock);
    return pBlock->GetTime(this);
}
"
"const char* SegmentInfo::GetMuxingAppAsUTF8() const
{
    return m_pMuxingAppAsUTF8;
}
","{
    return m_pMuxingAppAsUTF8;
}
"
"const char* Track::GetNameAsUTF8() const
{
    return m_info.nameAsUTF8;
}
","{
    return m_info.nameAsUTF8;
}
"
"long Track::GetNext(
    const BlockEntry* pCurrEntry,
    const BlockEntry*& pNextEntry) const
{
    assert(pCurrEntry);
    assert(!pCurrEntry->EOS());  //?
 
    const Block* const pCurrBlock = pCurrEntry->GetBlock();
    assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
    if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
        return -1;
 
    const Cluster* pCluster = pCurrEntry->GetCluster();
    assert(pCluster);
    assert(!pCluster->EOS());
 
    long status = pCluster->GetNext(pCurrEntry, pNextEntry);
 
    if (status < 0)  //error
         return status;
 
    for (int i = 0; ; )
    {
        while (pNextEntry)
        {
            const Block* const pNextBlock = pNextEntry->GetBlock();
            assert(pNextBlock);
 
            if (pNextBlock->GetTrackNumber() == m_info.number)
                return 0;
 
            pCurrEntry = pNextEntry;
 
            status = pCluster->GetNext(pCurrEntry, pNextEntry);
 
            if (status < 0) //error
                return status;
        }
 
        pCluster = m_pSegment->GetNext(pCluster);
 
        if (pCluster == NULL)
        {
            pNextEntry = GetEOS();
            return 1;
        }
 
        if (pCluster->EOS())
        {
 #if 0
             if (m_pSegment->Unparsed() <= 0)   //all clusters have been loaded
             {
                pNextEntry = GetEOS();

                 return 1;
             }
 #else
            if (m_pSegment->DoneParsing())
            {
                pNextEntry = GetEOS();
                return 1;
            }
 #endif
 
 
            pNextEntry = NULL;
            return E_BUFFER_NOT_FULL;
        }
        status = pCluster->GetFirst(pNextEntry);
        if (status < 0)  //error
            return status;
        if (pNextEntry == NULL)  //empty cluster
            continue;
        ++i;
        if (i >= 100)
            break;
     }
 
 
    pNextEntry = GetEOS();  //so we can return a non-NULL value
    return 1;
 }
","    const BlockEntry* pCurrEntry,
    const BlockEntry*& pNextEntry) const
{
    assert(pCurrEntry);
    assert(!pCurrEntry->EOS());  //?
    const Block* const pCurrBlock = pCurrEntry->GetBlock();
    assert(pCurrBlock && pCurrBlock->GetTrackNumber() == m_info.number);
    if (!pCurrBlock || pCurrBlock->GetTrackNumber() != m_info.number)
        return -1;
    const Cluster* pCluster = pCurrEntry->GetCluster();
    assert(pCluster);
    assert(!pCluster->EOS());
    long status = pCluster->GetNext(pCurrEntry, pNextEntry);
    if (status < 0)  //error
    for (int i = 0; ; )
    {
        while (pNextEntry)
        {
            const Block* const pNextBlock = pNextEntry->GetBlock();
            assert(pNextBlock);
            if (pNextBlock->GetTrackNumber() == m_info.number)
                return 0;
            pCurrEntry = pNextEntry;
            status = pCluster->GetNext(pCurrEntry, pNextEntry);
            if (status < 0) //error
                return status;
        }
        pCluster = m_pSegment->GetNext(pCluster);
        if (pCluster == NULL)
        {
            pNextEntry = GetEOS();
            return 1;
        }
        if (pCluster->EOS())
        {
            if (m_pSegment->DoneParsing())
            {
                pNextEntry = GetEOS();
                return 1;
            }
            pNextEntry = NULL;
            return E_BUFFER_NOT_FULL;
        }
        status = pCluster->GetFirst(pNextEntry);
        if (status < 0)  //error
            return status;
        if (pNextEntry == NULL)  //empty cluster
            continue;
        ++i;
        if (i >= 100)
            break;
    pNextEntry = GetEOS();  //so we can return a non-NULL value
    return 1;
"
"long Cluster::GetNext(
    const BlockEntry* pCurr,
    const BlockEntry*& pNext) const
{
    assert(pCurr);
     assert(m_entries);
     assert(m_entries_count > 0);
    size_t idx = pCurr->GetIndex();
     assert(idx < size_t(m_entries_count));
    assert(m_entries[idx] == pCurr);
 
    ++idx;
 
    if (idx >= size_t(m_entries_count))
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pNext = NULL;
            return status;
        }
        if (status > 0)
        {
            pNext = NULL;
            return 0;
        }
        assert(m_entries);
        assert(m_entries_count > 0);
        assert(idx < size_t(m_entries_count));
    }
    pNext = m_entries[idx];
    assert(pNext);
    return 0;
 }
","    const BlockEntry* pCurr,
    const BlockEntry*& pNext) const
{
    assert(pCurr);
    size_t idx = pCurr->GetIndex();
    assert(m_entries[idx] == pCurr);
    ++idx;
    if (idx >= size_t(m_entries_count))
    {
        long long pos;
        long len;
        const long status = Parse(pos, len);
        if (status < 0)  //error
        {
            pNext = NULL;
            return status;
        }
        if (status > 0)
        {
            pNext = NULL;
            return 0;
        }
        assert(m_entries);
        assert(m_entries_count > 0);
        assert(idx < size_t(m_entries_count));
    }
    pNext = m_entries[idx];
    assert(pNext);
    return 0;
"
"const CuePoint* Cues::GetNext(const CuePoint* pCurr) const
{
    if (pCurr == NULL)
        return NULL;
    assert(pCurr->GetTimeCode() >= 0);
    assert(m_cue_points);
    assert(m_count >= 1);
 
 #if 0
     const size_t count = m_count + m_preload_count;

 size_t index = pCurr->m_index;
    assert(index < count);

 CuePoint* const* const pp = m_cue_points;
    assert(pp);
    assert(pp[index] == pCurr);

 ++index;

 if (index >= count)
 return NULL;

 CuePoint* const pNext = pp[index];
    assert(pNext);

 
     pNext->Load(m_pSegment->m_pReader);
 #else
    long index = pCurr->m_index;
    assert(index < m_count);
 
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    assert(pp[index] == pCurr);
 
    ++index;
 
    if (index >= m_count)
        return NULL;
 
    CuePoint* const pNext = pp[index];
    assert(pNext);
    assert(pNext->GetTimeCode() >= 0);
 #endif
 
    return pNext;
 }
","{
    if (pCurr == NULL)
        return NULL;
    assert(pCurr->GetTimeCode() >= 0);
    assert(m_cue_points);
    assert(m_count >= 1);
    long index = pCurr->m_index;
    assert(index < m_count);
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    assert(pp[index] == pCurr);
    ++index;
    if (index >= m_count)
        return NULL;
    CuePoint* const pNext = pp[index];
    assert(pNext);
    assert(pNext->GetTimeCode() >= 0);
    return pNext;
"
"long long BlockGroup::GetNextTimeCode() const
{
    return m_next;
}
","{
    return m_next;
}
"
"long Track::GetNumber() const
{
    return m_info.number;
}
","{
    return m_info.number;
}
"
"long long Cluster::GetPosition() const
{
    const long long pos = m_element_start - m_pSegment->m_start;
    assert(pos >= 0);
 
    return pos;
 }
","{
    const long long pos = m_element_start - m_pSegment->m_start;
    assert(pos >= 0);
    return pos;
"
"long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}
","{
    return m_prev;
}
"
"double AudioTrack::GetSamplingRate() const
{
    return m_rate;
 }
","{
    return m_rate;
"
"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}
","{
    return m_pSeekHead;
}
"
"unsigned long long Track::GetSeekPreRoll() const
{
    return m_info.seekPreRoll;
}
","{
    return m_info.seekPreRoll;
}
"
"long long Chapters::Atom::GetStartTime(const Chapters* pChapters) const
{
    return GetTime(pChapters, m_start_timecode);
}
","{
    return GetTime(pChapters, m_start_timecode);
}
"
"long long Chapters::Atom::GetStartTimecode() const
{
    return m_start_timecode;
}
","{
    return m_start_timecode;
}
"
"long long Chapters::Atom::GetStopTime(const Chapters* pChapters) const
{
    return GetTime(pChapters, m_stop_timecode);
}
","{
    return GetTime(pChapters, m_stop_timecode);
}
"
"long long Chapters::Atom::GetStopTimecode() const
{
    return m_stop_timecode;
}
","{
    return m_stop_timecode;
}
"
"const char* Chapters::Display::GetString() const
{
    return m_string;
}
","{
    return m_string;
}
"
"const char* Chapters::Atom::GetStringUID() const
{
    return m_string_uid;
}
","{
    return m_string_uid;
}
"
"long long Chapters::Atom::GetTime(
    const Chapters* pChapters,
    long long timecode)
{
    if (pChapters == NULL)
        return -1;
    Segment* const pSegment = pChapters->m_pSegment;
    if (pSegment == NULL)  // weird
        return -1;
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    if (pInfo == NULL)
        return -1;
    const long long timecode_scale = pInfo->GetTimeCodeScale();
    if (timecode_scale < 1)  // weird
        return -1;
    if (timecode < 0)
        return -1;
    const long long result = timecode_scale * timecode;
    return result;
}
","    const Chapters* pChapters,
    long long timecode)
{
    if (pChapters == NULL)
        return -1;
    Segment* const pSegment = pChapters->m_pSegment;
    if (pSegment == NULL)  // weird
        return -1;
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    if (pInfo == NULL)
        return -1;
    const long long timecode_scale = pInfo->GetTimeCodeScale();
    if (timecode_scale < 1)  // weird
        return -1;
    if (timecode < 0)
        return -1;
    const long long result = timecode_scale * timecode;
    return result;
}
"
"long long Cluster::GetTime() const
{
    const long long tc = GetTimeCode();
    if (tc < 0)
        return tc;
    const SegmentInfo* const pInfo = m_pSegment->GetInfo();
    assert(pInfo);
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
    const long long t = m_timecode * scale;
    return t;
}
","{
    const long long tc = GetTimeCode();
    if (tc < 0)
        return tc;
    const SegmentInfo* const pInfo = m_pSegment->GetInfo();
    assert(pInfo);
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
    const long long t = m_timecode * scale;
    return t;
}
"
"long long Block::GetTime(const Cluster* pCluster) const
{
    assert(pCluster);
 
    const long long tc = GetTimeCode(pCluster);
 
    const Segment* const pSegment = pCluster->m_pSegment;
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    assert(pInfo);
 
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
 
    const long long ns = tc * scale;
    return ns;
 }
","{
    assert(pCluster);
    const long long tc = GetTimeCode(pCluster);
    const Segment* const pSegment = pCluster->m_pSegment;
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    assert(pInfo);
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
    const long long ns = tc * scale;
    return ns;
"
"long long CuePoint::GetTime(const Segment* pSegment) const
{
    assert(pSegment);
    assert(m_timecode >= 0);
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    assert(pInfo);
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
    const long long time = scale * m_timecode;
    return time;
}
","{
    assert(pSegment);
    assert(m_timecode >= 0);
    const SegmentInfo* const pInfo = pSegment->GetInfo();
    assert(pInfo);
    const long long scale = pInfo->GetTimeCodeScale();
    assert(scale >= 1);
    const long long time = scale * m_timecode;
    return time;
}
"
"long long Cluster::GetTimeCode() const
{
     long long pos;
     long len;
 
    const long status = Load(pos, len);
 
    if (status < 0) //error
        return status;
    return m_timecode;
}
","{
    const long status = Load(pos, len);
    if (status < 0) //error
        return status;
    return m_timecode;
}
"
"long long Block::GetTimeCode(const Cluster* pCluster) const
{
    if (pCluster == 0)
        return m_timecode;
 
    const long long tc0 = pCluster->GetTimeCode();
    assert(tc0 >= 0);
 
    const long long tc = tc0 + m_timecode;
    return tc;  //unscaled timecode units
 }
","{
    if (pCluster == 0)
        return m_timecode;
    const long long tc0 = pCluster->GetTimeCode();
    assert(tc0 >= 0);
    const long long tc = tc0 + m_timecode;
    return tc;  //unscaled timecode units
"
"long long CuePoint::GetTimeCode() const
{
    return m_timecode;
 }
","{
    return m_timecode;
"
"long long SegmentInfo::GetTimeCodeScale() const
{
    return m_timecodeScale;
}
","{
    return m_timecodeScale;
}
"
"const char* SegmentInfo::GetTitleAsUTF8() const
{
    return m_pTitleAsUTF8;
}
","{
    return m_pTitleAsUTF8;
}
"
"const Track* Tracks::GetTrackByIndex(unsigned long idx) const
{
    const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;
    if (idx >= static_cast<unsigned long>(count))
         return NULL;
    return m_trackEntries[idx];
 }
","{
    const ptrdiff_t count = m_trackEntriesEnd - m_trackEntries;
    if (idx >= static_cast<unsigned long>(count))
         return NULL;
    return m_trackEntries[idx];
"
"const Track* Tracks::GetTrackByNumber(long tn) const
{
    if (tn < 0)
        return NULL;
    Track** i = m_trackEntries;
    Track** const j = m_trackEntriesEnd;
    while (i != j)
    {
        Track* const pTrack = *i++;
        if (pTrack == NULL)
            continue;
        if (tn == pTrack->GetNumber())
            return pTrack;
    }
    return NULL;  //not found
}
","{
    if (tn < 0)
        return NULL;
    Track** i = m_trackEntries;
    Track** const j = m_trackEntriesEnd;
    while (i != j)
    {
        Track* const pTrack = *i++;
        if (pTrack == NULL)
            continue;
        if (tn == pTrack->GetNumber())
            return pTrack;
    }
    return NULL;  //not found
}
"
"long long Block::GetTrackNumber() const
{
    return m_track;
 }
","{
    return m_track;
"
"const Tracks* Segment::GetTracks() const
{
    return m_pTracks;
 }
","{
    return m_pTracks;
"
"unsigned long Tracks::GetTracksCount() const
{
    const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;
    assert(result >= 0);
    return static_cast<unsigned long>(result);
}
","{
    const ptrdiff_t result = m_trackEntriesEnd - m_trackEntries;
    assert(result >= 0);
    return static_cast<unsigned long>(result);
}
"
"long Track::GetType() const
{
    return m_info.type;
}
","{
    return m_info.type;
}
"
"unsigned long long Chapters::Atom::GetUID() const
{
    return m_uid;
 }
","{
    return m_uid;
"
"long long mkvparser::GetUIntLength(
    IMkvReader* pReader,
    long long pos,
    long& len)
{
    assert(pReader);
    assert(pos >= 0);
 
    long long total, available;
 
    int status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
 
    len = 1;
 
    if (pos >= available)
        return pos;  //too few bytes available
 
//// TODO(vigneshv): This function assumes that unsigned values never have their
//// high bit set.
     unsigned char b;
 
    status = pReader->Read(pos, 1, &b);
 
     if (status < 0)
        return status;
 
    assert(status == 0);
 
    if (b == 0)  //we can't handle u-int values larger than 8 bytes
        return E_FILE_FORMAT_INVALID;
 
    unsigned char m = 0x80;
    while (!(b & m))
    {
        m >>= 1;
        ++len;
    }
    return 0;  //success
 }
","    IMkvReader* pReader,
    long long pos,
    long& len)
{
    assert(pReader);
    assert(pos >= 0);
    long long total, available;
    int status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    len = 1;
    if (pos >= available)
        return pos;  //too few bytes available
    status = pReader->Read(pos, 1, &b);
        return status;
    assert(status == 0);
    if (b == 0)  //we can't handle u-int values larger than 8 bytes
        return E_FILE_FORMAT_INVALID;
    unsigned char m = 0x80;
    while (!(b & m))
    {
        m >>= 1;
        ++len;
    }
    return 0;  //success
"
"unsigned long long Track::GetUid() const
{
    return m_info.uid;
}
","{
    return m_info.uid;
}
"
"void mkvparser::GetVersion(int& major, int& minor, int& build, int& revision)
{
    major = 1;
    minor = 0;
    build = 0;
    revision = 27;
}
","{
    major = 1;
    minor = 0;
    build = 0;
    revision = 27;
}
"
"const SeekHead::VoidElement* SeekHead::GetVoidElement(int idx) const
{
    if (idx < 0)
        return 0;
    if (idx >= m_void_element_count)
        return 0;
    return m_void_elements + idx;
}
","{
    if (idx < 0)
        return 0;
    if (idx >= m_void_element_count)
        return 0;
    return m_void_elements + idx;
}
"
"int SeekHead::GetVoidElementCount() const
{
    return m_void_element_count;
}
","{
    return m_void_element_count;
}
"
"long long VideoTrack::GetWidth() const
{
    return m_width;
}
","{
    return m_width;
}
"
"const char* SegmentInfo::GetWritingAppAsUTF8() const
{
    return m_pWritingAppAsUTF8;
}
","{
    return m_pWritingAppAsUTF8;
}
"
"Track::Info::Info():
    uid(0),
    defaultDuration(0),
    codecDelay(0),
    seekPreRoll(0),
    nameAsUTF8(NULL),
    language(NULL),
    codecId(NULL),
    codecNameAsUTF8(NULL),
    codecPrivate(NULL),
    codecPrivateSize(0),
    lacing(false)
{
}
","    uid(0),
    defaultDuration(0),
    codecDelay(0),
    seekPreRoll(0),
    nameAsUTF8(NULL),
    language(NULL),
    codecId(NULL),
    codecNameAsUTF8(NULL),
    codecPrivate(NULL),
    codecPrivateSize(0),
    lacing(false)
{
}
"
"void Chapters::Edition::Init()
{
    m_atoms = NULL;
    m_atoms_size = 0;
    m_atoms_count = 0;
 }
","{
    m_atoms = NULL;
    m_atoms_size = 0;
    m_atoms_count = 0;
"
"void Chapters::Atom::Init()
{
    m_string_uid = NULL;
    m_uid = 0;
    m_start_timecode = -1;
    m_stop_timecode = -1;
    m_displays = NULL;
    m_displays_size = 0;
    m_displays_count = 0;
}
","{
    m_string_uid = NULL;
    m_uid = 0;
    m_start_timecode = -1;
    m_stop_timecode = -1;
    m_displays = NULL;
    m_displays_size = 0;
    m_displays_count = 0;
}
"
"void Chapters::Display::Init()
{
    m_string = NULL;
    m_language = NULL;
    m_country = NULL;
}
","{
    m_string = NULL;
    m_language = NULL;
    m_country = NULL;
}
"
"void EBMLHeader::Init()
{
    m_version = 1;
    m_readVersion = 1;
    m_maxIdLength = 4;
    m_maxSizeLength = 8;
 
    if (m_docType)
    {
        delete[] m_docType;
        m_docType = NULL;
    }
 
    m_docTypeVersion = 1;
    m_docTypeReadVersion = 1;
}
","{
    m_version = 1;
    m_readVersion = 1;
    m_maxIdLength = 4;
    m_maxSizeLength = 8;
    if (m_docType)
    {
        delete[] m_docType;
        m_docType = NULL;
    }
    m_docTypeVersion = 1;
    m_docTypeReadVersion = 1;
}
"
"void Cues::Init() const
{
    if (m_cue_points)
        return;
 
    assert(m_count == 0);
    assert(m_preload_count == 0);
 
    IMkvReader* const pReader = m_pSegment->m_pReader;
 
    const long long stop = m_start + m_size;
    long long pos = m_start;
 
    long cue_points_size = 0;
 
    while (pos < stop)
    {
        const long long idpos = pos;
 
        long len;
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume ID
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);
        assert((pos + len) <= stop);
        pos += len;  //consume Size field
        assert((pos + size) <= stop);
        if (id == 0x3B)  //CuePoint ID
            PreloadCuePoint(cue_points_size, idpos);
        pos += size;  //consume payload
        assert(pos <= stop);
    }
}
","{
    if (m_cue_points)
        return;
    assert(m_count == 0);
    assert(m_preload_count == 0);
    IMkvReader* const pReader = m_pSegment->m_pReader;
    const long long stop = m_start + m_size;
    long long pos = m_start;
    long cue_points_size = 0;
    while (pos < stop)
    {
        const long long idpos = pos;
        long len;
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume ID
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);
        assert((pos + len) <= stop);
        pos += len;  //consume Size field
        assert((pos + size) <= stop);
        if (id == 0x3B)  //CuePoint ID
            PreloadCuePoint(cue_points_size, idpos);
        pos += size;  //consume payload
        assert(pos <= stop);
    }
}
"
"bool Block::IsInvisible() const
{
    return bool(int(m_flags & 0x08) != 0);
 }
","{
    return bool(int(m_flags & 0x08) != 0);
"
"bool Block::IsKey() const
{
    return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);
 }
","{
    return ((m_flags & static_cast<unsigned char>(1 << 7)) != 0);
"
"long Segment::Load()
{
    assert(m_clusters == NULL);
    assert(m_clusterSize == 0);
    assert(m_clusterCount == 0);
 
 
    const long long header_status = ParseHeaders();
 
    if (header_status < 0)  //error
        return static_cast<long>(header_status);
 
    if (header_status > 0)  //underflow
        return E_BUFFER_NOT_FULL;
 
    assert(m_pInfo);
    assert(m_pTracks);
 
    for (;;)
    {
        const int status = LoadCluster();
 
        if (status < 0)  //error
            return status;
 
        if (status >= 1)  //no more clusters
            return 0;
    }
 }
","{
    assert(m_clusters == NULL);
    assert(m_clusterSize == 0);
    assert(m_clusterCount == 0);
    const long long header_status = ParseHeaders();
    if (header_status < 0)  //error
        return static_cast<long>(header_status);
    if (header_status > 0)  //underflow
        return E_BUFFER_NOT_FULL;
    assert(m_pInfo);
    assert(m_pTracks);
    for (;;)
    {
        const int status = LoadCluster();
        if (status < 0)  //error
            return status;
        if (status >= 1)  //no more clusters
            return 0;
    }
"
"long Segment::LoadCluster(
    long long& pos,
    long& len)
{
    for (;;)
    {
        const long result = DoLoadCluster(pos, len);
 
        if (result <= 1)
            return result;
     }
}
","    long long& pos,
    long& len)
{
    for (;;)
    {
        const long result = DoLoadCluster(pos, len);
        if (result <= 1)
            return result;
}
"
"bool Cues::LoadCuePoint() const
{
    const long long stop = m_start + m_size;
    if (m_pos >= stop)
        return false;  //nothing else to do
    Init();
    IMkvReader* const pReader = m_pSegment->m_pReader;
    while (m_pos < stop)
    {
        const long long idpos = m_pos;
        long len;
        const long long id = ReadUInt(pReader, m_pos, len);
        assert(id >= 0);  //TODO
        assert((m_pos + len) <= stop);
        m_pos += len;  //consume ID
        const long long size = ReadUInt(pReader, m_pos, len);
        assert(size >= 0);
        assert((m_pos + len) <= stop);
        m_pos += len;  //consume Size field
        assert((m_pos + size) <= stop);
        if (id != 0x3B)  //CuePoint ID
        {
            m_pos += size;  //consume payload
            assert(m_pos <= stop);
            continue;
        }
        assert(m_preload_count > 0);
        CuePoint* const pCP = m_cue_points[m_count];
        assert(pCP);
        assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
        if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
            return false;
        pCP->Load(pReader);
        ++m_count;
        --m_preload_count;
        m_pos += size;  //consume payload
        assert(m_pos <= stop);
        return true;  //yes, we loaded a cue point
    }
    return false;  //no, we did not load a cue point
}
","{
    const long long stop = m_start + m_size;
    if (m_pos >= stop)
        return false;  //nothing else to do
    Init();
    IMkvReader* const pReader = m_pSegment->m_pReader;
    while (m_pos < stop)
    {
        const long long idpos = m_pos;
        long len;
        const long long id = ReadUInt(pReader, m_pos, len);
        assert(id >= 0);  //TODO
        assert((m_pos + len) <= stop);
        m_pos += len;  //consume ID
        const long long size = ReadUInt(pReader, m_pos, len);
        assert(size >= 0);
        assert((m_pos + len) <= stop);
        m_pos += len;  //consume Size field
        assert((m_pos + size) <= stop);
        if (id != 0x3B)  //CuePoint ID
        {
            m_pos += size;  //consume payload
            assert(m_pos <= stop);
            continue;
        }
        assert(m_preload_count > 0);
        CuePoint* const pCP = m_cue_points[m_count];
        assert(pCP);
        assert((pCP->GetTimeCode() >= 0) || (-pCP->GetTimeCode() == idpos));
        if (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos))
            return false;
        pCP->Load(pReader);
        ++m_count;
        --m_preload_count;
        m_pos += size;  //consume payload
        assert(m_pos <= stop);
        return true;  //yes, we loaded a cue point
    }
    return false;  //no, we did not load a cue point
}
"
"bool mkvparser::Match(
    IMkvReader* pReader,
    long long& pos,
    unsigned long id_,
    long long& val)
{
    assert(pReader);
    assert(pos >= 0);
 
    long long total, available;
 
    const long status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    if (status < 0)
        return false;
 
    long len;
 
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
 
    if ((unsigned long)id != id_)
        return false;
 
    pos += len;  //consume id
 
    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert(size <= 8);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
 
    pos += len;  //consume length of size of payload
 
    val = UnserializeUInt(pReader, pos, size);
    assert(val >= 0);
 
    pos += size;  //consume size of payload
    return true;
 }
","    IMkvReader* pReader,
    long long& pos,
    unsigned long id_,
    long long& val)
{
    assert(pReader);
    assert(pos >= 0);
    long long total, available;
    const long status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    if (status < 0)
        return false;
    long len;
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
    if ((unsigned long)id != id_)
        return false;
    pos += len;  //consume id
    const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert(size <= 8);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
    pos += len;  //consume length of size of payload
    val = UnserializeUInt(pReader, pos, size);
    assert(val >= 0);
    pos += size;  //consume size of payload
    return true;
"
"bool mkvparser::Match(
    IMkvReader* pReader,
    long long& pos,
    unsigned long id_,
    unsigned char*& buf,
    size_t& buflen)
{
    assert(pReader);
    assert(pos >= 0);
 
    long long total, available;
 
    long status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    if (status < 0)
        return false;
 
    long len;
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
 
    if ((unsigned long)id != id_)
        return false;
 
    pos += len;  //consume id
 
    const long long size_ = ReadUInt(pReader, pos, len);
    assert(size_ >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
 
    pos += len;  //consume length of size of payload
    assert((pos + size_) <= available);
 
    const long buflen_ = static_cast<long>(size_);
 
    buf = new (std::nothrow) unsigned char[buflen_];
    assert(buf);  //TODO
 
    status = pReader->Read(pos, buflen_, buf);
    assert(status == 0);  //TODO
 
    buflen = buflen_;
 
    pos += size_;  //consume size of payload
    return true;
 }
","    IMkvReader* pReader,
    long long& pos,
    unsigned long id_,
    unsigned char*& buf,
    size_t& buflen)
{
    assert(pReader);
    assert(pos >= 0);
    long long total, available;
    long status = pReader->Length(&total, &available);
    assert(status >= 0);
    assert((total < 0) || (available <= total));
    if (status < 0)
        return false;
    long len;
    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
    if ((unsigned long)id != id_)
        return false;
    pos += len;  //consume id
    const long long size_ = ReadUInt(pReader, pos, len);
    assert(size_ >= 0);
    assert(len > 0);
    assert(len <= 8);
    assert((pos + len) <= available);
    pos += len;  //consume length of size of payload
    assert((pos + size_) <= available);
    const long buflen_ = static_cast<long>(size_);
    buf = new (std::nothrow) unsigned char[buflen_];
    assert(buf);  //TODO
    status = pReader->Read(pos, buflen_, buf);
    assert(status == 0);  //TODO
    buflen = buflen_;
    pos += size_;  //consume size of payload
    return true;
"
"long Chapters::Parse()
{
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = m_start;  // payload start
    const long long stop = pos + m_size;  // payload stop
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x05B9)  // EditionEntry ID
        {
            status = ParseEdition(pos, size);
            if (status < 0)  // error
                return status;
        }
        pos += size;
        assert(pos <= stop);
     }
 
    assert(pos == stop);
    return 0;
 }
","{
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = m_start;  // payload start
    const long long stop = pos + m_size;  // payload stop
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x05B9)  // EditionEntry ID
        {
            status = ParseEdition(pos, size);
            if (status < 0)  // error
                return status;
        }
        pos += size;
        assert(pos <= stop);
    assert(pos == stop);
    return 0;
"
"long Chapters::Edition::Parse(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    const long long stop = pos + size;
 
    while (pos < stop)
    {
        long long id, size;
 
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
 
        if (status < 0)  // error
            return status;
 
        if (size == 0)  // weird
            continue;
 
        if (id == 0x36)  // Atom ID
        {
            status = ParseAtom(pReader, pos, size);
 
            if (status < 0)  // error
                return status;
        }
 
        pos += size;
        assert(pos <= stop);
     }
 
    assert(pos == stop);
    return 0;
 }
","    IMkvReader* pReader,
    long long pos,
    long long size)
{
    const long long stop = pos + size;
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x36)  // Atom ID
        {
            status = ParseAtom(pReader, pos, size);
            if (status < 0)  // error
                return status;
        }
        pos += size;
        assert(pos <= stop);
    assert(pos == stop);
    return 0;
"
"long Chapters::Atom::Parse(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    const long long stop = pos + size;
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x00)  // Display ID
        {
            status = ParseDisplay(pReader, pos, size);
            if (status < 0)  // error
                return status;
        }
        else if (id == 0x1654)  // StringUID ID
        {
            status = UnserializeString(pReader, pos, size, m_string_uid);
            if (status < 0)  // error
                return status;
        }
        else if (id == 0x33C4)  // UID ID
        {
            long long val;
            status = UnserializeInt(pReader, pos, size, val);
            if (status < 0)  // error
                return status;
            m_uid = val;
        }
        else if (id == 0x11)  // TimeStart ID
        {
            const long long val = UnserializeUInt(pReader, pos, size);
            if (val < 0)  // error
                return static_cast<long>(val);
            m_start_timecode = val;
        }
        else if (id == 0x12)  // TimeEnd ID
        {
            const long long val = UnserializeUInt(pReader, pos, size);
            if (val < 0)  // error
                return static_cast<long>(val);
            m_stop_timecode = val;
        }
        pos += size;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;
}
","    IMkvReader* pReader,
    long long pos,
    long long size)
{
    const long long stop = pos + size;
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x00)  // Display ID
        {
            status = ParseDisplay(pReader, pos, size);
            if (status < 0)  // error
                return status;
        }
        else if (id == 0x1654)  // StringUID ID
        {
            status = UnserializeString(pReader, pos, size, m_string_uid);
            if (status < 0)  // error
                return status;
        }
        else if (id == 0x33C4)  // UID ID
        {
            long long val;
            status = UnserializeInt(pReader, pos, size, val);
            if (status < 0)  // error
                return status;
            m_uid = val;
        }
        else if (id == 0x11)  // TimeStart ID
        {
            const long long val = UnserializeUInt(pReader, pos, size);
            if (val < 0)  // error
                return static_cast<long>(val);
            m_start_timecode = val;
        }
        else if (id == 0x12)  // TimeEnd ID
        {
            const long long val = UnserializeUInt(pReader, pos, size);
            if (val < 0)  // error
                return static_cast<long>(val);
            m_stop_timecode = val;
        }
        pos += size;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;
}
"
"long Chapters::Display::Parse(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    const long long stop = pos + size;
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x05)  // ChapterString ID
        {
            status = UnserializeString(pReader, pos, size, m_string);
            if (status)
              return status;
        }
        else if (id == 0x037C)  // ChapterLanguage ID
        {
            status = UnserializeString(pReader, pos, size, m_language);
            if (status)
              return status;
        }
        else if (id == 0x037E)  // ChapterCountry ID
        {
            status = UnserializeString(pReader, pos, size, m_country);
            if (status)
              return status;
        }
        pos += size;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;
}
","    IMkvReader* pReader,
    long long pos,
    long long size)
{
    const long long stop = pos + size;
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x05)  // ChapterString ID
        {
            status = UnserializeString(pReader, pos, size, m_string);
            if (status)
              return status;
        }
        else if (id == 0x037C)  // ChapterLanguage ID
        {
            status = UnserializeString(pReader, pos, size, m_language);
            if (status)
              return status;
        }
        else if (id == 0x037E)  // ChapterCountry ID
        {
            status = UnserializeString(pReader, pos, size, m_country);
            if (status)
              return status;
        }
        pos += size;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;
}
"
"long SegmentInfo::Parse()
{
    assert(m_pMuxingAppAsUTF8 == NULL);
    assert(m_pWritingAppAsUTF8 == NULL);
    assert(m_pTitleAsUTF8 == NULL);
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = m_start;
    const long long stop = m_start + m_size;
    m_timecodeScale = 1000000;
    m_duration = -1;
    while (pos < stop)
    {
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (id == 0x0AD7B1)  //Timecode Scale
        {
            m_timecodeScale = UnserializeUInt(pReader, pos, size);
            if (m_timecodeScale <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0489)  //Segment duration
        {
            const long status = UnserializeFloat(
                                    pReader,
                                    pos,
                                    size,
                                    m_duration);
            if (status < 0)
                return status;
            if (m_duration < 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0D80)  //MuxingApp
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pMuxingAppAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x1741)  //WritingApp
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pWritingAppAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x3BA9)  //Title
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pTitleAsUTF8);
            if (status)
                return status;
        }
        pos += size;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;
}
","{
    assert(m_pMuxingAppAsUTF8 == NULL);
    assert(m_pWritingAppAsUTF8 == NULL);
    assert(m_pTitleAsUTF8 == NULL);
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = m_start;
    const long long stop = m_start + m_size;
    m_timecodeScale = 1000000;
    m_duration = -1;
    while (pos < stop)
    {
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (id == 0x0AD7B1)  //Timecode Scale
        {
            m_timecodeScale = UnserializeUInt(pReader, pos, size);
            if (m_timecodeScale <= 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0489)  //Segment duration
        {
            const long status = UnserializeFloat(
                                    pReader,
                                    pos,
                                    size,
                                    m_duration);
            if (status < 0)
                return status;
            if (m_duration < 0)
                return E_FILE_FORMAT_INVALID;
        }
        else if (id == 0x0D80)  //MuxingApp
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pMuxingAppAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x1741)  //WritingApp
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pWritingAppAsUTF8);
            if (status)
                return status;
        }
        else if (id == 0x3BA9)  //Title
        {
            const long status = UnserializeString(
                                    pReader,
                                    pos,
                                    size,
                                    m_pTitleAsUTF8);
            if (status)
                return status;
        }
        pos += size;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;
}
"
"long Tracks::Parse()
{
    assert(m_trackEntries == NULL);
    assert(m_trackEntriesEnd == NULL);
    const long long stop = m_start + m_size;
    IMkvReader* const pReader = m_pSegment->m_pReader;
    int count = 0;
    long long pos = m_start;
    while (pos < stop)
    {
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (size == 0)  //weird
            continue;
        if (id == 0x2E)  //TrackEntry ID
            ++count;
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(pos == stop);
    if (count <= 0)
        return 0;  //success
    m_trackEntries = new (std::nothrow) Track*[count];
    if (m_trackEntries == NULL)
        return -1;
    m_trackEntriesEnd = m_trackEntries;
    pos = m_start;
    while (pos < stop)
    {
        const long long element_start = pos;
        long long id, payload_size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                payload_size);
        if (status < 0)  //error
            return status;
        if (payload_size == 0)  //weird
            continue;
        const long long payload_stop = pos + payload_size;
        assert(payload_stop <= stop);  //checked in ParseElement
        const long long element_size = payload_stop - element_start;
        if (id == 0x2E)  //TrackEntry ID
        {
            Track*& pTrack = *m_trackEntriesEnd;
            pTrack = NULL;
            const long status = ParseTrackEntry(
                                    pos,
                                    payload_size,
                                    element_start,
                                    element_size,
                                    pTrack);
            if (status)
                return status;
            if (pTrack)
                ++m_trackEntriesEnd;
        }
        pos = payload_stop;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;  //success
}
","{
    assert(m_trackEntries == NULL);
    assert(m_trackEntriesEnd == NULL);
    const long long stop = m_start + m_size;
    IMkvReader* const pReader = m_pSegment->m_pReader;
    int count = 0;
    long long pos = m_start;
    while (pos < stop)
    {
        long long id, size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                size);
        if (status < 0)  //error
            return status;
        if (size == 0)  //weird
            continue;
        if (id == 0x2E)  //TrackEntry ID
            ++count;
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(pos == stop);
    if (count <= 0)
        return 0;  //success
    m_trackEntries = new (std::nothrow) Track*[count];
    if (m_trackEntries == NULL)
        return -1;
    m_trackEntriesEnd = m_trackEntries;
    pos = m_start;
    while (pos < stop)
    {
        const long long element_start = pos;
        long long id, payload_size;
        const long status = ParseElementHeader(
                                pReader,
                                pos,
                                stop,
                                id,
                                payload_size);
        if (status < 0)  //error
            return status;
        if (payload_size == 0)  //weird
            continue;
        const long long payload_stop = pos + payload_size;
        assert(payload_stop <= stop);  //checked in ParseElement
        const long long element_size = payload_stop - element_start;
        if (id == 0x2E)  //TrackEntry ID
        {
            Track*& pTrack = *m_trackEntriesEnd;
            pTrack = NULL;
            const long status = ParseTrackEntry(
                                    pos,
                                    payload_size,
                                    element_start,
                                    element_size,
                                    pTrack);
            if (status)
                return status;
            if (pTrack)
                ++m_trackEntriesEnd;
        }
        pos = payload_stop;
        assert(pos <= stop);
    }
    assert(pos == stop);
    return 0;  //success
}
"
"long SimpleBlock::Parse()
{
    return m_block.Parse(m_pCluster);
}
","{
    return m_block.Parse(m_pCluster);
}
"
"long BlockGroup::Parse()
{
    const long status = m_block.Parse(m_pCluster);
    if (status)
        return status;
    m_block.SetKey((m_prev > 0) && (m_next <= 0));
    return 0;
}
","{
    const long status = m_block.Parse(m_pCluster);
    if (status)
        return status;
    m_block.SetKey((m_prev > 0) && (m_next <= 0));
    return 0;
}
"
"void CuePoint::TrackPosition::Parse(
    IMkvReader* pReader,
    long long start_,
    long long size_)
{
    const long long stop = start_ + size_;
    long long pos = start_;
 
    m_track = -1;
    m_pos = -1;
    m_block = 1;  //default
 
    while (pos < stop)
    {
        long len;
 
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
 
        pos += len;  //consume ID
 
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);
        assert((pos + len) <= stop);
 
        pos += len;  //consume Size field
        assert((pos + size) <= stop);
 
        if (id == 0x77)  //CueTrack ID
            m_track = UnserializeUInt(pReader, pos, size);
 
        else if (id == 0x71)  //CueClusterPos ID
            m_pos = UnserializeUInt(pReader, pos, size);
 
        else if (id == 0x1378)  //CueBlockNumber
            m_block = UnserializeUInt(pReader, pos, size);
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(m_pos >= 0);
    assert(m_track > 0);
 }
","    IMkvReader* pReader,
    long long start_,
    long long size_)
{
    const long long stop = start_ + size_;
    long long pos = start_;
    m_track = -1;
    m_pos = -1;
    m_block = 1;  //default
    while (pos < stop)
    {
        long len;
        const long long id = ReadUInt(pReader, pos, len);
        assert(id >= 0);  //TODO
        assert((pos + len) <= stop);
        pos += len;  //consume ID
        const long long size = ReadUInt(pReader, pos, len);
        assert(size >= 0);
        assert((pos + len) <= stop);
        pos += len;  //consume Size field
        assert((pos + size) <= stop);
        if (id == 0x77)  //CueTrack ID
            m_track = UnserializeUInt(pReader, pos, size);
        else if (id == 0x71)  //CueClusterPos ID
            m_pos = UnserializeUInt(pReader, pos, size);
        else if (id == 0x1378)  //CueBlockNumber
            m_block = UnserializeUInt(pReader, pos, size);
        pos += size;  //consume payload
        assert(pos <= stop);
    }
    assert(m_pos >= 0);
    assert(m_track > 0);
"
"long Chapters::Edition::ParseAtom(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandAtomsArray())
        return -1;
 
    Atom& a = m_atoms[m_atoms_count++];
    a.Init();
 
    return a.Parse(pReader, pos, size);
 }
","    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandAtomsArray())
        return -1;
    Atom& a = m_atoms[m_atoms_count++];
    a.Init();
    return a.Parse(pReader, pos, size);
"
"long ContentEncoding::ParseCompressionEntry(
    long long start,
    long long size,
    IMkvReader* pReader,
    ContentCompression* compression) {
   assert(pReader);
   assert(compression);
 
 long long pos = start;
 const long long stop = start + size;

 bool valid = false;

 
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
       return status;
 
     if (id == 0x254) {
 long long algo = UnserializeUInt(pReader, pos, size);
 if (algo < 0)
 return E_FILE_FORMAT_INVALID;
      compression->algo = algo;
      valid = true;
 } else if (id == 0x255) {
 if (size <= 0)
 return E_FILE_FORMAT_INVALID;

 const size_t buflen = static_cast<size_t>(size);
 typedef unsigned char* buf_t;
 const buf_t buf = new (std::nothrow) unsigned char[buflen];

       if (buf == NULL)
         return -1;
 
      const int read_status = pReader->Read(pos, buflen, buf);
       if (read_status) {
        delete [] buf;
         return status;
       }
 
      compression->settings = buf;

       compression->settings_len = buflen;
     }
 
    pos += size;  //consume payload
     assert(pos <= stop);
   }
 
 if (!valid)
 return E_FILE_FORMAT_INVALID;


   return 0;
 }
","    long long start,
    long long size,
    IMkvReader* pReader,
    ContentCompression* compression) {
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
      const int read_status = pReader->Read(pos, buflen, buf);
        delete [] buf;
    pos += size;  //consume payload
"
" long ContentEncoding::ParseContentEncAESSettingsEntry(
    long long start,
    long long size,
    IMkvReader* pReader,
     ContentEncAESSettings* aes) {
   assert(pReader);
   assert(aes);

 long long pos = start;
 const long long stop = start + size;

 
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
       return status;
 
     if (id == 0x7E8) {
      aes->cipher_mode = UnserializeUInt(pReader, pos, size);
 if (aes->cipher_mode != 1)

         return E_FILE_FORMAT_INVALID;
     }
 
    pos += size;  //consume payload
     assert(pos <= stop);
   }
 
   return 0;
 }
","    long long start,
    long long size,
    IMkvReader* pReader,
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
    pos += size;  //consume payload
"
"long Track::ParseContentEncodingsEntry(long long start, long long size) {
 IMkvReader* const pReader = m_pSegment->m_pReader;
  assert(pReader);

 long long pos = start;
 const long long stop = start + size;


   int count = 0;
   while (pos < stop) {
     long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
       return status;
 
     if (id == 0x2240)  // ContentEncoding ID
       ++count;
 
    pos += size;  //consume payload
     assert(pos <= stop);
   }
 
   if (count <= 0)
     return -1;
 
  content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];
   if (!content_encoding_entries_)
     return -1;
 
  content_encoding_entries_end_ = content_encoding_entries_;


   pos = start;
   while (pos < stop) {
     long long id, size;
    long status = ParseElementHeader(pReader,
                                     pos,
                                     stop,
                                     id,
                                     size);
    if (status < 0)  //error
       return status;
 
    if (id == 0x2240) { // ContentEncoding ID
       ContentEncoding* const content_encoding =
           new (std::nothrow) ContentEncoding();
       if (!content_encoding)
         return -1;
 
      status = content_encoding->ParseContentEncodingEntry(pos,
                                                           size,
                                                           pReader);
       if (status) {
         delete content_encoding;
         return status;
 }


       *content_encoding_entries_end_++ = content_encoding;
     }
 
    pos += size;  //consume payload
     assert(pos <= stop);
   }
 
  assert(pos == stop);


   return 0;
 }
","    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
    pos += size;  //consume payload
  content_encoding_entries_ = new (std::nothrow) ContentEncoding*[count];
    long status = ParseElementHeader(pReader,
                                     pos,
                                     stop,
                                     id,
                                     size);
    if (status < 0)  //error
    if (id == 0x2240) { // ContentEncoding ID
      status = content_encoding->ParseContentEncodingEntry(pos,
                                                           size,
                                                           pReader);
    pos += size;  //consume payload
"
"long Chapters::Atom::ParseDisplay(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandDisplaysArray())
        return -1;
    Display& d = m_displays[m_displays_count++];
    d.Init();
    return d.Parse(pReader, pos, size);
}
","    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandDisplaysArray())
        return -1;
    Display& d = m_displays[m_displays_count++];
    d.Init();
    return d.Parse(pReader, pos, size);
}
"
"long Chapters::ParseEdition(
    long long pos,
    long long size)
{
    if (!ExpandEditionsArray())
        return -1;
 
    Edition& e = m_editions[m_editions_count++];
    e.Init();
    return e.Parse(m_pSegment->m_pReader, pos, size);
 }
","    long long pos,
    long long size)
{
    if (!ExpandEditionsArray())
        return -1;
    Edition& e = m_editions[m_editions_count++];
    e.Init();
    return e.Parse(m_pSegment->m_pReader, pos, size);
"
"long mkvparser::ParseElementHeader(
    IMkvReader* pReader,
    long long& pos,
    long long stop,
    long long& id,
    long long& size)
{
    if ((stop >= 0) && (pos >= stop))
        return E_FILE_FORMAT_INVALID;
 
    long len;
 
    id = ReadUInt(pReader, pos, len);
 
    if (id < 0)
        return E_FILE_FORMAT_INVALID;
 
    pos += len;  //consume id
 
    if ((stop >= 0) && (pos >= stop))
        return E_FILE_FORMAT_INVALID;
 
    size = ReadUInt(pReader, pos, len);
 
    if (size < 0)
        return E_FILE_FORMAT_INVALID;
 
    pos += len;  //consume length of size
 
 
    if ((stop >= 0) && ((pos + size) > stop))
        return E_FILE_FORMAT_INVALID;
    return 0;  //success
 }
","    IMkvReader* pReader,
    long long& pos,
    long long stop,
    long long& id,
    long long& size)
{
    if ((stop >= 0) && (pos >= stop))
        return E_FILE_FORMAT_INVALID;
    long len;
    id = ReadUInt(pReader, pos, len);
    if (id < 0)
        return E_FILE_FORMAT_INVALID;
    pos += len;  //consume id
    if ((stop >= 0) && (pos >= stop))
        return E_FILE_FORMAT_INVALID;
    size = ReadUInt(pReader, pos, len);
    if (size < 0)
        return E_FILE_FORMAT_INVALID;
    pos += len;  //consume length of size
    if ((stop >= 0) && ((pos + size) > stop))
        return E_FILE_FORMAT_INVALID;
    return 0;  //success
"
"bool SeekHead::ParseEntry(
    IMkvReader* pReader,
    long long start,
    long long size_,
    Entry* pEntry)
{
    if (size_ <= 0)
        return false;
 
    long long pos = start;
    const long long stop = start + size_;
 
    long len;
 
 
    const long long seekIdId = ReadUInt(pReader, pos, len);
 
    if (seekIdId != 0x13AB)  //SeekID ID
        return false;
 
    if ((pos + len) > stop)
        return false;
 
    pos += len;  //consume SeekID id
 
    const long long seekIdSize = ReadUInt(pReader, pos, len);
 
    if (seekIdSize <= 0)
        return false;
 
    if ((pos + len) > stop)
        return false;
 
    pos += len;  //consume size of field
 
    if ((pos + seekIdSize) > stop)
        return false;
 
 
    pEntry->id = ReadUInt(pReader, pos, len);  //payload
 
    if (pEntry->id <= 0)
        return false;
 
    if (len != seekIdSize)
        return false;
 
    pos += seekIdSize;  //consume SeekID payload
 
    const long long seekPosId = ReadUInt(pReader, pos, len);
 
    if (seekPosId != 0x13AC)  //SeekPos ID
        return false;
 
    if ((pos + len) > stop)
        return false;
 
    pos += len;  //consume id
 
    const long long seekPosSize = ReadUInt(pReader, pos, len);
 
    if (seekPosSize <= 0)
        return false;
 
    if ((pos + len) > stop)
        return false;
 
    pos += len;  //consume size
 
    if ((pos + seekPosSize) > stop)
        return false;
 
    pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);
 
    if (pEntry->pos < 0)
        return false;
 
    pos += seekPosSize;  //consume payload
 
    if (pos != stop)
        return false;
 
    return true;
 }
","    IMkvReader* pReader,
    long long start,
    long long size_,
    Entry* pEntry)
{
    if (size_ <= 0)
        return false;
    long long pos = start;
    const long long stop = start + size_;
    long len;
    const long long seekIdId = ReadUInt(pReader, pos, len);
    if (seekIdId != 0x13AB)  //SeekID ID
        return false;
    if ((pos + len) > stop)
        return false;
    pos += len;  //consume SeekID id
    const long long seekIdSize = ReadUInt(pReader, pos, len);
    if (seekIdSize <= 0)
        return false;
    if ((pos + len) > stop)
        return false;
    pos += len;  //consume size of field
    if ((pos + seekIdSize) > stop)
        return false;
    pEntry->id = ReadUInt(pReader, pos, len);  //payload
    if (pEntry->id <= 0)
        return false;
    if (len != seekIdSize)
        return false;
    pos += seekIdSize;  //consume SeekID payload
    const long long seekPosId = ReadUInt(pReader, pos, len);
    if (seekPosId != 0x13AC)  //SeekPos ID
        return false;
    if ((pos + len) > stop)
        return false;
    pos += len;  //consume id
    const long long seekPosSize = ReadUInt(pReader, pos, len);
    if (seekPosSize <= 0)
        return false;
    if ((pos + len) > stop)
        return false;
    pos += len;  //consume size
    if ((pos + seekPosSize) > stop)
        return false;
    pEntry->pos = UnserializeUInt(pReader, pos, seekPosSize);
    if (pEntry->pos < 0)
        return false;
    pos += seekPosSize;  //consume payload
    if (pos != stop)
        return false;
    return true;
"
"void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)
{
    assert(pCluster);
    assert(pCluster->m_index < 0);
    assert(idx >= m_clusterCount);
    const long count = m_clusterCount + m_clusterPreloadCount;
    long& size = m_clusterSize;
    assert(size >= count);
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
        while (p != pp)
            *q++ = *p++;
        delete[] m_clusters;
        m_clusters = qq;
        size = n;
    }
     assert(m_clusters);
 
    Cluster** const p = m_clusters + idx;
 
    Cluster** q = m_clusters + count;
    assert(q >= p);
     assert(q < (m_clusters + size));
 
    while (q > p)
    {
        Cluster** const qq = q - 1;
        assert((*qq)->m_index < 0);
 
        *q = *qq;
        q = qq;
     }
 
    m_clusters[idx] = pCluster;
    ++m_clusterPreloadCount;
 }
","{
    assert(pCluster);
    assert(pCluster->m_index < 0);
    assert(idx >= m_clusterCount);
    const long count = m_clusterCount + m_clusterPreloadCount;
    long& size = m_clusterSize;
    assert(size >= count);
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
        while (p != pp)
            *q++ = *p++;
        delete[] m_clusters;
        m_clusters = qq;
        size = n;
    }
    Cluster** const p = m_clusters + idx;
    Cluster** q = m_clusters + count;
    assert(q >= p);
    while (q > p)
    {
        Cluster** const qq = q - 1;
        assert((*qq)->m_index < 0);
        *q = *qq;
        q = qq;
    m_clusters[idx] = pCluster;
    ++m_clusterPreloadCount;
"
"void Cues::PreloadCuePoint(
    long& cue_points_size,
    long long pos) const
{
    assert(m_count == 0);
    if (m_preload_count >= cue_points_size)
    {
        const long n = (cue_points_size <= 0) ? 2048 : 2*cue_points_size;
        CuePoint** const qq = new CuePoint*[n];
        CuePoint** q = qq;  //beginning of target
        CuePoint** p = m_cue_points;                //beginning of source
        CuePoint** const pp = p + m_preload_count;  //end of source
        while (p != pp)
            *q++ = *p++;
        delete[] m_cue_points;
        m_cue_points = qq;
        cue_points_size = n;
     }
 
    CuePoint* const pCP = new CuePoint(m_preload_count, pos);
    m_cue_points[m_preload_count++] = pCP;
 }
","    long& cue_points_size,
    long long pos) const
{
    assert(m_count == 0);
    if (m_preload_count >= cue_points_size)
    {
        const long n = (cue_points_size <= 0) ? 2048 : 2*cue_points_size;
        CuePoint** const qq = new CuePoint*[n];
        CuePoint** q = qq;  //beginning of target
        CuePoint** p = m_cue_points;                //beginning of source
        CuePoint** const pp = p + m_preload_count;  //end of source
        while (p != pp)
            *q++ = *p++;
        delete[] m_cue_points;
        m_cue_points = qq;
        cue_points_size = n;
    CuePoint* const pCP = new CuePoint(m_preload_count, pos);
    m_cue_points[m_preload_count++] = pCP;
"
"long Block::Frame::Read(IMkvReader* pReader, unsigned char* buf) const
{
    assert(pReader);
    assert(buf);
    const long status = pReader->Read(pos, len, buf);
    return status;
}
","{
    assert(pReader);
    assert(buf);
    const long status = pReader->Read(pos, len, buf);
    return status;
}
"
"long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len)
{
    assert(pReader);
    assert(pos >= 0);
 
    int status;
 
 
    len = 1;
 
    unsigned char b;
 
     status = pReader->Read(pos, 1, &b);
 
    if (status < 0)  //error or underflow
        return status;
    if (status > 0)  //interpreted as ""underflow""
        return E_BUFFER_NOT_FULL;
    if (b == 0)  //we can't handle u-int values larger than 8 bytes
        return E_FILE_FORMAT_INVALID;
    unsigned char m = 0x80;
    while (!(b & m))
    {
        m >>= 1;
        ++len;
     }
 
 
    long long result = b & (~m);
     ++pos;
 
    for (int i = 1; i < len; ++i)
    {
        status = pReader->Read(pos, 1, &b);
        if (status < 0)
        {
            len = 1;
            return status;
        }
        if (status > 0)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result <<= 8;
        result |= b;
        ++pos;
    }
    return result;
 }
","{
    assert(pReader);
    assert(pos >= 0);
    int status;
    len = 1;
    unsigned char b;
    if (status < 0)  //error or underflow
        return status;
    if (status > 0)  //interpreted as ""underflow""
        return E_BUFFER_NOT_FULL;
    if (b == 0)  //we can't handle u-int values larger than 8 bytes
        return E_FILE_FORMAT_INVALID;
    unsigned char m = 0x80;
    while (!(b & m))
    {
        m >>= 1;
        ++len;
    long long result = b & (~m);
    for (int i = 1; i < len; ++i)
    {
        status = pReader->Read(pos, 1, &b);
        if (status < 0)
        {
            len = 1;
            return status;
        }
        if (status > 0)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result <<= 8;
        result |= b;
        ++pos;
    }
    return result;
"
"long Track::Seek(
    long long time_ns,
    const BlockEntry*& pResult) const
{
    const long status = GetFirst(pResult);
 
    if (status < 0)  //buffer underflow, etc
        return status;
 
    assert(pResult);
 
    if (pResult->EOS())
        return 0;
 
    const Cluster* pCluster = pResult->GetCluster();
     assert(pCluster);
     assert(pCluster->GetIndex() >= 0);
 
    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
        return 0;
 
    Cluster** const clusters = m_pSegment->m_clusters;
    assert(clusters);
 
    const long count = m_pSegment->GetCount();  //loaded only, not preloaded
    assert(count > 0);
 
    Cluster** const i = clusters + pCluster->GetIndex();
    assert(i);
    assert(*i == pCluster);
     assert(pCluster->GetTime() <= time_ns);
 
    Cluster** const j = clusters + count;
 
    Cluster** lo = i;
    Cluster** hi = j;
 
    while (lo < hi)
    {
 
        Cluster** const mid = lo + (hi - lo) / 2;
        assert(mid < hi);
        pCluster = *mid;
        assert(pCluster);
        assert(pCluster->GetIndex() >= 0);
        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
        const long long t = pCluster->GetTime();
        if (t <= time_ns)
            lo = mid + 1;
        else
            hi = mid;
        assert(lo <= hi);
    }
    assert(lo == hi);
    assert(lo > i);
    assert(lo <= j);
    while (lo > i)
    {
        pCluster = *--lo;
        assert(pCluster);
        assert(pCluster->GetTime() <= time_ns);
        pResult = pCluster->GetEntry(this);
        if ((pResult != 0) && !pResult->EOS())
            return 0;
    }
    pResult = GetEOS();  //weird
    return 0;
 }
","    long long time_ns,
    const BlockEntry*& pResult) const
{
    const long status = GetFirst(pResult);
    if (status < 0)  //buffer underflow, etc
        return status;
    assert(pResult);
    if (pResult->EOS())
        return 0;
    const Cluster* pCluster = pResult->GetCluster();
    if (time_ns <= pResult->GetBlock()->GetTime(pCluster))
        return 0;
    Cluster** const clusters = m_pSegment->m_clusters;
    assert(clusters);
    const long count = m_pSegment->GetCount();  //loaded only, not preloaded
    assert(count > 0);
    Cluster** const i = clusters + pCluster->GetIndex();
    assert(i);
    assert(*i == pCluster);
    Cluster** const j = clusters + count;
    Cluster** lo = i;
    Cluster** hi = j;
    while (lo < hi)
    {
        Cluster** const mid = lo + (hi - lo) / 2;
        assert(mid < hi);
        pCluster = *mid;
        assert(pCluster);
        assert(pCluster->GetIndex() >= 0);
        assert(pCluster->GetIndex() == long(mid - m_pSegment->m_clusters));
        const long long t = pCluster->GetTime();
        if (t <= time_ns)
            lo = mid + 1;
        else
            hi = mid;
        assert(lo <= hi);
    }
    assert(lo == hi);
    assert(lo > i);
    assert(lo <= j);
    while (lo > i)
    {
        pCluster = *--lo;
        assert(pCluster);
        assert(pCluster->GetTime() <= time_ns);
        pResult = pCluster->GetEntry(this);
        if ((pResult != 0) && !pResult->EOS())
            return 0;
    }
    pResult = GetEOS();  //weird
    return 0;
"
"SeekHead::SeekHead(
    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_entries(0),
    m_entry_count(0),
    m_void_elements(0),
    m_void_element_count(0)
{
 }
","    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_entries(0),
    m_entry_count(0),
    m_void_elements(0),
    m_void_element_count(0)
{
"
"Segment::Segment(
    IMkvReader* pReader,
    long long elem_start,
    long long start,
    long long size) :
    m_pReader(pReader),
    m_element_start(elem_start),
    m_start(start),
    m_size(size),
    m_pos(start),
    m_pUnknownSize(0),
    m_pSeekHead(NULL),
    m_pInfo(NULL),
    m_pTracks(NULL),
    m_pCues(NULL),
    m_pChapters(NULL),
    m_clusters(NULL),
    m_clusterCount(0),
    m_clusterPreloadCount(0),
    m_clusterSize(0)
{
}
","    IMkvReader* pReader,
    long long elem_start,
    long long start,
    long long size) :
    m_pReader(pReader),
    m_element_start(elem_start),
    m_start(start),
    m_size(size),
    m_pos(start),
    m_pUnknownSize(0),
    m_pSeekHead(NULL),
    m_pInfo(NULL),
    m_pTracks(NULL),
    m_pCues(NULL),
    m_pChapters(NULL),
    m_clusters(NULL),
    m_clusterCount(0),
    m_clusterPreloadCount(0),
    m_clusterSize(0)
{
}
"
"SegmentInfo::SegmentInfo(
    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_pMuxingAppAsUTF8(NULL),
    m_pWritingAppAsUTF8(NULL),
    m_pTitleAsUTF8(NULL)
{
}
","    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_pMuxingAppAsUTF8(NULL),
    m_pWritingAppAsUTF8(NULL),
    m_pTitleAsUTF8(NULL)
{
}
"
"void Block::SetKey(bool bKey)
{
    if (bKey)
        m_flags |= static_cast<unsigned char>(1 << 7);
    else
        m_flags &= 0x7F;
 }
","{
    if (bKey)
        m_flags |= static_cast<unsigned char>(1 << 7);
    else
        m_flags &= 0x7F;
"
"void Chapters::Edition::ShallowCopy(Edition& rhs) const
{
    rhs.m_atoms = m_atoms;
    rhs.m_atoms_size = m_atoms_size;
    rhs.m_atoms_count = m_atoms_count;
 }
","{
    rhs.m_atoms = m_atoms;
    rhs.m_atoms_size = m_atoms_size;
    rhs.m_atoms_count = m_atoms_count;
"
"void Chapters::Atom::ShallowCopy(Atom& rhs) const
{
    rhs.m_string_uid = m_string_uid;
    rhs.m_uid = m_uid;
    rhs.m_start_timecode = m_start_timecode;
    rhs.m_stop_timecode = m_stop_timecode;
    rhs.m_displays = m_displays;
    rhs.m_displays_size = m_displays_size;
    rhs.m_displays_count = m_displays_count;
}
","{
    rhs.m_string_uid = m_string_uid;
    rhs.m_uid = m_uid;
    rhs.m_start_timecode = m_start_timecode;
    rhs.m_stop_timecode = m_stop_timecode;
    rhs.m_displays = m_displays;
    rhs.m_displays_size = m_displays_size;
    rhs.m_displays_count = m_displays_count;
}
"
"void Chapters::Display::ShallowCopy(Display& rhs) const
{
    rhs.m_string = m_string;
    rhs.m_language = m_language;
    rhs.m_country = m_country;
}
","{
    rhs.m_string = m_string;
    rhs.m_language = m_language;
    rhs.m_country = m_country;
}
"
"SimpleBlock::SimpleBlock(
    Cluster* pCluster,
    long idx,
    long long start,
    long long size) :
    BlockEntry(pCluster, idx),
    m_block(start, size, 0)
{
}
","    Cluster* pCluster,
    long idx,
    long long start,
    long long size) :
    BlockEntry(pCluster, idx),
    m_block(start, size, 0)
{
}
"
"Track::Track(
    Segment* pSegment,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_element_start(element_start),
    m_element_size(element_size),
    content_encoding_entries_(NULL),
    content_encoding_entries_end_(NULL)
{
 }
","    Segment* pSegment,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_element_start(element_start),
    m_element_size(element_size),
    content_encoding_entries_(NULL),
    content_encoding_entries_end_(NULL)
{
"
"Tracks::Tracks(
    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_trackEntries(NULL),
    m_trackEntriesEnd(NULL)
{
}
","    Segment* pSegment,
    long long start,
    long long size_,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(start),
    m_size(size_),
    m_element_start(element_start),
    m_element_size(element_size),
    m_trackEntries(NULL),
    m_trackEntriesEnd(NULL)
{
}
"
"long mkvparser::UnserializeFloat(
    IMkvReader* pReader,
    long long pos,
    long long size_,
    double& result)
{
    assert(pReader);
    assert(pos >= 0);
 
    if ((size_ != 4) && (size_ != 8))
        return E_FILE_FORMAT_INVALID;
 
    const long size = static_cast<long>(size_);
 
    unsigned char buf[8];
 
    const int status = pReader->Read(pos, size, buf);
 
    if (status < 0)  //error
        return status;
 
    if (size == 4)
    {
        union
        {
            float f;
            unsigned long ff;
        };
 
        ff = 0;
 
        for (int i = 0;;)
        {
            ff |= buf[i];
 
            if (++i >= 4)
                break;
 
            ff <<= 8;
        }
        result = f;
    }
    else
    {
        assert(size == 8);
        union
        {
            double d;
            unsigned long long dd;
        };
        dd = 0;
        for (int i = 0;;)
        {
            dd |= buf[i];
            if (++i >= 8)
                break;
            dd <<= 8;
        }
        result = d;
    }
    return 0;
 }
","    IMkvReader* pReader,
    long long pos,
    long long size_,
    double& result)
{
    assert(pReader);
    assert(pos >= 0);
    if ((size_ != 4) && (size_ != 8))
        return E_FILE_FORMAT_INVALID;
    const long size = static_cast<long>(size_);
    unsigned char buf[8];
    const int status = pReader->Read(pos, size, buf);
    if (status < 0)  //error
        return status;
    if (size == 4)
    {
        union
        {
            float f;
            unsigned long ff;
        };
        ff = 0;
        for (int i = 0;;)
        {
            ff |= buf[i];
            if (++i >= 4)
                break;
            ff <<= 8;
        }
        result = f;
    }
    else
    {
        assert(size == 8);
        union
        {
            double d;
            unsigned long long dd;
        };
        dd = 0;
        for (int i = 0;;)
        {
            dd |= buf[i];
            if (++i >= 8)
                break;
            dd <<= 8;
        }
        result = d;
    }
    return 0;
"
"long mkvparser::UnserializeInt(
    IMkvReader* pReader,
    long long pos,
    long size,
    long long& result)
{
    assert(pReader);
    assert(pos >= 0);
    assert(size > 0);
    assert(size <= 8);
 
    {
        signed char b;
 
        const long status = pReader->Read(pos, 1, (unsigned char*)&b);
 
        if (status < 0)
            return status;
 
        result = b;
 
        ++pos;
    }
 
    for (long i = 1; i < size; ++i)
    {
        unsigned char b;
        const long status = pReader->Read(pos, 1, &b);
        if (status < 0)
            return status;
        result <<= 8;
        result |= b;
        ++pos;
    }
    return 0;  //success
}
","    IMkvReader* pReader,
    long long pos,
    long size,
    long long& result)
{
    assert(pReader);
    assert(pos >= 0);
    assert(size > 0);
    assert(size <= 8);
    {
        signed char b;
        const long status = pReader->Read(pos, 1, (unsigned char*)&b);
        if (status < 0)
            return status;
        result = b;
        ++pos;
    }
    for (long i = 1; i < size; ++i)
    {
        unsigned char b;
        const long status = pReader->Read(pos, 1, &b);
        if (status < 0)
            return status;
        result <<= 8;
        result |= b;
        ++pos;
    }
    return 0;  //success
}
"
"long mkvparser::UnserializeString(
    IMkvReader* pReader,
    long long pos,
    long long size_,
    char*& str)
{
     delete[] str;
     str = NULL;
 
    if (size_ >= LONG_MAX)  //we need (size+1) chars
        return E_FILE_FORMAT_INVALID;
 
    const long size = static_cast<long>(size_);
 
    str = new (std::nothrow) char[size+1];
    if (str == NULL)
        return -1;
    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
    const long status = pReader->Read(pos, size, buf);
    if (status)
    {
        delete[] str;
        str = NULL;
        return status;
    }
    str[size] = '\0';
    return 0;  //success
 }
","    IMkvReader* pReader,
    long long pos,
    long long size_,
    char*& str)
{
    if (size_ >= LONG_MAX)  //we need (size+1) chars
        return E_FILE_FORMAT_INVALID;
    const long size = static_cast<long>(size_);
    str = new (std::nothrow) char[size+1];
    if (str == NULL)
        return -1;
    unsigned char* const buf = reinterpret_cast<unsigned char*>(str);
    const long status = pReader->Read(pos, size, buf);
    if (status)
    {
        delete[] str;
        str = NULL;
        return status;
    }
    str[size] = '\0';
    return 0;  //success
"
"long long mkvparser::UnserializeUInt(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    assert(pReader);
    assert(pos >= 0);
 
    if ((size <= 0) || (size > 8))
        return E_FILE_FORMAT_INVALID;
 
    long long result = 0;
 
    for (long long i = 0; i < size; ++i)
    {
        unsigned char b;
 
        const long status = pReader->Read(pos, 1, &b);
 
        if (status < 0)
            return status;
 
        result <<= 8;
        result |= b;
 
        ++pos;
     }
 
    return result;
 }
","    IMkvReader* pReader,
    long long pos,
    long long size)
{
    assert(pReader);
    assert(pos >= 0);
    if ((size <= 0) || (size > 8))
        return E_FILE_FORMAT_INVALID;
    long long result = 0;
    for (long long i = 0; i < size; ++i)
    {
        unsigned char b;
        const long status = pReader->Read(pos, 1, &b);
        if (status < 0)
            return status;
        result <<= 8;
        result |= b;
        ++pos;
    return result;
"
"bool Track::VetEntry(const BlockEntry* pBlockEntry) const
{
    assert(pBlockEntry);
    const Block* const pBlock = pBlockEntry->GetBlock();
    assert(pBlock);
    assert(pBlock->GetTrackNumber() == m_info.number);
    if (!pBlock || pBlock->GetTrackNumber() != m_info.number)
        return false;
 
 
    return true;
 }
","{
    assert(pBlockEntry);
    const Block* const pBlock = pBlockEntry->GetBlock();
    assert(pBlock);
    assert(pBlock->GetTrackNumber() == m_info.number);
    if (!pBlock || pBlock->GetTrackNumber() != m_info.number)
        return false;
    return true;
"
"bool VideoTrack::VetEntry(const BlockEntry* pBlockEntry) const
{
    return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();
}
","{
    return Track::VetEntry(pBlockEntry) && pBlockEntry->GetBlock()->IsKey();
}
"
"VideoTrack::VideoTrack(
    Segment* pSegment,
    long long element_start,
    long long element_size) :
    Track(pSegment, element_start, element_size)
{
}
","    Segment* pSegment,
    long long element_start,
    long long element_size) :
    Track(pSegment, element_start, element_size)
{
}
"
"Chapters::Atom::~Atom()
{
 }
","{
"
"Block::~Block()
{
    delete[] m_frames;
}
","{
    delete[] m_frames;
}
"
"BlockEntry::~BlockEntry()
{
}
","{
}
"
"Chapters::~Chapters()
{
    while (m_editions_count > 0)
    {
        Edition& e = m_editions[--m_editions_count];
        e.Clear();
    }
}
","{
    while (m_editions_count > 0)
    {
        Edition& e = m_editions[--m_editions_count];
        e.Clear();
    }
}
"
"Cluster::~Cluster()
{
    if (m_entries_count <= 0)
        return;
    BlockEntry** i = m_entries;
    BlockEntry** const j = m_entries + m_entries_count;
    while (i != j)
    {
         BlockEntry* p = *i++;
         assert(p);
         delete p;
     }
 
    delete[] m_entries;
 }
","{
    if (m_entries_count <= 0)
        return;
    BlockEntry** i = m_entries;
    BlockEntry** const j = m_entries + m_entries_count;
    while (i != j)
    {
         BlockEntry* p = *i++;
         assert(p);
         delete p;
    delete[] m_entries;
"
" ContentEncoding::ContentCompression::~ContentCompression() {
  delete [] settings;
 }
","  delete [] settings;
"
" ContentEncoding::~ContentEncoding() {
   ContentCompression** comp_i = compression_entries_;
 ContentCompression** const comp_j = compression_entries_end_;

 while (comp_i != comp_j) {
 ContentCompression* const comp = *comp_i++;

     delete comp;
   }
 
  delete [] compression_entries_;
 
   ContentEncryption** enc_i = encryption_entries_;
   ContentEncryption** const enc_j = encryption_entries_end_;

 while (enc_i != enc_j) {
 ContentEncryption* const enc = *enc_i++;

     delete enc;
   }
 
  delete [] encryption_entries_;
 }
","  delete [] compression_entries_;
  delete [] encryption_entries_;
"
" ContentEncoding::ContentEncryption::~ContentEncryption() {
  delete [] key_id;
  delete [] signature;
  delete [] sig_key_id;
 }
","  delete [] key_id;
  delete [] signature;
  delete [] sig_key_id;
"
"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}
","{
    delete[] m_track_positions;
}
"
"Cues::~Cues()
{
    const long n = m_count + m_preload_count;
 
    CuePoint** p = m_cue_points;
    CuePoint** const q = p + n;
 
    while (p != q)
    {
        CuePoint* const pCP = *p++;
        assert(pCP);
 
        delete pCP;
    }
 
     delete[] m_cue_points;
 }
","{
    const long n = m_count + m_preload_count;
    CuePoint** p = m_cue_points;
    CuePoint** const q = p + n;
    while (p != q)
    {
        CuePoint* const pCP = *p++;
        assert(pCP);
        delete pCP;
    }
"
"Chapters::Display::~Display()
{
}
","{
}
"
"EBMLHeader::~EBMLHeader()
{
     delete[] m_docType;
 }
","{
"
"Chapters::Edition::~Edition()
{
 }
","{
"
"mkvparser::IMkvReader::~IMkvReader()
{
//// Disable MSVC warnings that suggest making code non-portable.
 }
","{
"
"Track::Info::~Info()
{
    Clear();
}
","{
    Clear();
}
"
"SeekHead::~SeekHead()
{
    delete[] m_entries;
    delete[] m_void_elements;
 }
","{
    delete[] m_entries;
    delete[] m_void_elements;
"
"Segment::~Segment()
{
    const long count = m_clusterCount + m_clusterPreloadCount;
 
    Cluster** i = m_clusters;
    Cluster** j = m_clusters + count;
 
    while (i != j)
    {
        Cluster* const p = *i++;
        assert(p);
 
        delete p;
    }
 
    delete[] m_clusters;
 
    delete m_pTracks;
    delete m_pInfo;
    delete m_pCues;
    delete m_pChapters;
    delete m_pSeekHead;
}
","{
    const long count = m_clusterCount + m_clusterPreloadCount;
    Cluster** i = m_clusters;
    Cluster** j = m_clusters + count;
    while (i != j)
    {
        Cluster* const p = *i++;
        assert(p);
        delete p;
    }
    delete[] m_clusters;
    delete m_pTracks;
    delete m_pInfo;
    delete m_pCues;
    delete m_pChapters;
    delete m_pSeekHead;
}
"
"SegmentInfo::~SegmentInfo()
{
    delete[] m_pMuxingAppAsUTF8;
    m_pMuxingAppAsUTF8 = NULL;
    delete[] m_pWritingAppAsUTF8;
    m_pWritingAppAsUTF8 = NULL;
    delete[] m_pTitleAsUTF8;
    m_pTitleAsUTF8 = NULL;
}
","{
    delete[] m_pMuxingAppAsUTF8;
    m_pMuxingAppAsUTF8 = NULL;
    delete[] m_pWritingAppAsUTF8;
    m_pWritingAppAsUTF8 = NULL;
    delete[] m_pTitleAsUTF8;
    m_pTitleAsUTF8 = NULL;
}
"
"Track::~Track()
{
    Info& info = const_cast<Info&>(m_info);
    info.Clear();
 
    ContentEncoding** i = content_encoding_entries_;
    ContentEncoding** const j = content_encoding_entries_end_;
 
    while (i != j) {
        ContentEncoding* const encoding = *i++;
        delete encoding;
    }
 
    delete [] content_encoding_entries_;
 }
","{
    Info& info = const_cast<Info&>(m_info);
    info.Clear();
    ContentEncoding** i = content_encoding_entries_;
    ContentEncoding** const j = content_encoding_entries_end_;
    while (i != j) {
        ContentEncoding* const encoding = *i++;
        delete encoding;
    }
    delete [] content_encoding_entries_;
"
"Tracks::~Tracks()
{
    Track** i = m_trackEntries;
    Track** const j = m_trackEntriesEnd;
    while (i != j)
    {
        Track* const pTrack = *i++;
        delete pTrack;
    }
    delete[] m_trackEntries;
}
","{
    Track** i = m_trackEntries;
    Track** const j = m_trackEntriesEnd;
    while (i != j)
    {
        Track* const pTrack = *i++;
        delete pTrack;
    }
    delete[] m_trackEntries;
}
"
"int main(int argc, char **argv) {
 int frame_cnt = 0;
 FILE *outfile = NULL;
 vpx_codec_ctx_t codec;
 VpxVideoReader *reader = NULL;
 const VpxVideoInfo *info = NULL;
 const VpxInterface *decoder = NULL;

  exec_name = argv[0];

 if (argc != 3)
    die(""Invalid number of arguments."");

  reader = vpx_video_reader_open(argv[1]);
 if (!reader)
    die(""Failed to open %s for reading."", argv[1]);

 if (!(outfile = fopen(argv[2], ""wb"")))
    die(""Failed to open %s for writing."", argv[2]);

  info = vpx_video_reader_get_info(reader);

  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);

   if (!decoder)
     die(""Unknown input codec."");
 
  printf(""Using %s\n"", vpx_codec_iface_name(decoder->interface()));
 
  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
     die_codec(&codec, ""Failed to initialize decoder"");
 
   while (vpx_video_reader_read_frame(reader)) {
 vpx_codec_iter_t iter = NULL;
 vpx_image_t *img = NULL;
 size_t frame_size = 0;
 const unsigned char *frame = vpx_video_reader_get_frame(reader,
 &frame_size);
 if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))
      die_codec(&codec, ""Failed to decode frame"");

 while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {
 unsigned char digest[16];

      get_image_md5(img, digest);
      print_md5(outfile, digest);
      fprintf(outfile, ""  img-%dx%d-%04d.i420\n"",
              img->d_w, img->d_h, ++frame_cnt);
 }
 }

  printf(""Processed %d frames.\n"", frame_cnt);
 if (vpx_codec_destroy(&codec))
    die_codec(&codec, ""Failed to destroy codec."");

  vpx_video_reader_close(reader);

  fclose(outfile);
 return EXIT_SUCCESS;
}
","  printf(""Using %s\n"", vpx_codec_iface_name(decoder->interface()));
  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
"
"static void usage(char *progname) {
   printf(""Usage:\n"");
   printf(""%s <input_yuv> <width>x<height> <target_width>x<target_height> "",
         progname);
   printf(""<output_yuv> [<frames>]\n"");
 }
","         progname);
"
"static void encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         VpxVideoWriter *writer) {
   vpx_codec_iter_t iter = NULL;
   const vpx_codec_cx_pkt_t *pkt = NULL;
   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1, 0,
                                               VPX_DL_GOOD_QUALITY);
 if (res != VPX_CODEC_OK)

     die_codec(codec, ""Failed to encode frame"");
 
   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {
     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
       if (!vpx_video_writer_write_frame(writer,
                                        pkt->data.frame.buf,
                                        pkt->data.frame.sz,
                                        pkt->data.frame.pts)) {
        die_codec(codec, ""Failed to write compressed frame"");
 }

      printf(keyframe ? ""K"" : ""."");

       fflush(stdout);
     }
   }
 }
","                         vpx_image_t *img,
                         int frame_index,
                         VpxVideoWriter *writer) {
"
" static void set_active_map(const vpx_codec_enc_cfg_t *cfg,
                            vpx_codec_ctx_t *codec) {
   unsigned int i;
  vpx_active_map_t map = {0};
 
   map.rows = (cfg->g_h + 15) / 16;
   map.cols = (cfg->g_w + 15) / 16;

 map.active_map = (uint8_t *)malloc(map.rows * map.cols);
 for (i = 0; i < map.rows * map.cols; ++i)
 map.active_map[i] = i % 2;

 if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))
    die_codec(codec, ""Failed to set active map"");

  free(map.active_map);
}
","  vpx_active_map_t map = {0};
"
" static void set_roi_map(const vpx_codec_enc_cfg_t *cfg,
                         vpx_codec_ctx_t *codec) {
   unsigned int i;
  vpx_roi_map_t roi = {0};
 
   roi.rows = (cfg->g_h + 15) / 16;
   roi.cols = (cfg->g_w + 15) / 16;

  roi.delta_q[0] = 0;
  roi.delta_q[1] = -2;
  roi.delta_q[2] = -4;
  roi.delta_q[3] = -6;

  roi.delta_lf[0] = 0;
  roi.delta_lf[1] = 1;
  roi.delta_lf[2] = 2;
  roi.delta_lf[3] = 3;

  roi.static_threshold[0] = 1500;
  roi.static_threshold[1] = 1000;
  roi.static_threshold[2] = 500;
  roi.static_threshold[3] = 0;

  roi.roi_map = (uint8_t *)malloc(roi.rows * roi.cols);
 for (i = 0; i < roi.rows * roi.cols; ++i)
    roi.roi_map[i] = i % 4;

 if (vpx_codec_control(codec, VP8E_SET_ROI_MAP, &roi))
    die_codec(codec, ""Failed to set ROI map"");

  free(roi.roi_map);
}
","  vpx_roi_map_t roi = {0};
"
" static void unset_active_map(const vpx_codec_enc_cfg_t *cfg,
                              vpx_codec_ctx_t *codec) {
  vpx_active_map_t map = {0};
 
   map.rows = (cfg->g_h + 15) / 16;
   map.cols = (cfg->g_w + 15) / 16;
 map.active_map = NULL;

 if (vpx_codec_control(codec, VP8E_SET_ACTIVEMAP, &map))

     die_codec(codec, ""Failed to set active map"");
 }
","  vpx_active_map_t map = {0};
"
"int main(int argc, char **argv) {
 int frame_cnt = 0;
 FILE *outfile = NULL;
 vpx_codec_ctx_t codec;
 VpxVideoReader *reader = NULL;
 const VpxInterface *decoder = NULL;
 const VpxVideoInfo *info = NULL;

  exec_name = argv[0];

 if (argc != 3)
    die(""Invalid number of arguments."");

  reader = vpx_video_reader_open(argv[1]);
 if (!reader)
    die(""Failed to open %s for reading."", argv[1]);

 if (!(outfile = fopen(argv[2], ""wb"")))
    die(""Failed to open %s for writing."", argv[2]);

  info = vpx_video_reader_get_info(reader);

  decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);

   if (!decoder)
     die(""Unknown input codec."");
 
  printf(""Using %s\n"", vpx_codec_iface_name(decoder->interface()));
 
  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
     die_codec(&codec, ""Failed to initialize decoder."");
 
   while (vpx_video_reader_read_frame(reader)) {
 vpx_codec_iter_t iter = NULL;
 vpx_image_t *img = NULL;
 size_t frame_size = 0;
 const unsigned char *frame = vpx_video_reader_get_frame(reader,
 &frame_size);
 if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))
      die_codec(&codec, ""Failed to decode frame."");

 while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {
      vpx_img_write(img, outfile);
 ++frame_cnt;
 }
 }

  printf(""Processed %d frames.\n"", frame_cnt);
 if (vpx_codec_destroy(&codec))
    die_codec(&codec, ""Failed to destroy codec"");

  printf(""Play: ffplay -f rawvideo -pix_fmt yuv420p -s %dx%d %s\n"",
         info->frame_width, info->frame_height, argv[2]);

  vpx_video_reader_close(reader);

  fclose(outfile);

 return EXIT_SUCCESS;
}
","  printf(""Using %s\n"", vpx_codec_iface_name(decoder->interface()));
  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
"
"static void encode_frame(vpx_codec_ctx_t *codec,
                         vpx_image_t *img,
                         int frame_index,
                         int flags,
                         VpxVideoWriter *writer) {
   vpx_codec_iter_t iter = NULL;
   const vpx_codec_cx_pkt_t *pkt = NULL;
   const vpx_codec_err_t res = vpx_codec_encode(codec, img, frame_index, 1,
                                               flags, VPX_DL_GOOD_QUALITY);
 if (res != VPX_CODEC_OK)

     die_codec(codec, ""Failed to encode frame"");
 
   while ((pkt = vpx_codec_get_cx_data(codec, &iter)) != NULL) {
     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
       if (!vpx_video_writer_write_frame(writer,
                                        pkt->data.frame.buf,
                                        pkt->data.frame.sz,

                                         pkt->data.frame.pts)) {
         die_codec(codec, ""Failed to write compressed frame"");
       }
       printf(keyframe ? ""K"" : ""."");
       fflush(stdout);
     }
   }
 }
","                         vpx_image_t *img,
                         int frame_index,
                         int flags,
                         VpxVideoWriter *writer) {
"
"static void encode_frame(vpx_codec_ctx_t *ctx,
                         const vpx_image_t *img,
                         vpx_codec_pts_t pts,
                         unsigned int duration,
                         vpx_enc_frame_flags_t flags,
                         unsigned int deadline,
                         VpxVideoWriter *writer) {
   vpx_codec_iter_t iter = NULL;
   const vpx_codec_cx_pkt_t *pkt = NULL;
   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,
                                               deadline);
 if (res != VPX_CODEC_OK)

     die_codec(ctx, ""Failed to encode frame."");
 
   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {
     if (pkt->kind == VPX_CODEC_CX_FRAME_PKT) {
       const int keyframe = (pkt->data.frame.flags & VPX_FRAME_IS_KEY) != 0;
 
 if (!vpx_video_writer_write_frame(writer, pkt->data.frame.buf,
                                                pkt->data.frame.sz,
                                                pkt->data.frame.pts))
        die_codec(ctx, ""Failed to write compressed frame."");
      printf(keyframe ? ""K"" : ""."");

       fflush(stdout);
     }
   }
 }
","                         const vpx_image_t *img,
                         vpx_codec_pts_t pts,
                         unsigned int duration,
                         vpx_enc_frame_flags_t flags,
                         unsigned int deadline,
                         VpxVideoWriter *writer) {
"
"static void get_frame_stats(vpx_codec_ctx_t *ctx,
                            const vpx_image_t *img,
                            vpx_codec_pts_t pts,
                            unsigned int duration,
                            vpx_enc_frame_flags_t flags,
                            unsigned int deadline,
                            vpx_fixed_buf_t *stats) {
   vpx_codec_iter_t iter = NULL;
   const vpx_codec_cx_pkt_t *pkt = NULL;
   const vpx_codec_err_t res = vpx_codec_encode(ctx, img, pts, duration, flags,
                                               deadline);
 if (res != VPX_CODEC_OK)

     die_codec(ctx, ""Failed to get frame stats."");
 
   while ((pkt = vpx_codec_get_cx_data(ctx, &iter)) != NULL) {
     if (pkt->kind == VPX_CODEC_STATS_PKT) {
       const uint8_t *const pkt_buf = pkt->data.twopass_stats.buf;
       const size_t pkt_size = pkt->data.twopass_stats.sz;
      stats->buf = realloc(stats->buf, stats->sz + pkt_size);
      memcpy((uint8_t *)stats->buf + stats->sz, pkt_buf, pkt_size);

       stats->sz += pkt_size;
     }
   }
 }
","                            const vpx_image_t *img,
                            vpx_codec_pts_t pts,
                            unsigned int duration,
                            vpx_enc_frame_flags_t flags,
                            unsigned int deadline,
                            vpx_fixed_buf_t *stats) {
"
"static void die(const char *fmt, ...) {
    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    if(fmt[strlen(fmt)-1] != '\n')
        printf(""\n"");
    exit(EXIT_FAILURE);
}
","    va_list ap;
    va_start(ap, fmt);
    vprintf(fmt, ap);
    if(fmt[strlen(fmt)-1] != '\n')
        printf(""\n"");
    exit(EXIT_FAILURE);
}
"
"static void die_codec(vpx_codec_ctx_t *ctx, const char *s) {
    const char *detail = vpx_codec_error_detail(ctx);
    printf(""%s: %s\n"", s, vpx_codec_error(ctx));
    if(detail)
        printf(""    %s\n"",detail);
    exit(EXIT_FAILURE);
}
","    const char *detail = vpx_codec_error_detail(ctx);
    printf(""%s: %s\n"", s, vpx_codec_error(ctx));
    if(detail)
        printf(""    %s\n"",detail);
    exit(EXIT_FAILURE);
}
"
"  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {
    }
  }
","    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {
    }
  }
"
"  ConvolveFunctions(convolve_fn_t h8, convolve_fn_t h8_avg,
                    convolve_fn_t v8, convolve_fn_t v8_avg,
                    convolve_fn_t hv8, convolve_fn_t hv8_avg)
      : h8_(h8), v8_(v8), hv8_(hv8), h8_avg_(h8_avg), v8_avg_(v8_avg),
        hv8_avg_(hv8_avg) {}
","                    convolve_fn_t v8, convolve_fn_t v8_avg,
                    convolve_fn_t hv8, convolve_fn_t hv8_avg)
      : h8_(h8), v8_(v8), hv8_(hv8), h8_avg_(h8_avg), v8_avg_(v8_avg),
        hv8_avg_(hv8_avg) {}
"
"   virtual void SetUp() {
     UUT_ = GET_PARAM(2);
     /* Set up guard blocks for an inner block centered in the outer block */
     for (int i = 0; i < kOutputBufferSize; ++i) {
       if (IsIndexInBorder(i))
        output_[i] = 255;
 else
        output_[i] = 0;

     }
 
     ::libvpx_test::ACMRandom prng;
    for (int i = 0; i < kInputBufferSize; ++i)
      input_[i] = prng.Rand8Extremes();
   }
","    for (int i = 0; i < kInputBufferSize; ++i)
      input_[i] = prng.Rand8Extremes();
"
"void filter_average_block2d_8_c(const uint8_t *src_ptr,
 const unsigned int src_stride,
 const int16_t *HFilter,
 const int16_t *VFilter,
 uint8_t *dst_ptr,

                                 unsigned int dst_stride,
                                 unsigned int output_width,
                                 unsigned int output_height) {
  uint8_t tmp[64 * 64];
 
  assert(output_width <= 64);
  assert(output_height <= 64);
   filter_block2d_8_c(src_ptr, src_stride, HFilter, VFilter, tmp, 64,
                      output_width, output_height);
   block2d_average_c(tmp, 64, dst_ptr, dst_stride,
                     output_width, output_height);
 }
","  uint8_t tmp[64 * 64];
  assert(output_width <= 64);
  assert(output_height <= 64);
"
"  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {
    }
   }
","    if (pkt->data.frame.flags & VPX_FRAME_IS_KEY) {
    }
"
"   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,
                                   ::libvpx_test::Encoder *encoder) {
     if (video->frame() == 1) {
       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);
      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);
      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);
      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);
      encoder->Control(VP8E_SET_ARNR_TYPE, 3);
     }
   }
","      encoder->Control(VP8E_SET_ENABLEAUTOALTREF, 1);
      encoder->Control(VP8E_SET_ARNR_MAXFRAMES, 7);
      encoder->Control(VP8E_SET_ARNR_STRENGTH, 5);
      encoder->Control(VP8E_SET_ARNR_TYPE, 3);
"
"   virtual void SetUp() {
     InitializeConfig();
    SetMode(GET_PARAM(1));
    set_cpu_used_ = GET_PARAM(2);
   }
","    SetMode(GET_PARAM(1));
    set_cpu_used_ = GET_PARAM(2);
"
"   virtual void PreEncodeFrameHook(::libvpx_test::VideoSource *video,
                                   ::libvpx_test::Encoder *encoder) {
    if (video->frame() == 1) {
       encoder->Control(VP8E_SET_CPUUSED, set_cpu_used_);
     }
     if (cfg_.ts_number_layers > 1) {
      if (video->frame() == 1) {
         encoder->Control(VP9E_SET_SVC, 1);
       }
      vpx_svc_layer_id_t layer_id = {0, 0};
       layer_id.spatial_layer_id = 0;
       frame_flags_ = SetFrameFlags(video->frame(), cfg_.ts_number_layers);
       layer_id.temporal_layer_id = SetLayerId(video->frame(),
                                               cfg_.ts_number_layers);
      if (video->frame() > 0) {
       encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);
      }
     }
     const vpx_rational_t tb = video->timebase();
     timebase_ = static_cast<double>(tb.num) / tb.den;
    duration_ = 0;
 }
","    if (video->frame() == 1) {
      if (video->frame() == 1) {
      vpx_svc_layer_id_t layer_id = {0, 0};
      if (video->frame() > 0) {
       encoder->Control(VP9E_SET_SVC_LAYER_ID, &layer_id);
      }
"
"   void RunAccuracyCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
 uint32_t max_error = 0;

     int64_t total_error = 0;
     const int count_test_block = 10000;
     for (int i = 0; i < count_test_block; ++i) {
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
 
       for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
       }
 
      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
                                      test_temp_block, pitch_));
      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         const uint32_t diff = dst[j] - src[j];
         const uint32_t error = diff * diff;
         if (max_error < error)
           max_error = error;
        total_error += error;

       }
     }
 
    EXPECT_GE(1u, max_error)
         << ""Error: 16x16 FHT/IHT has an individual round trip error > 1"";
 
    EXPECT_GE(count_test_block , total_error)
         << ""Error: 16x16 FHT/IHT has average round trip error > 1 per block"";
   }
","      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
                                      test_temp_block, pitch_));
      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));
    EXPECT_GE(1u, max_error)
    EXPECT_GE(count_test_block , total_error)
"
"   void RunCoeffCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
 
     for (int i = 0; i < count_test_block; ++i) {
       for (int j = 0; j < kNumCoeffs; ++j)
        input_block[j] = rnd.Rand8() - rnd.Rand8();
 
       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j)
        EXPECT_EQ(output_block[j], output_ref_block[j]);
 }
 }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
        input_block[j] = rnd.Rand8() - rnd.Rand8();
      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));
"
"   void RunInvAccuracyCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
 
     for (int i = 0; i < count_test_block; ++i) {
       double out_r[kNumCoeffs];
 
       for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        in[j] = src[j] - dst[j];
       }
 
       reference_16x16_dct_2d(in, out_r);
       for (int j = 0; j < kNumCoeffs; ++j)
        coeff[j] = round(out_r[j]);
 
      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         const uint32_t diff = dst[j] - src[j];
         const uint32_t error = diff * diff;
         EXPECT_GE(1u, error)
             << ""Error: 16x16 IDCT has error "" << error
 << "" at index "" << j;

       }
     }
   }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        in[j] = src[j] - dst[j];
        coeff[j] = round(out_r[j]);
      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, 16));
"
"   void RunMemCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
 
     for (int i = 0; i < count_test_block; ++i) {
       for (int j = 0; j < kNumCoeffs; ++j) {
        input_block[j] = rnd.Rand8() - rnd.Rand8();
        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;
       }
      if (i == 0)
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = 255;
      if (i == 1)
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = -255;
 
       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                      output_block, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         EXPECT_EQ(output_block[j], output_ref_block[j]);
        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))
             << ""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE"";
       }
     }
   }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
        input_block[j] = rnd.Rand8() - rnd.Rand8();
        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;
      if (i == 0)
          input_extreme_block[j] = 255;
      if (i == 1)
          input_extreme_block[j] = -255;
      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                      output_block, pitch_));
        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))
"
"void fdct16x16_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
  vp9_fdct16x16_c(in, out, stride);
 }
","  vp9_fdct16x16_c(in, out, stride);
"
"void reference_32x32_dct_2d(const int16_t input[kNumCoeffs],
 double output[kNumCoeffs]) {
 for (int i = 0; i < 32; ++i) {

     double temp_in[32], temp_out[32];
     for (int j = 0; j < 32; ++j)
       temp_in[j] = input[j*32 + i];
    reference_32x32_dct_1d(temp_in, temp_out, 1);
     for (int j = 0; j < 32; ++j)
       output[j * 32 + i] = temp_out[j];
   }
 for (int i = 0; i < 32; ++i) {

     double temp_in[32], temp_out[32];
     for (int j = 0; j < 32; ++j)
       temp_in[j] = output[j + i*32];
    reference_32x32_dct_1d(temp_in, temp_out, 1);
     for (int j = 0; j < 32; ++j)
       output[j + i * 32] = temp_out[j] / 4;
   }
 }
","    reference_32x32_dct_1d(temp_in, temp_out, 1);
    reference_32x32_dct_1d(temp_in, temp_out, 1);
"
" vpx_codec_err_t Decoder::DecodeFrame(const uint8_t *cxdata, size_t size) {
   vpx_codec_err_t res_dec;
   InitOnce();
  REGISTER_STATE_CHECK(
       res_dec = vpx_codec_decode(&decoder_,
                                  cxdata, static_cast<unsigned int>(size),
                                 NULL, 0));
   return res_dec;
 }
","  REGISTER_STATE_CHECK(
                                 NULL, 0));
"
"void DecoderTest::RunLoop(CompressedVideoSource *video) {
  vpx_codec_dec_cfg_t dec_cfg = {0};
  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);
   ASSERT_TRUE(decoder != NULL);
 
  for (video->Begin(); video->cxdata(); video->Next()) {
     PreDecodeFrameHook(*video, decoder);
    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),
                                                   video->frame_size());
    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();
 
     DxDataIterator dec_iter = decoder->GetDxData();
     const vpx_image_t *img = NULL;


     while ((img = dec_iter.Next()))
       DecompressedFrameHook(*img, video->frame_number());
   }
   delete decoder;
 }
","  vpx_codec_dec_cfg_t dec_cfg = {0};
  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);
  for (video->Begin(); video->cxdata(); video->Next()) {
    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),
                                                   video->frame_size());
    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();
"
"void Encoder::EncodeFrameInternal(const VideoSource &video,
 const unsigned long frame_flags) {

   vpx_codec_err_t res;
   const vpx_image_t *img = video.img();
 
  if (!encoder_.priv) {
    cfg_.g_w = img->d_w;
    cfg_.g_h = img->d_h;
    cfg_.g_timebase = video.timebase();
    cfg_.rc_twopass_stats_in = stats_->buf();
    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,
                             init_flags_);
    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
  }
   if (cfg_.g_w != img->d_w || cfg_.g_h != img->d_h) {
     cfg_.g_w = img->d_w;
    cfg_.g_h = img->d_h;
    res = vpx_codec_enc_config_set(&encoder_, &cfg_);
    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();

   }
 
  REGISTER_STATE_CHECK(
      res = vpx_codec_encode(&encoder_,
                             video.img(), video.pts(), video.duration(),
                              frame_flags, deadline_));
   ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
 }
","  if (!encoder_.priv) {
    cfg_.g_w = img->d_w;
    cfg_.g_h = img->d_h;
    cfg_.g_timebase = video.timebase();
    cfg_.rc_twopass_stats_in = stats_->buf();
    res = vpx_codec_enc_init(&encoder_, CodecInterface(), &cfg_,
                             init_flags_);
    ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
  }
  REGISTER_STATE_CHECK(
      res = vpx_codec_encode(&encoder_,
                             video.img(), video.pts(), video.duration(),
"
" void Encoder::Flush() {
   const vpx_codec_err_t res = vpx_codec_encode(&encoder_, NULL, 0, 0, 0,
                                                deadline_);
  ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
 }
","  ASSERT_EQ(VPX_CODEC_OK, res) << EncoderError();
"
"void EncoderTest::MismatchHook(const vpx_image_t *img1,
                               const vpx_image_t *img2) {
   ASSERT_TRUE(0) << ""Encode/Decode mismatch found"";
 }
","                               const vpx_image_t *img2) {
"
"  virtual void PreEncodeFrameHook(libvpx_test::VideoSource *video) {
     frame_flags_ &= ~(VP8_EFLAG_NO_UPD_LAST |
                       VP8_EFLAG_NO_UPD_GF |
                       VP8_EFLAG_NO_UPD_ARF);
    if (droppable_nframes_ > 0 &&
        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {
       for (unsigned int i = 0; i < droppable_nframes_; ++i) {
         if (droppable_frames_[i] == video->frame()) {
          std::cout << ""             Encoding droppable frame: ""
                     << droppable_frames_[i] << ""\n"";
          frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST |
                           VP8_EFLAG_NO_UPD_GF |
                           VP8_EFLAG_NO_UPD_ARF);
          return;
         }
       }
     }
   }
","    if (droppable_nframes_ > 0 &&
        (cfg_.g_pass == VPX_RC_LAST_PASS || cfg_.g_pass == VPX_RC_ONE_PASS)) {
          std::cout << ""             Encoding droppable frame: ""
          frame_flags_ |= (VP8_EFLAG_NO_UPD_LAST |
                           VP8_EFLAG_NO_UPD_GF |
                           VP8_EFLAG_NO_UPD_ARF);
          return;
"
"   int ReturnFrameBuffer(vpx_codec_frame_buffer_t *fb) {
    EXPECT_TRUE(fb != NULL);
     ExternalFrameBuffer *const ext_fb =
         reinterpret_cast<ExternalFrameBuffer*>(fb->priv);
    EXPECT_TRUE(ext_fb != NULL);
     EXPECT_EQ(1, ext_fb->in_use);
     ext_fb->in_use = 0;
     return 0;
 }
","    EXPECT_TRUE(fb != NULL);
    EXPECT_TRUE(ext_fb != NULL);
"
" virtual void SetUp() {
    video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);
    ASSERT_TRUE(video_ != NULL);

     video_->Init();
     video_->Begin();
 
    vpx_codec_dec_cfg_t cfg = {0};
     decoder_ = new libvpx_test::VP9Decoder(cfg, 0);
     ASSERT_TRUE(decoder_ != NULL);
   }
","    vpx_codec_dec_cfg_t cfg = {0};
"
"  void RunAccuracyCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     uint32_t max_error = 0;
     int64_t total_error = 0;
     const int count_test_block = 10000;
     for (int i = 0; i < count_test_block; ++i) {
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
 
       for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
       }
 
      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
                                      test_temp_block, pitch_));
      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         const uint32_t diff = dst[j] - src[j];
         const uint32_t error = diff * diff;
         if (max_error < error)
           max_error = error;
        total_error += error;

       }
     }
 
    EXPECT_GE(1u, max_error)
        << ""Error: 4x4 FHT/IHT has an individual round trip error > 1"";
 
    EXPECT_GE(count_test_block , total_error)
        << ""Error: 4x4 FHT/IHT has average round trip error > 1 per block"";
   }
","      DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
      DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
      REGISTER_STATE_CHECK(RunFwdTxfm(test_input_block,
                                      test_temp_block, pitch_));
      REGISTER_STATE_CHECK(RunInvTxfm(test_temp_block, dst, pitch_));
    EXPECT_GE(1u, max_error)
        << ""Error: 4x4 FHT/IHT has an individual round trip error > 1"";
    EXPECT_GE(count_test_block , total_error)
        << ""Error: 4x4 FHT/IHT has average round trip error > 1 per block"";
"
"   void RunCoeffCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 5000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
 
     for (int i = 0; i < count_test_block; ++i) {
       for (int j = 0; j < kNumCoeffs; ++j)
        input_block[j] = rnd.Rand8() - rnd.Rand8();
 
       fwd_txfm_ref(input_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j)
        EXPECT_EQ(output_block[j], output_ref_block[j]);
 }
 }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
        input_block[j] = rnd.Rand8() - rnd.Rand8();
      REGISTER_STATE_CHECK(RunFwdTxfm(input_block, output_block, pitch_));
"
"  void RunInvAccuracyCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 1000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
 
     for (int i = 0; i < count_test_block; ++i) {
       for (int j = 0; j < kNumCoeffs; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        in[j] = src[j] - dst[j];
       }
 
       fwd_txfm_ref(in, coeff, pitch_, tx_type_);
 
      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         const uint32_t diff = dst[j] - src[j];
         const uint32_t error = diff * diff;
        EXPECT_GE(1u, error)
            << ""Error: 16x16 IDCT has error "" << error
             << "" at index "" << j;
       }
     }
 }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, in, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, coeff, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, kNumCoeffs);
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        in[j] = src[j] - dst[j];
      REGISTER_STATE_CHECK(RunInvTxfm(coeff, dst, pitch_));
        EXPECT_GE(1u, error)
            << ""Error: 16x16 IDCT has error "" << error
"
"   void RunMemCheck() {
     ACMRandom rnd(ACMRandom::DeterministicSeed());
     const int count_test_block = 5000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
 
     for (int i = 0; i < count_test_block; ++i) {
       for (int j = 0; j < kNumCoeffs; ++j) {
        input_block[j] = rnd.Rand8() - rnd.Rand8();
        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;
       }
      if (i == 0)
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = 255;
      if (i == 1)
         for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = -255;
 
       fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                      output_block, pitch_));
 
       for (int j = 0; j < kNumCoeffs; ++j) {
         EXPECT_EQ(output_block[j], output_ref_block[j]);
        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))
            << ""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE"";
       }
     }
   }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);
        input_block[j] = rnd.Rand8() - rnd.Rand8();
        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;
      if (i == 0)
          input_extreme_block[j] = 255;
      if (i == 1)
          input_extreme_block[j] = -255;
      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                      output_block, pitch_));
        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))
            << ""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE"";
"
"void fdct4x4_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
  vp9_fdct4x4_c(in, out, stride);
 }
","  vp9_fdct4x4_c(in, out, stride);
"
" void RunExtremalCheck() {

     ACMRandom rnd(ACMRandom::DeterministicSeed());
     int max_error = 0;
     int total_error = 0;
     const int count_test_block = 100000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);
 
     for (int i = 0; i < count_test_block; ++i) {
       for (int j = 0; j < 64; ++j) {
        src[j] = rnd.Rand8() % 2 ? 255 : 0;
        dst[j] = src[j] > 0 ? 0 : 255;
        test_input_block[j] = src[j] - dst[j];
       }
 
      REGISTER_STATE_CHECK(
           RunFwdTxfm(test_input_block, test_temp_block, pitch_));
      REGISTER_STATE_CHECK(
          RunInvTxfm(test_temp_block, dst, pitch_));
 
       for (int j = 0; j < 64; ++j) {
         const int diff = dst[j] - src[j];
         const int error = diff * diff;
         if (max_error < error)
           max_error = error;
         total_error += error;
       }
 
      EXPECT_GE(1, max_error)
           << ""Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has""
           << ""an individual roundtrip error > 1"";
 
      EXPECT_GE(count_test_block/5, total_error)
           << ""Error: Extremal 8x8 FDCT/IDCT or FHT/IHT has average""
           << "" roundtrip error > 1/5 per block"";
     }
   }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);
        src[j] = rnd.Rand8() % 2 ? 255 : 0;
        dst[j] = src[j] > 0 ? 0 : 255;
        test_input_block[j] = src[j] - dst[j];
      REGISTER_STATE_CHECK(
      REGISTER_STATE_CHECK(
          RunInvTxfm(test_temp_block, dst, pitch_));
      EXPECT_GE(1, max_error)
      EXPECT_GE(count_test_block/5, total_error)
"
" void RunRoundTripErrorCheck() {
 ACMRandom rnd(ACMRandom::DeterministicSeed());

     int max_error = 0;
     int total_error = 0;
     const int count_test_block = 100000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);
 
     for (int i = 0; i < count_test_block; ++i) {
       for (int j = 0; j < 64; ++j) {
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
       }
 
      REGISTER_STATE_CHECK(
           RunFwdTxfm(test_input_block, test_temp_block, pitch_));
       for (int j = 0; j < 64; ++j) {
           if (test_temp_block[j] > 0) {
            test_temp_block[j] += 2;
            test_temp_block[j] /= 4;
            test_temp_block[j] *= 4;
 } else {
            test_temp_block[j] -= 2;
            test_temp_block[j] /= 4;

             test_temp_block[j] *= 4;
           }
       }
      REGISTER_STATE_CHECK(
          RunInvTxfm(test_temp_block, dst, pitch_));
 
       for (int j = 0; j < 64; ++j) {
         const int diff = dst[j] - src[j];
         const int error = diff * diff;
         if (max_error < error)
           max_error = error;
        total_error += error;

       }
     }
 
    EXPECT_GE(1, max_error)
       << ""Error: 8x8 FDCT/IDCT or FHT/IHT has an individual""
       << "" roundtrip error > 1"";
 
    EXPECT_GE(count_test_block/5, total_error)
       << ""Error: 8x8 FDCT/IDCT or FHT/IHT has average roundtrip ""
       << ""error > 1/5 per block"";
   }
","    DECLARE_ALIGNED_ARRAY(16, int16_t, test_input_block, 64);
    DECLARE_ALIGNED_ARRAY(16, int16_t, test_temp_block, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, dst, 64);
    DECLARE_ALIGNED_ARRAY(16, uint8_t, src, 64);
        src[j] = rnd.Rand8();
        dst[j] = rnd.Rand8();
        test_input_block[j] = src[j] - dst[j];
      REGISTER_STATE_CHECK(
      REGISTER_STATE_CHECK(
          RunInvTxfm(test_temp_block, dst, pitch_));
    EXPECT_GE(1, max_error)
    EXPECT_GE(count_test_block/5, total_error)
"
"void fdct8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {
  vp9_fdct8x8_c(in, out, stride);
 }
","  vp9_fdct8x8_c(in, out, stride);
"
"   virtual void Predict(MB_PREDICTION_MODE mode) {
     mbptr_->mode_info_context->mbmi.mode = mode;
    REGISTER_STATE_CHECK(pred_fn_(mbptr_,
                                  data_ptr_[0] - kStride,
                                  data_ptr_[0] - 1, kStride,
                                  data_ptr_[0], kStride));
   }
","    REGISTER_STATE_CHECK(pred_fn_(mbptr_,
                                  data_ptr_[0] - kStride,
                                  data_ptr_[0] - 1, kStride,
                                  data_ptr_[0], kStride));
"
"   virtual void SetUp() {
    full_itxfm_ = GET_PARAM(0);
    partial_itxfm_ = GET_PARAM(1);
    tx_size_  = GET_PARAM(2);
    last_nonzero_ = GET_PARAM(3);
   }
","    full_itxfm_ = GET_PARAM(0);
    partial_itxfm_ = GET_PARAM(1);
    tx_size_  = GET_PARAM(2);
    last_nonzero_ = GET_PARAM(3);
"
"  virtual void FramePktHook(const vpx_codec_cx_pkt_t *pkt) {
 #if WRITE_COMPRESSED_STREAM
     ++out_frames_;
 
 if (pkt->data.frame.pts == 0)
      write_ivf_file_header(&cfg_, 0, outfile_);


     write_ivf_frame_header(pkt, outfile_);
     (void)fwrite(pkt->data.frame.buf, 1, pkt->data.frame.sz, outfile_);
#endif
   }
","#endif
"
"   void CheckSADs() {
     unsigned int reference_sad, exp_sad[4];
 
     SADs(exp_sad);
    for (int block = 0; block < 4; block++) {
      reference_sad = ReferenceSAD(UINT_MAX, block);
 
      EXPECT_EQ(exp_sad[block], reference_sad) << ""block "" << block;
     }
   }
","    for (int block = 0; block < 4; block++) {
      reference_sad = ReferenceSAD(UINT_MAX, block);
      EXPECT_EQ(exp_sad[block], reference_sad) << ""block "" << block;
"
"  void CheckSad(unsigned int max_sad) {
    unsigned int reference_sad, exp_sad;
    reference_sad = ReferenceSAD(max_sad);
    exp_sad = SAD(max_sad);
    if (reference_sad <= max_sad) {
      ASSERT_EQ(exp_sad, reference_sad);
    } else {
      ASSERT_GE(exp_sad, reference_sad);
    }
  }
","    unsigned int reference_sad, exp_sad;
    reference_sad = ReferenceSAD(max_sad);
    exp_sad = SAD(max_sad);
    if (reference_sad <= max_sad) {
      ASSERT_EQ(exp_sad, reference_sad);
    } else {
      ASSERT_GE(exp_sad, reference_sad);
    }
  }
"
"  void FillConstant(uint8_t *data, int stride, uint8_t fill_constant) {
     for (int h = 0; h < height_; ++h) {
       for (int w = 0; w < width_; ++w) {
        data[h * stride + w] = fill_constant;
       }
     }
   }
","        data[h * stride + w] = fill_constant;
"
"   void FillRandom(uint8_t *data, int stride) {
     for (int h = 0; h < height_; ++h) {
       for (int w = 0; w < width_; ++w) {
        data[h * stride + w] = rnd_.Rand8();
       }
     }
   }
","        data[h * stride + w] = rnd_.Rand8();
"
"  unsigned int ReferenceSAD(unsigned int max_sad, int block_idx = 0) {
     unsigned int sad = 0;
    const uint8_t* const reference = GetReference(block_idx);
     for (int h = 0; h < height_; ++h) {
       for (int w = 0; w < width_; ++w) {
        sad += abs(source_data_[h * source_stride_ + w]
               - reference[h * reference_stride_ + w]);
      }
      if (sad > max_sad) {
        break;
       }
     }
     return sad;
   }
","    const uint8_t* const reference = GetReference(block_idx);
        sad += abs(source_data_[h * source_stride_ + w]
               - reference[h * reference_stride_ + w]);
      }
      if (sad > max_sad) {
        break;
"
"  unsigned int SAD(unsigned int max_sad, int block_idx = 0) {
    unsigned int ret;
    const uint8_t* const reference = GetReference(block_idx);
    REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,
                                            reference, reference_stride_,
                                            max_sad));
    return ret;
  }
","    unsigned int ret;
    const uint8_t* const reference = GetReference(block_idx);
    REGISTER_STATE_CHECK(ret = GET_PARAM(2)(source_data_, source_stride_,
                                            reference, reference_stride_,
                                            max_sad));
    return ret;
  }
"
"   void SADs(unsigned int *results) {
    const uint8_t* refs[] = {GetReference(0), GetReference(1),
                             GetReference(2), GetReference(3)};
 
    REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,
                                      refs, reference_stride_,
                                      results));
   }
","    const uint8_t* refs[] = {GetReference(0), GetReference(1),
                             GetReference(2), GetReference(3)};
    REGISTER_STATE_CHECK(GET_PARAM(2)(source_data_, source_stride_,
                                      refs, reference_stride_,
                                      results));
"
"   static void SetUpTestCase() {
    source_data_ = reinterpret_cast<uint8_t*>(
         vpx_memalign(kDataAlignment, kDataBlockSize));
    reference_data_ = reinterpret_cast<uint8_t*>(
         vpx_memalign(kDataAlignment, kDataBufferSize));
   }
","    source_data_ = reinterpret_cast<uint8_t*>(
    reference_data_ = reinterpret_cast<uint8_t*>(
"
"   static void TearDownTestCase() {
    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
   }
","    vpx_free(source_data_);
    source_data_ = NULL;
    vpx_free(reference_data_);
    reference_data_ = NULL;
"
"   virtual void SetUp() {
    svc_.encoding_mode = INTER_LAYER_PREDICTION_IP;
     svc_.log_level = SVC_LOG_DEBUG;
     svc_.log_print = 0;
 
    codec_iface_ = vpx_codec_vp9_cx();
 const vpx_codec_err_t res =
        vpx_codec_enc_config_default(codec_iface_, &codec_enc_, 0);
    EXPECT_EQ(VPX_CODEC_OK, res);

    codec_enc_.g_w = kWidth;
    codec_enc_.g_h = kHeight;
    codec_enc_.g_timebase.num = 1;
    codec_enc_.g_timebase.den = 60;

     codec_enc_.kf_min_dist = 100;
     codec_enc_.kf_max_dist = 100;
 
    vpx_codec_dec_cfg_t dec_cfg = {0};
     VP9CodecFactory codec_factory;
     decoder_ = codec_factory.CreateDecoder(dec_cfg, 0);
   }
","    svc_.encoding_mode = INTER_LAYER_PREDICTION_IP;
    vpx_codec_dec_cfg_t dec_cfg = {0};
"
"   SvcTest()
       : codec_iface_(0),
         test_file_name_(""hantro_collage_w352h288.yuv""),
        stats_file_name_(""hantro_collage_w352h288.stat""),
         codec_initialized_(false),
         decoder_(0) {
     memset(&svc_, 0, sizeof(svc_));
    memset(&codec_, 0, sizeof(codec_));
    memset(&codec_enc_, 0, sizeof(codec_enc_));
 }
","        stats_file_name_(""hantro_collage_w352h288.stat""),
"
"   virtual void TearDown() {
    vpx_svc_release(&svc_);
     delete(decoder_);
     if (codec_initialized_) vpx_codec_destroy(&codec_);
   }
","    vpx_svc_release(&svc_);
"
"int main(int argc, char **argv) {
 ::testing::InitGoogleTest(&argc, argv);


 #if ARCH_X86 || ARCH_X86_64
   const int simd_caps = x86_simd_caps();
   if (!(simd_caps & HAS_MMX))
    append_negative_gtest_filter("":MMX/*"");
   if (!(simd_caps & HAS_SSE))
    append_negative_gtest_filter("":SSE/*"");
   if (!(simd_caps & HAS_SSE2))
    append_negative_gtest_filter("":SSE2/*"");
   if (!(simd_caps & HAS_SSE3))
    append_negative_gtest_filter("":SSE3/*"");
   if (!(simd_caps & HAS_SSSE3))
    append_negative_gtest_filter("":SSSE3/*"");
   if (!(simd_caps & HAS_SSE4_1))
    append_negative_gtest_filter("":SSE4_1/*"");
   if (!(simd_caps & HAS_AVX))
    append_negative_gtest_filter("":AVX/*"");
   if (!(simd_caps & HAS_AVX2))
    append_negative_gtest_filter("":AVX2/*"");
 #endif
 
 #if !CONFIG_SHARED

 
 #if CONFIG_VP8
   vp8_rtcd();
#endif
 #if CONFIG_VP9
   vp9_rtcd();
#endif
#endif
 
   return RUN_ALL_TESTS();
 }
","    append_negative_gtest_filter("":MMX/*"");
    append_negative_gtest_filter("":SSE/*"");
    append_negative_gtest_filter("":SSE2/*"");
    append_negative_gtest_filter("":SSE3/*"");
    append_negative_gtest_filter("":SSSE3/*"");
    append_negative_gtest_filter("":SSE4_1/*"");
    append_negative_gtest_filter("":AVX/*"");
    append_negative_gtest_filter("":AVX2/*"");
#endif
#endif
#endif
"
" TileIndependenceTest()
 : EncoderTest(GET_PARAM(0)),
        md5_fw_order_(),

         md5_inv_order_(),
         n_tiles_(GET_PARAM(1)) {
     init_flags_ = VPX_CODEC_USE_PSNR;
    vpx_codec_dec_cfg_t cfg;
     cfg.w = 704;
     cfg.h = 144;
     cfg.threads = 1;
    fw_dec_ = codec_->CreateDecoder(cfg, 0);
    inv_dec_ = codec_->CreateDecoder(cfg, 0);
    inv_dec_->Control(VP9_INVERT_TILE_DECODE_ORDER, 1);
 }
","    vpx_codec_dec_cfg_t cfg;
"
" void VarianceTest<VarianceFunctionType>::OneQuarterTest() {
  memset(src_, 255, block_size_);
   const int half = block_size_ / 2;
  memset(ref_, 255, half);
  memset(ref_ + half, 0, half);
   unsigned int sse;
   unsigned int var;
  REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
   const unsigned int expected = block_size_ * 255 * 255 / 4;
   EXPECT_EQ(expected, var);
 }
","  memset(src_, 255, block_size_);
  memset(ref_, 255, half);
  memset(ref_ + half, 0, half);
  REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
"
" void VarianceTest<VarianceFunctionType>::RefTest() {
   for (int i = 0; i < 10; ++i) {
     for (int j = 0; j < block_size_; j++) {
      src_[j] = rnd.Rand8();
      ref_[j] = rnd.Rand8();
     }
     unsigned int sse1, sse2;
     unsigned int var1;
    REGISTER_STATE_CHECK(var1 = variance_(src_, width_, ref_, width_, &sse1));
     const unsigned int var2 = variance_ref(src_, ref_, log2width_,
                                           log2height_, &sse2);
     EXPECT_EQ(sse1, sse2);
     EXPECT_EQ(var1, var2);
   }
}
","      src_[j] = rnd.Rand8();
      ref_[j] = rnd.Rand8();
    REGISTER_STATE_CHECK(var1 = variance_(src_, width_, ref_, width_, &sse1));
                                           log2height_, &sse2);
"
" void SubpelVarianceTest<SubpelVarianceFunctionType>::RefTest() {
  for (int x = 0; x < 16; ++x) {
    for (int y = 0; y < 16; ++y) {
      for (int j = 0; j < block_size_; j++) {
        src_[j] = rnd.Rand8();
      }
      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {
        ref_[j] = rnd.Rand8();
       }
       unsigned int sse1, sse2;
       unsigned int var1;
      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,
                                                   src_, width_, &sse1));
      const unsigned int var2 = subpel_variance_ref(ref_, src_, log2width_,
                                                    log2height_, x, y, &sse2);
       EXPECT_EQ(sse1, sse2) << ""at position "" << x << "", "" << y;
       EXPECT_EQ(var1, var2) << ""at position "" << x << "", "" << y;
     }
   }
 }
","  for (int x = 0; x < 16; ++x) {
    for (int y = 0; y < 16; ++y) {
      for (int j = 0; j < block_size_; j++) {
        src_[j] = rnd.Rand8();
      }
      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {
        ref_[j] = rnd.Rand8();
      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,
                                                   src_, width_, &sse1));
      const unsigned int var2 = subpel_variance_ref(ref_, src_, log2width_,
                                                    log2height_, x, y, &sse2);
"
"void SubpelVarianceTest<vp9_subp_avg_variance_fn_t>::RefTest() {
  for (int x = 0; x < 16; ++x) {
    for (int y = 0; y < 16; ++y) {
      for (int j = 0; j < block_size_; j++) {
        src_[j] = rnd.Rand8();
        sec_[j] = rnd.Rand8();
      }
      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {
        ref_[j] = rnd.Rand8();
       }
       unsigned int sse1, sse2;
       unsigned int var1;
      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,
                                                   src_, width_, &sse1, sec_));
       const unsigned int var2 = subpel_avg_variance_ref(ref_, src_, sec_,
                                                         log2width_, log2height_,
                                                        x, y, &sse2);
       EXPECT_EQ(sse1, sse2) << ""at position "" << x << "", "" << y;
       EXPECT_EQ(var1, var2) << ""at position "" << x << "", "" << y;
     }
   }
 }
","  for (int x = 0; x < 16; ++x) {
    for (int y = 0; y < 16; ++y) {
      for (int j = 0; j < block_size_; j++) {
        src_[j] = rnd.Rand8();
        sec_[j] = rnd.Rand8();
      }
      for (int j = 0; j < block_size_ + width_ + height_ + 1; j++) {
        ref_[j] = rnd.Rand8();
      REGISTER_STATE_CHECK(var1 = subpel_variance_(ref_, width_ + 1, x, y,
                                                   src_, width_, &sse1, sec_));
                                                        x, y, &sse2);
"
"   virtual void SetUp() {
    const tuple<int, int, VarianceFunctionType>& params = this->GetParam();
     log2width_  = get<0>(params);
     width_ = 1 << log2width_;
     log2height_ = get<1>(params);
     height_ = 1 << log2height_;
     variance_ = get<2>(params);
 
    rnd(ACMRandom::DeterministicSeed());
     block_size_ = width_ * height_;
    src_ = new uint8_t[block_size_];
    ref_ = new uint8_t[block_size_];
     ASSERT_TRUE(src_ != NULL);
     ASSERT_TRUE(ref_ != NULL);
   }
","    const tuple<int, int, VarianceFunctionType>& params = this->GetParam();
    rnd(ACMRandom::DeterministicSeed());
    src_ = new uint8_t[block_size_];
    ref_ = new uint8_t[block_size_];
"
"   virtual void SetUp() {
    const tuple<int, int, SubpelVarianceFunctionType>& params =
        this->GetParam();
     log2width_  = get<0>(params);
     width_ = 1 << log2width_;
     log2height_ = get<1>(params);
     height_ = 1 << log2height_;
    subpel_variance_ = get<2>(params);
 
     rnd(ACMRandom::DeterministicSeed());
     block_size_ = width_ * height_;
     src_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));
    sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));
    ref_ = new uint8_t[block_size_ + width_ + height_ + 1];
     ASSERT_TRUE(src_ != NULL);
    ASSERT_TRUE(sec_ != NULL);
     ASSERT_TRUE(ref_ != NULL);
   }
","    const tuple<int, int, SubpelVarianceFunctionType>& params =
        this->GetParam();
    subpel_variance_ = get<2>(params);
    sec_ = reinterpret_cast<uint8_t *>(vpx_memalign(16, block_size_));
    ref_ = new uint8_t[block_size_ + width_ + height_ + 1];
    ASSERT_TRUE(sec_ != NULL);
"
"   virtual void TearDown() {
    delete[] src_;
    delete[] ref_;
     libvpx_test::ClearSystemState();
   }
","    delete[] src_;
    delete[] ref_;
"
"   virtual void TearDown() {
     vpx_free(src_);
     delete[] ref_;
    vpx_free(sec_);
     libvpx_test::ClearSystemState();
   }
","    vpx_free(sec_);
"
" void VarianceTest<VarianceFunctionType>::ZeroTest() {
   for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
     for (int j = 0; j <= 255; ++j) {
      memset(ref_, j, block_size_);
       unsigned int sse;
       unsigned int var;
      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
     }
   }
 }
","    memset(src_, i, block_size_);
      memset(ref_, j, block_size_);
      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
"
"unsigned int subpel_avg_variance_ref(const uint8_t *ref,
                                     const uint8_t *src,
                                     const uint8_t *second_pred,
                                     int l2w, int l2h,
                                     int xoff, int yoff,
                                     unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
  for (int y = 0; y < h; y++) {
    for (int x = 0; x < w; x++) {
      const int a1 = ref[(w + 1) * (y + 0) + x + 0];
      const int a2 = ref[(w + 1) * (y + 0) + x + 1];
      const int b1 = ref[(w + 1) * (y + 1) + x + 0];
      const int b2 = ref[(w + 1) * (y + 1) + x + 1];
      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);
      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);
      const int r = a + (((b - a) * yoff + 8) >> 4);
      int diff = ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];
      se += diff;
      sse += diff * diff;
    }
  }
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
}
","                                     const uint8_t *src,
                                     const uint8_t *second_pred,
                                     int l2w, int l2h,
                                     int xoff, int yoff,
                                     unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
  for (int y = 0; y < h; y++) {
    for (int x = 0; x < w; x++) {
      const int a1 = ref[(w + 1) * (y + 0) + x + 0];
      const int a2 = ref[(w + 1) * (y + 0) + x + 1];
      const int b1 = ref[(w + 1) * (y + 1) + x + 0];
      const int b2 = ref[(w + 1) * (y + 1) + x + 1];
      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);
      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);
      const int r = a + (((b - a) * yoff + 8) >> 4);
      int diff = ((r + second_pred[w * y + x] + 1) >> 1) - src[w * y + x];
      se += diff;
      sse += diff * diff;
    }
  }
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
}
"
"static unsigned int subpel_variance_ref(const uint8_t *ref, const uint8_t *src,
                                        int l2w, int l2h, int xoff, int yoff,
                                        unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
   for (int y = 0; y < h; y++) {
     for (int x = 0; x < w; x++) {
      const int a1 = ref[(w + 1) * (y + 0) + x + 0];
      const int a2 = ref[(w + 1) * (y + 0) + x + 1];
      const int b1 = ref[(w + 1) * (y + 1) + x + 0];
      const int b2 = ref[(w + 1) * (y + 1) + x + 1];
      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);
      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);
      const int r = a + (((b - a) * yoff + 8) >> 4);
      int diff = r - src[w * y + x];
      se += diff;
      sse += diff * diff;
     }
   }
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
 }
","                                        int l2w, int l2h, int xoff, int yoff,
                                        unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
      const int a1 = ref[(w + 1) * (y + 0) + x + 0];
      const int a2 = ref[(w + 1) * (y + 0) + x + 1];
      const int b1 = ref[(w + 1) * (y + 1) + x + 0];
      const int b2 = ref[(w + 1) * (y + 1) + x + 1];
      const int a = a1 + (((a2 - a1) * xoff + 8) >> 4);
      const int b = b1 + (((b2 - b1) * xoff + 8) >> 4);
      const int r = a + (((b - a) * yoff + 8) >> 4);
      int diff = r - src[w * y + x];
      se += diff;
      sse += diff * diff;
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
"
"static unsigned int variance_ref(const uint8_t *ref, const uint8_t *src,
                                 int l2w, int l2h, unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
  for (int y = 0; y < h; y++) {
    for (int x = 0; x < w; x++) {
      int diff = ref[w * y + x] - src[w * y + x];
      se += diff;
      sse += diff * diff;
    }
//// Truncate high bit depth results by downshifting (with rounding) by:
//// 2 * (bit_depth - 8) for sse
//// (bit_depth - 8) for se
   }
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
 }
","                                 int l2w, int l2h, unsigned int *sse_ptr) {
  int se = 0;
  unsigned int sse = 0;
  const int w = 1 << l2w, h = 1 << l2h;
  for (int y = 0; y < h; y++) {
    for (int x = 0; x < w; x++) {
      int diff = ref[w * y + x] - src[w * y + x];
      se += diff;
      sse += diff * diff;
    }
  *sse_ptr = sse;
  return sse - (((int64_t) se * se) >> (l2w + l2h));
"
" string DecodeFile(const string& filename, int num_threads) {
   libvpx_test::WebMVideoSource video(filename);
   video.Init();
 
  vpx_codec_dec_cfg_t cfg = {0};
   cfg.threads = num_threads;
   libvpx_test::VP9Decoder decoder(cfg, 0);
 
  libvpx_test::MD5 md5;
 for (video.Begin(); video.cxdata(); video.Next()) {
 const vpx_codec_err_t res =
        decoder.DecodeFrame(video.cxdata(), video.frame_size());
 if (res != VPX_CODEC_OK) {
      EXPECT_EQ(VPX_CODEC_OK, res) << decoder.DecodeError();
 break;
 }

    libvpx_test::DxDataIterator dec_iter = decoder.GetDxData();
 const vpx_image_t *img = NULL;

 while ((img = dec_iter.Next())) {
      md5.Add(img);
 }
 }

   return string(md5.Get());
 }
","  vpx_codec_dec_cfg_t cfg = {0};
"
"   virtual void SetUp() {
    vp9_worker_init(&worker_);
   }
","    vp9_worker_init(&worker_);
"
"   virtual void TearDown() {
    vp9_worker_end(&worker_);
   }
","    vp9_worker_end(&worker_);
"
