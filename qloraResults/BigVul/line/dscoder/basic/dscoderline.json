[
  {
    "code": "    DidFinishNavigation(NavigationHandle* handle) {\n  if (handle->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  if (!handle->HasCommitted())\n    return;\n  if (handle->GetRenderFrameHost()->GetSiteInstance() != parent_site_instance_)\n    return;\n  if (!handle->GetURL().IsAboutBlank())\n    return;\n  if (!handle->GetRenderFrameHost()->PrepareForInnerWebContentsAttach()) {\n    filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                   MSG_ROUTING_NONE /* no plugin frame */);\n  }\n  base::PostTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy,\n                     filter_, element_instance_id_,\n                     handle->GetRenderFrameHost()->GetRoutingID()));\n}\n",
    "response": "\n{\n  \"LINE1\": \"                                   MSG_ROUTING_NONE /* no plugin frame */);\",\n  \"LINE2\": \"base::PostTaskWithTraits(\",\n  \"LINE3\": \"FROM_HERE, {BrowserThread::UI},\",\n  \"LINE4\": \"base::BindOnce(&ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy,\",\n  \"LINE5\": \"filter_, element_instance_id_, handle->GetRenderFrameHost()->GetRoutingID()));\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (handle->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  if (!handle->HasCommitted())\n    return;\n  if (handle->GetRenderFrameHost()->GetSiteInstance() != parent_site_instance_)\n    return;\n  if (!handle->GetURL().IsAboutBlank())\n    return;\n  if (!handle->GetRenderFrameHost()->PrepareForInnerWebContentsAttach()) {\n    filter_->Res",
    "truly_vulnerable_lines": "  if (handle->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  if (!handle->HasCommitted())\n    return;\n  if (handle->GetRenderFrameHost()->GetSiteInstance() != parent_site_instance_)\n    return;\n  if (!handle->GetURL().IsAboutBlank())\n    return;\n  if (!handle->GetRenderFrameHost()->PrepareForInnerWebContentsAttach()) {\n    filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                   MSG_ROUTING_NONE /* no plugin frame */);\n  }\n  base::PostTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy,\n                     filter_, element_instance_id_,\n                     handle->GetRenderFrameHost()->GetRoutingID()));\n}\n"
  },
  {
    "code": " ExtensionsGuestViewMessageFilter::ExtensionsGuestViewMessageFilter(\n     int render_process_id,\n    BrowserContext* context)\n    : GuestViewMessageFilter(kFilteredMessageClasses,\n                             base::size(kFilteredMessageClasses),\n                              render_process_id,\n                              context),\n       content::BrowserAssociatedInterface<mojom::GuestView>(this, this) {\n  GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);\n }\n",
    "response": "\n{\n  \"LINE1\": \"    BrowserContext* context)\",\n  \"LINE2\": \"    : GuestViewMessageFilter(kFilteredMessageClasses,\",\n  \"LINE3\": \"                             base::size(kFilteredMessageClasses),\",\n  \"LINE4\": \"                              render_process_id,\",\n  \"LINE5\": \"                              context),\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    BrowserContext* context)\",\n  \"vulnerability2\": \"       content::BrowserAssociatedInterface<mojom::GuestView>(this, this)\",\n  \"vulnerability3\": \"GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    BrowserContext* context)\",\n  \"vulnerability2\": \"    : GuestViewMessageFilter(kFilteredMessageClasses,\",\n  \"vulnerability3\": \"                             base::size(kFilteredMessageClasses),\",\n  \"vulnerability4\": \"                              render",
    "truly_vulnerable_lines": "  GetProcessIdToFilterMap()->insert_or_assign(render_process_id_, this);\n"
  },
  {
    "code": "void ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameDeleted(\n    RenderFrameHost* render_frame_host) {\n  if (render_frame_host->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                 MSG_ROUTING_NONE /* no plugin frame */);\n}\n",
    "response": "\n{\n  \"LINE1\": \"code line 1\",\n  \"LINE2\": \"code line 2\",\n  \"LINE3\": \"code line 3\",\n  \"LINE4\": \"code line 4\",\n  \"LINE5\": \"code line 5\"\n}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\"]}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\", \"vulnerability 6\", \"vulnerability 7\", \"vulnerability 8\", \"vulnerability 9\", \"vulnerability 10\"]}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\", \"vulnerability",
    "truly_vulnerable_lines": "    RenderFrameHost* render_frame_host) {\n  if (render_frame_host->GetFrameTreeNodeId() != frame_tree_node_id_)\n    return;\n  filter_->ResumeAttachOrDestroy(element_instance_id_,\n                                 MSG_ROUTING_NONE /* no plugin frame */);\n}\n"
  },
  {
    "code": "ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(\n    RenderFrameHost* plugin_rfh,\n    int32_t guest_instance_id,\n    int32_t element_instance_id,\n    bool is_full_page_plugin,\n    ExtensionsGuestViewMessageFilter* filter)\n    : content::WebContentsObserver(\n          content::WebContents::FromRenderFrameHost(plugin_rfh)),\n      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),\n      guest_instance_id_(guest_instance_id),\n      element_instance_id_(element_instance_id),\n      is_full_page_plugin_(is_full_page_plugin),\n      filter_(filter),\n      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),\n      weak_factory_(this) {\n  DCHECK(GetGuestView());\n  NavigateToAboutBlank();\n  base::PostDelayedTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::\n                         CancelPendingTask,\n                     weak_factory_.GetWeakPtr()),\n      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));\n}\n",
    "response": "\n{\"LINE1\": \"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(\",\n  \"LINE2\": \"    RenderFrameHost* plugin_rfh,\",\n  \"LINE3\": \"    int32_t guest_instance_id,\",\n  \"LINE4\": \"    int32_t element_instance_id,\",\n  \"LINE5\": \"    bool is_full_page_plugin,\"\n}{\"LINE1\": \"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(\",\n  \"LINE2\": \"    RenderFrameHost* plugin_rfh,\",\n  \"LINE3\": \"    int32_t guest_instance_id,\",\n  \"LINE4\": \"    int32_t element_instance_id,\",\n  \"LINE5\": \"    bool is_full_page_plugin,\"\n}{\"LINE1\": \"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::FrameNavigationHelper(\",\n  \"LINE2\": \"    RenderFrameHost* plugin_rfh,\",\n  \"LINE3\": \"    int3",
    "truly_vulnerable_lines": "    RenderFrameHost* plugin_rfh,\n    int32_t guest_instance_id,\n    int32_t element_instance_id,\n    bool is_full_page_plugin,\n    ExtensionsGuestViewMessageFilter* filter)\n    : content::WebContentsObserver(\n          content::WebContents::FromRenderFrameHost(plugin_rfh)),\n      frame_tree_node_id_(plugin_rfh->GetFrameTreeNodeId()),\n      guest_instance_id_(guest_instance_id),\n      element_instance_id_(element_instance_id),\n      is_full_page_plugin_(is_full_page_plugin),\n      filter_(filter),\n      parent_site_instance_(plugin_rfh->GetParent()->GetSiteInstance()),\n      weak_factory_(this) {\n  DCHECK(GetGuestView());\n  NavigateToAboutBlank();\n  base::PostDelayedTaskWithTraits(\n      FROM_HERE, {BrowserThread::UI},\n      base::BindOnce(&ExtensionsGuestViewMessageFilter::FrameNavigationHelper::\n                         CancelPendingTask,\n                     weak_factory_.GetWeakPtr()),\n      base::TimeDelta::FromMilliseconds(kAttachFailureDelayMS));\n}\n"
  },
  {
    "code": "ExtensionsGuestViewMessageFilter::FrameNavigationHelper::GetGuestView() const {\n  return MimeHandlerViewGuest::From(\n             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)\n      ->As<MimeHandlerViewGuest>();\n}\n",
    "response": "\n{\n  \"LINE1\": \"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::GetGuestView() const {\",\n  \"LINE2\": \"             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)\n      ->As<MimeHandlerViewGuest>();\n}\n}<div class=\"header\">\n\n</div>\n{\"data\": {\"LINE1\": \"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::GetGuestView() const {\",\n  \"LINE2\": \"             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)\n      ->As<MimeHandlerViewGuest>();\n}\n}{\"data\": {\n  \"LINE1\": \"ExtensionsGuestViewMessageFilter::FrameNavigationHelper::GetGuestView() const {\",\n  \"LINE2\": \"             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)\n      ->As<MimeHandlerViewGuest>();\n}\n}{\"data\": {\n  \"LINE1",
    "truly_vulnerable_lines": "  return MimeHandlerViewGuest::From(\n             parent_site_instance_->GetProcess()->GetID(), guest_instance_id_)\n      ->As<MimeHandlerViewGuest>();\n}\n"
  },
  {
    "code": "ProcessIdToFilterMap* GetProcessIdToFilterMap() {\n  static base::NoDestructor<ProcessIdToFilterMap> instance;\n  return instance.get();\n}\n",
    "response": "\n{\n  \"LINE1\": \"ProcessIdToFilterMap* GetProcessIdToFilterMap() {\",\n  \"LINE2\": \"  static base::NoDestructor<ProcessIdToFilterMap> instance;\",\n  \"LINE3\": \"  return instance.get();\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"ProcessIdToFilterMap* GetProcessIdToFilterMap() {\"\n}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8\", \"vulnerability9\", \"vulnerability10\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"",
    "truly_vulnerable_lines": "  static base::NoDestructor<ProcessIdToFilterMap> instance;\n  return instance.get();\n}\n"
  },
  {
    "code": "ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\n    NavigationHandle* handle) {\n  DCHECK(content::MimeHandlerViewMode::UsesCrossProcessFrame());\n  if (!handle->GetParentFrame()) {\n    return nullptr;\n  }\n  int32_t parent_process_id = handle->GetParentFrame()->GetProcess()->GetID();\n  auto& map = *GetProcessIdToFilterMap();\n  if (!base::ContainsKey(map, parent_process_id) || !map[parent_process_id]) {\n    return nullptr;\n  }\n  for (auto& pair : map[parent_process_id]->frame_navigation_helpers_) {\n    if (!pair.second->ShouldCancelAndIgnore(handle))\n      continue;\n    return std::make_unique<CancelAndIgnoreNavigationForPluginFrameThrottle>(\n        handle);\n  }\n  return nullptr;\n}\n",
    "response": "\n{\n  \"LINE1\": \"ExtensionsGuestViewMessageFilter::MaybeCreateThrottle(\",\n  \"LINE2\": \"    NavigationHandle* handle) {\",\n  \"LINE3\": \"  DCHECK(content::MimeHandlerViewMode::UsesCrossProcessFrame());\",\n  \"LINE4\": \"  if (!handle->GetParentFrame()) {\",\n  \"LINE5\": \"    return nullptr;\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    DCHECK(content::MimeHandlerViewMode::UsesCrossProcessFrame());\",\n  \"vulnerability2\": \"  if (!handle->GetParentFrame()) {\",\n  \"vulnerability3\": \"    return nullptr;\",\n  \"vulnerability4\": \"  int32_t parent_process_id = handle->GetParentFrame()->GetProcess()->GetID();\",\n  \"vulnerability5\": \"  auto& map = *GetProcessIdToFilterMap();\"{\"vulnerabilities\": [\"vulnerability1\": \"  DCHECK(content::M",
    "truly_vulnerable_lines": "    NavigationHandle* handle) {\n  DCHECK(content::MimeHandlerViewMode::UsesCrossProcessFrame());\n  if (!handle->GetParentFrame()) {\n    return nullptr;\n  }\n  int32_t parent_process_id = handle->GetParentFrame()->GetProcess()->GetID();\n  auto& map = *GetProcessIdToFilterMap();\n  if (!base::ContainsKey(map, parent_process_id) || !map[parent_process_id]) {\n    return nullptr;\n  }\n  for (auto& pair : map[parent_process_id]->frame_navigation_helpers_) {\n    if (!pair.second->ShouldCancelAndIgnore(handle))\n      continue;\n    return std::make_unique<CancelAndIgnoreNavigationForPluginFrameThrottle>(\n        handle);\n  }\n  return nullptr;\n}\n"
  },
  {
    "code": "    NavigateToAboutBlank() {\n  GURL about_blank(url::kAboutBlankURL);\n  content::NavigationController::LoadURLParams params(about_blank);\n  params.frame_tree_node_id = frame_tree_node_id_;\n  params.source_site_instance = parent_site_instance_;\n  params.is_renderer_initiated = true;\n  web_contents()->GetController().LoadURLWithParams(params);\n}\n",
    "response": "\n{\n  \"LINE1\": \"  GURL about_blank(url::kAboutBlankURL);\",\n  \"LINE2\": \"  content::NavigationController::LoadURLParams params(about_blank);\",\n  \"LINE3\": \"  params.frame_tree_node_id = frame_tree_node_id_;\",\n  \"LINE4\": \"  params.source_site_instance = parent_site_instance_;\",\n  \"LINE5\": \"  params.is_renderer_initiated = true;\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  GURL about_blank(url::kAboutBlankURL);\",\n  \"vulnerability2\": \"  content::NavigationController::LoadURLParams params(about_blank);\",\n  \"vulnerability3\": \"  params.frame_tree_node_id = frame_tree_node_id_;\",\n  \"vulnerability4\": \"  params.source_site_instance = parent_site_instance_;\",\n  \"vulnerability5\": \"  params.is_renderer_initiated = true",
    "truly_vulnerable_lines": "  GURL about_blank(url::kAboutBlankURL);\n  content::NavigationController::LoadURLParams params(about_blank);\n  params.frame_tree_node_id = frame_tree_node_id_;\n  params.source_site_instance = parent_site_instance_;\n  params.is_renderer_initiated = true;\n  web_contents()->GetController().LoadURLWithParams(params);\n}\n"
  },
  {
    "code": "void RemoveProcessIdFromGlobalMap(int32_t process_id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  GetProcessIdToFilterMap()->erase(process_id);\n}\n",
    "response": "\n{\n  \"LINE1\": \"void RemoveProcessIdFromGlobalMap(int32_t process_id) {\",\n  \"LINE2\": \"  DCHECK_CURRENTLY_ON(BrowserThread::UI);\",\n  \"LINE3\": \"  GetProcessIdToFilterMap()->erase(process_id);\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"  DCHECK_CURRENTLY_ON(BrowserThread::UI);\"\n}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8\", \"vulnerability9\", \"vulnerability10\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"",
    "truly_vulnerable_lines": "  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  GetProcessIdToFilterMap()->erase(process_id);\n}\n"
  },
  {
    "code": "void ExtensionsGuestViewMessageFilter::ResumeAttachOrDestroy(\n    int32_t element_instance_id,\n    int32_t plugin_frame_routing_id) {\n  auto it = frame_navigation_helpers_.find(element_instance_id);\n  if (it == frame_navigation_helpers_.end()) {\n    return;\n  }\n  auto* plugin_rfh = content::RenderFrameHost::FromID(render_process_id_,\n                                                      plugin_frame_routing_id);\n  auto* helper = it->second.get();\n  auto* guest_view = helper->GetGuestView();\n  if (!guest_view)\n    return;\n \n  if (plugin_rfh) {\n    DCHECK(\n        guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh));\n    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,\n                                              helper->is_full_page_plugin());\n  } else {\n    guest_view->GetEmbedderFrame()->Send(\n        new ExtensionsGuestViewMsg_DestroyFrameContainer(element_instance_id));\n    guest_view->Destroy(true);\n  }\n  frame_navigation_helpers_.erase(element_instance_id);\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (plugin_rfh) {\",\n  \"LINE2\": \"    DCHECK(guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh));\",\n  \"LINE3\": \"    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,\",\n  \"LINE4\": \"                                              helper->is_full_page_plugin());\",\n  \"LINE5\": \"  } else {\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line ",
    "truly_vulnerable_lines": "    int32_t element_instance_id,\n    int32_t plugin_frame_routing_id) {\n  auto it = frame_navigation_helpers_.find(element_instance_id);\n  if (it == frame_navigation_helpers_.end()) {\n    return;\n  }\n  auto* plugin_rfh = content::RenderFrameHost::FromID(render_process_id_,\n                                                      plugin_frame_routing_id);\n  auto* helper = it->second.get();\n  auto* guest_view = helper->GetGuestView();\n  if (!guest_view)\n    return;\n  if (plugin_rfh) {\n    DCHECK(\n        guest_view->web_contents()->CanAttachToOuterContentsFrame(plugin_rfh));\n    guest_view->AttachToOuterWebContentsFrame(plugin_rfh, element_instance_id,\n                                              helper->is_full_page_plugin());\n  } else {\n    guest_view->GetEmbedderFrame()->Send(\n        new ExtensionsGuestViewMsg_DestroyFrameContainer(element_instance_id));\n    guest_view->Destroy(true);\n  }\n  frame_navigation_helpers_.erase(element_instance_id);\n"
  },
  {
    "code": "    ShouldCancelAndIgnore(NavigationHandle* handle) {\n  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\n}\n",
    "response": "\n{\n  \"LINE1\": \"  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\",\n  \"LINE2\": \"}\",\n  \"LINE3\": \"ShouldCancelAndIgnore(NavigationHandle* handle) {\",\n  \"LINE4\": \"  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\",\n  \"vulnerability2\": \"}\",\n  \"vulnerability3\": \"ShouldCancelAndIgnore(NavigationHandle* handle) {\",\n  \"vulnerability4\": \"  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\",\n  \"vulnerability5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\",\n  \"vulnerability2",
    "truly_vulnerable_lines": "  return handle->GetFrameTreeNodeId() == frame_tree_node_id_;\n}\n"
  },
  {
    "code": "  SiteInstance* parent_site_instance() const {\n    return parent_site_instance_.get();\n  }\n",
    "response": "\n{\n  \"LINE1\": \"    return parent_site_instance_.get();\",\n  \"LINE2\": \"  }\",\n  \"LINE3\": \"  SiteInstance* parent_site_instance() const {\",\n  \"LINE4\": \"    return parent_site_instance_.get();\",\n  \"LINE5\": \"  }\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    return parent_site_instance_.get();\",\n  \"vulnerability2\": \"  }\",\n  \"vulnerability3\": \"  SiteInstance* parent_site_instance() const {\",\n  \"vulnerability4\": \"    return parent_site_instance_.get();\",\n  \"vulnerability5\": \"  }\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  }\",\n  \"vulnerability2\": \"  SiteInstance* parent_site_instance() const {\",\n  \"vulnerability3\": \"    return parent_site_instance_.get();\",\n  \"vulnerability4\": \"  }\"\n",
    "truly_vulnerable_lines": "    return parent_site_instance_.get();\n  }\n"
  },
  {
    "code": " ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\n  base::PostTaskWithTraits(\n      FROM_HERE, BrowserThread::UI,\n      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\n }\n",
    "response": "\n{\n  \"LINE1\": \"  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\",\n  \"LINE2\": \"  base::PostTaskWithTraits(\",\n  \"LINE3\": \"      FROM_HERE, BrowserThread::UI,\",\n  \"LINE4\": \"      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\",\n  \"vulnerability2\": \"  base::PostTaskWithTraits(\",\n  \"vulnerability3\": \"      FROM_HERE, BrowserThread::UI,\",\n  \"vulnerability4\": \"      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\",\n  \"vulnerability5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  (*GetProcessIdToFilterMap())[render_process",
    "truly_vulnerable_lines": "  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\n  base::PostTaskWithTraits(\n      FROM_HERE, BrowserThread::UI,\n      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\n"
  },
  {
    "code": "void DOMStorageContextWrapper::OpenSessionStorage(\n    int process_id,\n    const std::string& namespace_id,\n    mojo::ReportBadMessageCallback bad_message_callback,\n     blink::mojom::SessionStorageNamespaceRequest request) {\n   if (!mojo_session_state_)\n     return;\n  mojo_task_runner_->PostTask(\n       FROM_HERE,\n       base::BindOnce(&SessionStorageContextMojo::OpenSessionStorage,\n                      base::Unretained(mojo_session_state_), process_id,\n                     namespace_id, std::move(bad_message_callback),\n                      std::move(request)));\n }\n",
    "response": "\n{\n  \"LINE1\": \"                      base::Unretained(mojo_session_state_), process_id,\",\n  \"LINE2\": \"                     namespace_id, std::move(bad_message_callback),\",\n  \"LINE3\": \"                      std::move(request)));\",\n  \"LINE4\": \"  mojo_task_runner_->PostTask(\",\n  \"LINE5\": \"                     base::BindOnce(&SessionStorageContextMojo::OpenSessionStorage,\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  if (is_incognito)\n    return;\n  mojo_task_runner_->PostTask(\n    mojo_task_runner_->PostTask(\n    mojo_task_runner_->PostTask(\n    mojo_task_runner_->PostTask(\n    mojo_task_runner_->PostTask(\n    mojo_task_runner_->PostTask(\n    mojo_task_runner_->PostTask(\n    mojo_task_runner_->PostTask(\n    mojo_task_runner_-",
    "truly_vulnerable_lines": "                     namespace_id, std::move(bad_message_callback),\n"
  },
  {
    "code": " void DOMStorageContextWrapper::Shutdown() {\n  DCHECK(context_.get());\n  mojo_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,\n                                base::Unretained(mojo_state_)));\n  mojo_state_ = nullptr;\n   if (mojo_session_state_) {\n     mojo_task_runner_->PostTask(\n         FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,\n                                   base::Unretained(mojo_session_state_)));\n     mojo_session_state_ = nullptr;\n   }\n   memory_pressure_listener_.reset();\n  context_->task_runner()->PostShutdownBlockingTask(\n      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,\n      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));\n }\n",
    "response": "\n{\n  \"LINE1\": \"  context_->task_runner()->PostShutdownBlockingTask(\",\n  \"LINE2\": \"      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,\",\n  \"LINE3\": \"      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));\",\n  \"LINE4\": \"  DCHECK(context_.get());\",\n  \"LINE5\": \"  mojo_task_runner_->PostTask(\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\",\n  \"vulnerability line 6\",\n  \"vulnerability line ",
    "truly_vulnerable_lines": "  DCHECK(context_.get());\n  mojo_task_runner_->PostTask(\n      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,\n                                base::Unretained(mojo_state_)));\n  mojo_state_ = nullptr;\n  context_->task_runner()->PostShutdownBlockingTask(\n      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,\n      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));\n"
  },
  {
    "code": "void Document::InitContentSecurityPolicy(\n    ContentSecurityPolicy* csp,\n    const ContentSecurityPolicy* policy_to_inherit,\n    const ContentSecurityPolicy* previous_document_csp) {\n   SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\n \n   GetContentSecurityPolicy()->BindToExecutionContext(this);\n \n  if (policy_to_inherit) {\n     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  } else {\n    if (frame_) {\n       Frame* inherit_from = frame_->Tree().Parent()\n                                 ? frame_->Tree().Parent()\n                                 : frame_->Client()->Opener();\n       if (inherit_from && frame_ != inherit_from) {\n         DCHECK(inherit_from->GetSecurityContext() &&\n                inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n        policy_to_inherit =\n            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n       }\n     }\n    if (!policy_to_inherit)\n      policy_to_inherit = previous_document_csp;\n    if (policy_to_inherit &&\n        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n         url_.ProtocolIs(\"blob\") || url_.ProtocolIs(\"filesystem\")))\n      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  }\n  if (policy_to_inherit && IsPluginDocument())\n    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n }\n",
    "response": "\n{\n  \"LINE1\": \"  SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());\",\n  \"LINE2\": \"  GetContentSecurityPolicy()->BindToExecutionContext(this);\",\n  \"LINE3\": \"  if (policy_to_inherit) {\",\n  \"LINE4\": \"     GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\",\n  \"LINE5\": \"  } else {\"\n}{\"vulnerabilities\": [\"code line 1\",\n    if (policy_to_inherit) {\n        GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n    } else {\n        if (frame_) {\n            Frame* inherit_from = frame_->Tree().Parent()\n                                 ? frame_->Tree().Parent()\n                                 : frame_->Client()->Opener();\n            if (inherit_from && frame_ != inherit_from) {\n                DCHECK(inherit_from->GetSecurityContext() &&\n                       inherit_from->GetSecurityContext()->GetContentSecurityPolicy());\n            policy_to_inherit =\n",
    "truly_vulnerable_lines": "    ContentSecurityPolicy* csp,\n    const ContentSecurityPolicy* policy_to_inherit,\n    const ContentSecurityPolicy* previous_document_csp) {\n  if (policy_to_inherit) {\n  } else {\n    if (frame_) {\n        policy_to_inherit =\n            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();\n    if (!policy_to_inherit)\n      policy_to_inherit = previous_document_csp;\n    if (policy_to_inherit &&\n        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||\n         url_.ProtocolIs(\"blob\") || url_.ProtocolIs(\"filesystem\")))\n      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);\n  }\n  if (policy_to_inherit && IsPluginDocument())\n    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);\n"
  },
  {
    "code": "DocumentInit& DocumentInit::WithPreviousDocumentCSP(\n    const ContentSecurityPolicy* previous_csp) {\n  DCHECK(!previous_csp_);\n  previous_csp_ = previous_csp;\n  return *this;\n}\n",
    "response": "\n{\n  \"LINE1\": \"DocumentInit& DocumentInit::WithPreviousDocumentCSP(\",\n  \"LINE2\": \"    const ContentSecurityPolicy* previous_csp)\",\n  \"LINE3\": \"  DCHECK(!previous_csp_);\",\n  \"LINE4\": \"  previous_csp_ = previous_csp;\",\n  \"LINE5\": \"  return *this;\"\n}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8\", \"vulnerability9\", \"vulnerability10\", \"vulnerability11\", \"vulnerability12\", \"vulnerability13\", \"vulnerability14\", \"vulnerability15\", \"v",
    "truly_vulnerable_lines": "    const ContentSecurityPolicy* previous_csp) {\n  DCHECK(!previous_csp_);\n  previous_csp_ = previous_csp;\n  return *this;\n}\n"
  },
  {
    "code": "bool ContentSecurityPolicy::AllowPluginTypeForDocument(\n    const Document& document,\n    const String& type,\n    const String& type_attribute,\n    const KURL& url,\n    SecurityViolationReportingPolicy reporting_policy) const {\n  if (document.GetContentSecurityPolicy() &&\n      !document.GetContentSecurityPolicy()->AllowPluginType(\n           type, type_attribute, url, reporting_policy))\n     return false;\n \n  LocalFrame* frame = document.GetFrame();\n  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {\n    ContentSecurityPolicy* parent_csp = frame->Tree()\n                                            .Parent()\n                                            ->GetSecurityContext()\n                                            ->GetContentSecurityPolicy();\n    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,\n                                                   reporting_policy))\n      return false;\n  }\n   return true;\n }\n",
    "response": "\n{\n  \"LINE1\": \"     return false;\",\n  \"LINE2\": \"  LocalFrame* frame = document.GetFrame();\",\n  \"LINE3\": \"  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {\",\n  \"LINE4\": \"    ContentSecurityPolicy* parent_csp = frame->Tree()\",\n  \"LINE5\": \"                                            .Parent()\",\n  \"LINE6\": \"                                            ->GetSecurityContext()\",\n  \"LINE7\": \"                                            ->GetContentSecurityPolicy();\",\n  \"LINE8\": \"    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,\",\n  \"LINE9\": \"                                                   reporting_policy))\",\n  \"LINE10\": \"      return false;\"\n}{\"vulnerabilities\": [\"code line 1\",\n  \"code line 2\",\n  \"code line 3\",\n  \"code line 4\",\n  \"code line 5\"]}{\"vulnerabilities\": [\"code line 1\",\n  \"code line",
    "truly_vulnerable_lines": "  LocalFrame* frame = document.GetFrame();\n  if (frame && frame->Tree().Parent() && document.IsPluginDocument()) {\n    ContentSecurityPolicy* parent_csp = frame->Tree()\n                                            .Parent()\n                                            ->GetSecurityContext()\n                                            ->GetContentSecurityPolicy();\n    if (parent_csp && !parent_csp->AllowPluginType(type, type_attribute, url,\n                                                   reporting_policy))\n      return false;\n  }\n"
  },
  {
    "code": "void DocumentLoader::DidInstallNewDocument(\n    Document* document,\n    const ContentSecurityPolicy* previous_csp) {\n   document->SetReadyState(Document::kLoading);\n   if (content_security_policy_) {\n    document->InitContentSecurityPolicy(content_security_policy_.Release(),\n                                        nullptr, previous_csp);\n   }\n \n   if (history_item_ && IsBackForwardLoadType(load_type_))\n    document->SetStateForNewFormElements(history_item_->GetDocumentState());\n\n  DCHECK(document->GetFrame());\n  document->GetFrame()->GetClientHintsPreferences().UpdateFrom(\n      client_hints_preferences_);\n\n  Settings* settings = document->GetSettings();\n  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());\n  fetcher_->SetAutoLoadImages(settings->GetLoadsImagesAutomatically());\n\n  const AtomicString& dns_prefetch_control =\n      response_.HttpHeaderField(http_names::kXDNSPrefetchControl);\n  if (!dns_prefetch_control.IsEmpty())\n    document->ParseDNSPrefetchControlHeader(dns_prefetch_control);\n\n  String header_content_language =\n      response_.HttpHeaderField(http_names::kContentLanguage);\n  if (!header_content_language.IsEmpty()) {\n    wtf_size_t comma_index = header_content_language.find(',');\n    header_content_language.Truncate(comma_index);\n    header_content_language =\n        header_content_language.StripWhiteSpace(IsHTMLSpace<UChar>);\n    if (!header_content_language.IsEmpty())\n      document->SetContentLanguage(AtomicString(header_content_language));\n  }\n\n  String referrer_policy_header =\n      response_.HttpHeaderField(http_names::kReferrerPolicy);\n  if (!referrer_policy_header.IsNull()) {\n    UseCounter::Count(*document, WebFeature::kReferrerPolicyHeader);\n    document->ParseAndSetReferrerPolicy(referrer_policy_header);\n  }\n\n  if (response_.IsSignedExchangeInnerResponse())\n    UseCounter::Count(*document, WebFeature::kSignedExchangeInnerResponse);\n\n  GetLocalFrameClient().DidCreateNewDocument();\n}\n",
    "response": "\n{\n  \"LINE1\": \"    document->InitContentSecurityPolicy(content_security_policy_.Release(),\",\n  \"LINE2\": \"                                        nullptr, previous_csp);\",\n  \"LINE3\": \"   }\",\n  \"LINE4\": \"    document->SetStateForNewFormElements(history_item_->GetDocumentState());\",\n  \"LINE5\": \"  DCHECK(document->GetFrame());\"\n}{\"vulnerabilities\": [\"document->SetReadyState(Document::kLoading);\",\n    document->InitContentSecurityPolicy(content_security_policy_.Release(),\n                                        nullptr, previous_csp);\n    document->SetStateForNewFormElements(history_item_->GetDocumentState());\n  DCHECK(document->GetFrame());\n  document->GetFrame()->GetClientHintsPreferences().UpdateFrom(\n      client_hints_preferences_);\n\n  Settings* settings = document->GetSettings();\n  fetcher_->SetImagesEnabled(settings->GetImagesEnabled());\n  fetcher_->SetAutoLoadImages(settings-",
    "truly_vulnerable_lines": "    Document* document,\n    const ContentSecurityPolicy* previous_csp) {\n    document->InitContentSecurityPolicy(content_security_policy_.Release(),\n                                        nullptr, previous_csp);\n"
  },
  {
    "code": " std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\n                                            const std::wstring& switch_name) {\n   assert(!command_line.empty());\n   assert(!switch_name.empty());\n \n   std::vector<std::wstring> as_array = TokenizeCommandLineToArray(command_line);\n   std::wstring switch_with_equal = L\"--\" + switch_name + L\"=\";\n  for (size_t i = 1; i < as_array.size(); ++i) {\n    const std::wstring& arg = as_array[i];\n     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\n       return arg.substr(switch_with_equal.size());\n   }\n\n  return std::wstring();\n}\n",
    "response": "\n{\n  \"LINE1\": \"  for (size_t i = 1; i < as_array.size(); ++i) {\",\n  \"LINE2\": \"    const std::wstring& arg = as_array[i];\",\n  \"LINE3\": \"     if (arg.compare(0, switch_with_equal.size(), switch_with_equal) == 0)\",\n  \"LINE4\": \"       return arg.substr(switch_with_equal.size());\",\n  \"LINE5\": \"  return std::wstring();\"\n}{\"vulnerabilities\": [\"std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\",\n                                            const std::wstring& switch_name) {\n  for (size_t i = 1; i < as_array.size(); ++i) {\n    const std::wstring& arg = as_array[i];\n  return std::wstring();\n}{\"vulnerabilities\": [\"std::wstring GetSwitchValueFromCommandLine(const std::wstring& command_line,\",\n                                            const std",
    "truly_vulnerable_lines": "  for (size_t i = 1; i < as_array.size(); ++i) {\n    const std::wstring& arg = as_array[i];\n"
  },
  {
    "code": "DOMArrayBuffer* FileReaderLoader::ArrayBufferResult() {\n  DCHECK_EQ(read_type_, kReadAsArrayBuffer);\n  if (array_buffer_result_)\n    return array_buffer_result_;\n\n   if (!raw_data_ || error_code_ != FileErrorCode::kOK)\n     return nullptr;\n \n  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  if (finished_loading_) {\n    array_buffer_result_ = result;\n    AdjustReportedMemoryUsageToV8(\n        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n    raw_data_.reset();\n   }\n  return result;\n }\n",
    "response": "\n{\n  \"LINE1\": \"  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\",\n  \"LINE2\": \"  if (finished_loading_) {\",\n  \"LINE3\": \"    array_buffer_result_ = result;\",\n  \"LINE4\": \"    AdjustReportedMemoryUsageToV8(\",\n  \"LINE5\": \"        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!raw_data_ || error_code_ != FileErrorCode::kOK)\",\n  \"vulnerability2\": \"  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\",\n  \"vulnerability3\": \"  if (finished_loading_) {\",\n  \"vulnerability4\": \"    array_buffer_result_ = result;\",\n  \"vulnerability5\": \"    AdjustReportedMemoryUsageToV8(\"\n]}{\"vul",
    "truly_vulnerable_lines": "  DOMArrayBuffer* result = DOMArrayBuffer::Create(raw_data_->ToArrayBuffer());\n  if (finished_loading_) {\n    array_buffer_result_ = result;\n    AdjustReportedMemoryUsageToV8(\n        -1 * static_cast<int64_t>(raw_data_->ByteLength()));\n    raw_data_.reset();\n  return result;\n"
  },
  {
    "code": " bool SVGElement::HasSVGParent() const {\n  return ParentOrShadowHostElement() &&\n         ParentOrShadowHostElement()->IsSVGElement();\n }\n",
    "response": "\n{\n  \"LINE1\": \"  return ParentOrShadowHostElement() &&\",\n  \"LINE2\": \"         ParentOrShadowHostElement()->IsSVGElement();\",\n  \"LINE3\": \" }\",\n  \"LINE4\": \"bool SVGElement::HasSVGParent() const {\",\n  \"LINE5\": \"  return ParentOrShadowHostElement() &&\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  return ParentOrShadowHostElement() &&\",\n  \"vulnerability2\": \"         ParentOrShadowHostElement()->IsSVGElement();\",\n  \"vulnerability3\": \" }\",\n  \"vulnerability4\": \"bool SVGElement::HasSVGParent() const {\",\n  \"vulnerability5\": \"  return ParentOrShadowHostElement() &&\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  return ParentOrShadowHostElement() &&\",\n  \"vulnerability2\": \"         ParentOrShadowHostElement()->IsSVGElement();\",\n  \"",
    "truly_vulnerable_lines": "  return ParentOrShadowHostElement() &&\n         ParentOrShadowHostElement()->IsSVGElement();\n"
  },
  {
    "code": " ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(\n     ImageBitmapFactories& factory,\n     base::Optional<IntRect> crop_rect,\n     ScriptState* script_state,\n     const ImageBitmapOptions* options)\n    : loader_(\n           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),\n       factory_(&factory),\n       resolver_(ScriptPromiseResolver::Create(script_state)),\n       crop_rect_(crop_rect),\n       options_(options) {}\n",
    "response": "\n{\n  \"LINE1\": \"    : loader_(\",\n  \"LINE2\": \"           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),\",\n  \"LINE3\": \"       factory_(&factory),\",\n  \"LINE4\": \"       resolver_(ScriptPromiseResolver::Create(script_state)),\",\n  \"LINE5\": \"       crop_rect_(crop_rect),\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    : loader_(\",\n\"vulnerability2\": \"           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),\",\n\"vulnerability3\": \"       factory_(&factory),\",\n\"vulnerability4\": \"       resolver_(ScriptPromiseResolver::Create(script_state)),\",\n\"vulnerability5\": \"       crop_rect_(crop_rect),\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    : loader_(\",\n\"vulnerability2\": \"           FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer,",
    "truly_vulnerable_lines": "    : loader_(\n"
  },
  {
    "code": "void ImageBitmapFactories::ImageBitmapLoader::LoadBlobAsync(\n    Blob* blob) {\n   loader_->Start(blob->GetBlobDataHandle());\n }\n",
    "response": "\n{\n  \"LINE1\": \"   loader_->Start(blob->GetBlobDataHandle());\",\n  \"LINE2\": \"}\",\n  \"LINE3\": \"void ImageBitmapFactories::ImageBitmapLoader::LoadBlobAsync(\",\n  \"LINE4\": \"    Blob* blob) {\",\n  \"LINE5\": \"    blob->GetBlobDataHandle()\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"   loader_->Start(blob->GetBlobDataHandle());\",\n  \"vulnerability2\": \"}\",\n  \"vulnerability3\": \"void ImageBitmapFactories::ImageBitmapLoader::LoadBlobAsync(\",\n  \"vulnerability4\": \"    Blob* blob) {\",\n  \"vulnerability5\": \"    blob->GetBlobDataHandle()\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"   loader_->Start(blob->GetBlobDataHandle());\",\n  \"vulnerability2\": \"}\",\n  \"",
    "truly_vulnerable_lines": "    Blob* blob) {\n"
  },
  {
    "code": "void ImageBitmapFactories::Trace(blink::Visitor* visitor) {\n  visitor->Trace(pending_loaders_);\n  Supplement<LocalDOMWindow>::Trace(visitor);\n  Supplement<WorkerGlobalScope>::Trace(visitor);\n }\n",
    "response": "\n{\n  \"LINE1\": \"  visitor->Trace(pending_loaders_);\",\n  \"LINE2\": \"  Supplement<LocalDOMWindow>::Trace(visitor);\",\n  \"LINE3\": \"  Supplement<WorkerGlobalScope>::Trace(visitor);\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"void ImageBitmapFactories::Trace(blink::Visitor* visitor) {\"\n}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\"]}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\", \"vulnerability 6\", \"vulnerability 7\", \"vulnerability 8\", \"vulnerability 9\", \"vulnerability 10\"]}{\"vulnerabilities\": [\"vulnerability 1",
    "truly_vulnerable_lines": "  visitor->Trace(pending_loaders_);\n  Supplement<LocalDOMWindow>::Trace(visitor);\n  Supplement<WorkerGlobalScope>::Trace(visitor);\n"
  },
  {
    "code": "void RenderFrameImpl::OnSelectPopupMenuItem(int selected_index) {\n  if (external_popup_menu_ == NULL)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n  external_popup_menu_->DidSelectItem(selected_index);\n  external_popup_menu_.reset();\n }\n",
    "response": "\n{\n  \"LINE1\": \"  external_popup_menu_->DidSelectItem(selected_index);\",\n  \"LINE2\": \"  external_popup_menu_.reset();\",\n  \"LINE3\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  blink::WebScopedUserGesture gesture(frame_);\",\n  \"vulnerability2\": \"  external_popup_menu_->DidSelectItem(selected_index);\",\n  \"vulnerability3\": \"  external_popup_menu_.reset();\",\n  \"vulnerability4\": \"}\"{\"vulnerabilities\": [\"vulnerability1\": \"  blink::WebScopedUserGesture gesture(frame_);\",\n  \"vulnerability2\": \"  external_popup_menu_->DidSelectItem(selected_index);\",\n  \"vulnerability3\": \"  external_popup_menu_.reset();\",\n  \"vulnerability4\": \"}\"{\"vulnerabilities\": [\"vulnerability1\": \" ",
    "truly_vulnerable_lines": "  external_popup_menu_->DidSelectItem(selected_index);\n  external_popup_menu_.reset();\n"
  },
  {
    "code": " void RenderFrameImpl::OnSelectPopupMenuItems(\n    bool canceled,\n    const std::vector<int>& selected_indices) {\n  if (!external_popup_menu_)\n     return;\n \n   blink::WebScopedUserGesture gesture(frame_);\n  external_popup_menu_->DidSelectItems(canceled, selected_indices);\n  external_popup_menu_.reset();\n }\n",
    "response": "\n{\n  \"LINE1\": \"    bool canceled,\",\n  \"LINE2\": \"    const std::vector<int>& selected_indices) {\",\n  \"LINE3\": \"  if (!external_popup_menu_)\",\n  \"LINE4\": \"     return;\",\n  \"LINE5\": \"  external_popup_menu_->DidSelectItems(canceled, selected_indices);\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!external_popup_menu_)\",\n  \"vulnerability2\": \"     return;\",\n  \"vulnerability3\": \"  external_popup_menu_->DidSelectItems(canceled, selected_indices);\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!external_popup_menu_)\",\n  \"vulnerability2\": \"     return;\",\n  \"vulnerability3\": \"  external_popup_menu_->DidSelectItems(canceled, selected_indices);\"\n}{\"vulnerabilities\":",
    "truly_vulnerable_lines": "  external_popup_menu_->DidSelectItems(canceled, selected_indices);\n  external_popup_menu_.reset();\n"
  },
  {
    "code": "   void ProcessStateChangesPlanB(WebRtcSetDescriptionObserver::States states) {\n     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kPlanB);\n     std::vector<RTCRtpReceiver*> removed_receivers;\n    for (auto it = handler_->rtp_receivers_.begin();\n         it != handler_->rtp_receivers_.end(); ++it) {\n      if (ReceiverWasRemoved(*(*it), states.transceiver_states))\n        removed_receivers.push_back(it->get());\n    }\n \n     for (auto& transceiver_state : states.transceiver_states) {\n      if (ReceiverWasAdded(transceiver_state)) {\n         handler_->OnAddReceiverPlanB(transceiver_state.MoveReceiverState());\n       }\n     }\n     for (auto* removed_receiver : removed_receivers) {\n      handler_->OnRemoveReceiverPlanB(RTCRtpReceiver::getId(\n          removed_receiver->state().webrtc_receiver().get()));\n     }\n   }\n",
    "response": "\n{\n  \"LINE1\": \"      if (ReceiverWasAdded(transceiver_state)) {\",\n  \"LINE2\": \"         handler_->OnAddReceiverPlanB(transceiver_state.MoveReceiverState());\",\n  \"LINE3\": \"      }\",\n  \"LINE4\": \"      handler_->OnRemoveReceiverPlanB(RTCRtpReceiver::getId(\",\n  \"LINE5\": \"          removed_receiver->state().webrtc_receiver().get()));\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulner",
    "truly_vulnerable_lines": "      if (ReceiverWasAdded(transceiver_state)) {\n      handler_->OnRemoveReceiverPlanB(RTCRtpReceiver::getId(\n          removed_receiver->state().webrtc_receiver().get()));\n"
  },
  {
    "code": "   void ProcessStateChangesUnifiedPlan(\n       WebRtcSetDescriptionObserver::States states) {\n     DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kUnifiedPlan);\n    handler_->OnModifyTransceivers(\n        std::move(states.transceiver_states),\n        action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);\n   }\n",
    "response": "\n{\n  \"LINE1\": \"    handler_->OnModifyTransceivers(\",\n  \"LINE2\": \"        std::move(states.transceiver_states),\",\n  \"LINE3\": \"        action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);\",\n  \"LINE4\": \"    WebRtcSetDescriptionObserver::States states)\",\n  \"LINE5\": \"    DCHECK_EQ(sdp_semantics_, webrtc::SdpSemantics::kUnifiedPlan);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vul",
    "truly_vulnerable_lines": "    handler_->OnModifyTransceivers(\n        std::move(states.transceiver_states),\n        action_ == PeerConnectionTracker::ACTION_SET_REMOTE_DESCRIPTION);\n"
  },
  {
    "code": "void PaymentRequest::AreRequestedMethodsSupportedCallback(\n    bool methods_supported) {\n  if (methods_supported) {\n    if (SatisfiesSkipUIConstraints()) {\n      skipped_payment_request_ui_ = true;\n      Pay();\n    }\n  } else {\n    journey_logger_.SetNotShown(\n        JourneyLogger::NOT_SHOWN_REASON_NO_SUPPORTED_PAYMENT_METHOD);\n    client_->OnError(mojom::PaymentErrorReason::NOT_SUPPORTED);\n    if (observer_for_testing_)\n      observer_for_testing_->OnNotSupportedError();\n     OnConnectionTerminated();\n   }\n}\n",
    "response": "\n{\n  \"LINE1\": \"   OnConnectionTerminated();\",\n  \"LINE2\": \"}\",\n  \"LINE3\": \"\",\n  \"LINE4\": \"\",\n  \"LINE5\": \"\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"     OnConnectionTerminated();\",\n  \"vulnerability2\": \"}\",\n  \"vulnerability3\": \"\",\n  \"vulnerability4\": \"\",\n  \"vulnerability5\": \"\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"void PaymentRequest::AreRequestedMethodsSupportedCallback(\",\n  \"vulnerability2\": \"    bool methods_supported) {\",\n  \"vulnerability3\": \"  if (methods_supported) {\",\n  \"vulnerability4\": \"    if (SatisfiesSkipUIConstraints()) {\",\n  \"vulnerability5\": \"      skipped_payment_request_ui_ = true;\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    bool methods_supported) {\",\n",
    "truly_vulnerable_lines": "    bool methods_supported) {\n  if (methods_supported) {\n    if (SatisfiesSkipUIConstraints()) {\n      skipped_payment_request_ui_ = true;\n      Pay();\n    }\n  } else {\n    journey_logger_.SetNotShown(\n        JourneyLogger::NOT_SHOWN_REASON_NO_SUPPORTED_PAYMENT_METHOD);\n    client_->OnError(mojom::PaymentErrorReason::NOT_SUPPORTED);\n    if (observer_for_testing_)\n      observer_for_testing_->OnNotSupportedError();\n}\n"
  },
  {
    "code": " void PaymentRequest::Complete(mojom::PaymentComplete result) {\n  if (!client_.is_bound())\n     return;\n \n  if (result == mojom::PaymentComplete::FAIL) {\n    delegate_->ShowErrorMessage();\n  } else {\n    DCHECK(!has_recorded_completion_);\n    journey_logger_.SetCompleted();\n    has_recorded_completion_ = true;\n\n    delegate_->GetPrefService()->SetBoolean(kPaymentsFirstTransactionCompleted,\n                                            true);\n    client_->OnComplete();\n    state_->RecordUseStats();\n  }\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!client_.is_bound())\",\n  \"LINE2\": \"  if (result == mojom::PaymentComplete::FAIL)\",\n  \"LINE3\": \"    delegate_->ShowErrorMessage();\",\n  \"LINE4\": \"  } else {\",\n  \"LINE5\": \"    DCHECK(!has_recorded_completion_);\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    if (!client_.is_bound())\",\n  \"vulnerability2\": \"  if (result == mojom::PaymentComplete::FAIL)\",\n  \"vulnerability3\": \"    delegate_->ShowErrorMessage();\",\n  \"vulnerability4\": \"  } else {\",\n  \"vulnerability5\": \"    DCHECK(!has_recorded_completion_);\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!client_.is_bound())\",\n  \"vulnerability2\": \"  if (result == mojom::PaymentComplete::FAIL)\",\n",
    "truly_vulnerable_lines": "  if (!client_.is_bound())\n"
  },
  {
    "code": " void PaymentRequest::Retry(mojom::PaymentValidationErrorsPtr errors) {\n  if (!client_.is_bound() || !binding_.is_bound()) {\n    DLOG(ERROR) << \"Attempted Retry(), but binding(s) missing.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n  if (!display_handle_) {\n    DLOG(ERROR) << \"Attempted Retry(), but display_handle_ is nullptr.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n   std::string error;\n   if (!PaymentsValidators::IsValidPaymentValidationErrorsFormat(errors,\n                                                                 &error)) {\n    DLOG(ERROR) << error;\n     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);\n     OnConnectionTerminated();\n     return;\n  }\n\n  spec()->Retry(std::move(errors));\n   display_handle_->Retry();\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!display_handle_) {\",\n  \"LINE2\": \"    DLOG(ERROR) << \\\"Attempted Retry(), but display_handle_ is nullptr.\\\";\",\n  \"LINE3\": \"    DLOG(ERROR) << error;\",\n  \"LINE4\": \"    client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);\",\n  \"LINE5\": \"    OnConnectionTerminated();\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!display_handle_) {\",\n  \"vulnerability2\": \"    DLOG(ERROR) << \\\"Attempted Retry(), but display_handle_ is nullptr.\\\";\",\n  \"vulnerability3\": \"    DLOG(ERROR) << error;\",\n  \"vulnerability4\": \"    client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);\",\n  \"vulnerability5\": \"    OnConnectionTerminated();\"\n}{\"vulnerabilities\": [\"vulnerability",
    "truly_vulnerable_lines": "  if (!client_.is_bound() || !binding_.is_bound()) {\n    DLOG(ERROR) << \"Attempted Retry(), but binding(s) missing.\";\n  if (!display_handle_) {\n    DLOG(ERROR) << \"Attempted Retry(), but display_handle_ is nullptr.\";\n    DLOG(ERROR) << error;\n"
  },
  {
    "code": "bool PaymentRequest::SatisfiesSkipUIConstraints() const {\n  return base::FeatureList::IsEnabled(features::kWebPaymentsSingleAppUiSkip) &&\n         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&\n         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&\n         state()->available_instruments().size() == 1 &&\n         spec()->stringified_method_data().size() == 1 &&\n         !spec()->request_shipping() && !spec()->request_payer_name() &&\n         !spec()->request_payer_phone() &&\n         !spec()->request_payer_email()\n         && spec()->url_payment_method_identifiers().size() == 1;\n}\n",
    "response": "\n{\n  \"LINE1\": \"         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&\",\n  \"LINE2\": \"         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&\",\n  \"LINE3\": \"         state()->available_instruments().size() == 1 &&\",\n  \"LINE4\": \"         spec()->stringified_method_data().size() == 1 &&\",\n  \"LINE5\": \"         !spec()->request_shipping() && !spec()->request_payer_name() &&\"\n}{\"vulnerabilities\": [\"code line 1\",\n  \"code line 2\",\n  \"code line 3\",\n  \"code line 4\",\n  \"code line 5\"]}{\"vulnerabilities\": [\"         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&\",\n  \"         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&",
    "truly_vulnerable_lines": "  return base::FeatureList::IsEnabled(features::kWebPaymentsSingleAppUiSkip) &&\n         base::FeatureList::IsEnabled(::features::kServiceWorkerPaymentApps) &&\n         is_show_user_gesture_ && state()->is_get_all_instruments_finished() &&\n         state()->available_instruments().size() == 1 &&\n         spec()->stringified_method_data().size() == 1 &&\n         !spec()->request_shipping() && !spec()->request_payer_name() &&\n         !spec()->request_payer_phone() &&\n         !spec()->request_payer_email()\n         && spec()->url_payment_method_identifiers().size() == 1;\n}\n"
  },
  {
    "code": " void PaymentRequest::Show(bool is_user_gesture) {\n  if (!client_.is_bound() || !binding_.is_bound()) {\n    LOG(ERROR) << \"Attempted Show(), but binding(s) missing.\";\n     OnConnectionTerminated();\n     return;\n   }\n \n   display_handle_ = display_manager_->TryShow(delegate_.get());\n   if (!display_handle_) {\n    LOG(ERROR) << \"A PaymentRequest UI is already showing\";\n     journey_logger_.SetNotShown(\n         JourneyLogger::NOT_SHOWN_REASON_CONCURRENT_REQUESTS);\n     client_->OnError(mojom::PaymentErrorReason::ALREADY_SHOWING);\n    OnConnectionTerminated();\n    return;\n   }\n \n   if (!delegate_->IsBrowserWindowActive()) {\n    LOG(ERROR) << \"Cannot show PaymentRequest UI in a background tab\";\n     journey_logger_.SetNotShown(JourneyLogger::NOT_SHOWN_REASON_OTHER);\n     client_->OnError(mojom::PaymentErrorReason::USER_CANCEL);\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (!state_) {\n     AreRequestedMethodsSupportedCallback(false);\n     return;\n   }\n\n  is_show_user_gesture_ = is_user_gesture;\n\n  display_handle_->Show(this);\n\n  state_->AreRequestedMethodsSupported(\n      base::BindOnce(&PaymentRequest::AreRequestedMethodsSupportedCallback,\n                     weak_ptr_factory_.GetWeakPtr()));\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!client_.is_bound() || !binding_.is_bound()) {\",\n  \"LINE2\": \"    LOG(ERROR) << \\\"Attempted Show(), but binding(s) missing.\\\";\",\n  \"LINE3\": \"     OnConnectionTerminated();\",\n  \"LINE4\": \"     return;\",\n  \"LINE5\": \"  display_handle_ = display_manager_->TryShow(delegate_.get());\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulnerability line 9\", \"v",
    "truly_vulnerable_lines": "  if (!client_.is_bound() || !binding_.is_bound()) {\n    LOG(ERROR) << \"Attempted Show(), but binding(s) missing.\";\n    LOG(ERROR) << \"A PaymentRequest UI is already showing\";\n    LOG(ERROR) << \"Cannot show PaymentRequest UI in a background tab\";\n"
  },
  {
    "code": "void PaymentRequest::UpdateWith(mojom::PaymentDetailsPtr details) {\n   std::string error;\n   if (!ValidatePaymentDetails(ConvertPaymentDetails(details), &error)) {\n    LOG(ERROR) << error;\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (details->shipping_address_errors &&\n       !PaymentsValidators::IsValidAddressErrorsFormat(\n           details->shipping_address_errors, &error)) {\n    DLOG(ERROR) << error;\n     OnConnectionTerminated();\n     return;\n   }\n \n   if (!details->total) {\n    LOG(ERROR) << \"Missing total\";\n     OnConnectionTerminated();\n     return;\n   }\n\n  spec_->UpdateWith(std::move(details));\n }\n",
    "response": "\n{\n  \"LINE1\": \"    LOG(ERROR) << error;\",\n  \"LINE2\": \"    DLOG(ERROR) << error;\",\n  \"LINE3\": \"    LOG(ERROR) << \\\"Missing total\\\";\",\n  \"LINE4\": \"     OnConnectionTerminated();\",\n  \"LINE5\": \"     OnConnectionTerminated();\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"    LOG(ERROR) << error;\",\n  \"vulnerability2\": \"    DLOG(ERROR) << error;\",\n  \"vulnerability3\": \"    LOG(ERROR) << \\\"Missing total\\\";\",\n  \"vulnerability4\": \"     OnConnectionTerminated();\",\n  \"vulnerability5\": \"     OnConnectionTerminated();\"]}{\"vulnerabilities\": [\"vulnerability1\": \"    LOG(ERROR) << error;\",\n  \"vulnerability2\": \"    DLOG(ERROR) << error;\",\n  \"vulnerability3\": \"    LOG(ERROR) << \\\"Missing total\\\";\",\n  \"",
    "truly_vulnerable_lines": "    LOG(ERROR) << error;\n    DLOG(ERROR) << error;\n    LOG(ERROR) << \"Missing total\";\n"
  },
  {
    "code": "void RenderFrameHostImpl::CreateMediaStreamDispatcherHost(\n    MediaStreamManager* media_stream_manager,\n    mojom::MediaStreamDispatcherHostRequest request) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!media_stream_dispatcher_host_) {\n    media_stream_dispatcher_host_.reset(new MediaStreamDispatcherHost(\n        GetProcess()->GetID(), GetRoutingID(), media_stream_manager));\n  }\n  media_stream_dispatcher_host_->BindRequest(std::move(request));\n}\n",
    "response": "\n{\n  \"LINE1\": \"code line 1\",\n  \"LINE2\": \"code line 2\",\n  \"LINE3\": \"code line 3\",\n  \"LINE4\": \"code line 4\",\n  \"LINE5\": \"code line 5\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulnerability line 9\", \"vulnerability line 10\", \"vulnerability line 11\", \"vulnerability line 12\", \"vulnerability line 13\", \"vulnerability line 14",
    "truly_vulnerable_lines": "    MediaStreamManager* media_stream_manager,\n    mojom::MediaStreamDispatcherHostRequest request) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!media_stream_dispatcher_host_) {\n    media_stream_dispatcher_host_.reset(new MediaStreamDispatcherHost(\n        GetProcess()->GetID(), GetRoutingID(), media_stream_manager));\n  }\n  media_stream_dispatcher_host_->BindRequest(std::move(request));\n}\n"
  },
  {
    "code": "void MediaStreamDispatcherHost::BindRequest(\n     mojom::MediaStreamDispatcherHostRequest request) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  bindings_.AddBinding(this, std::move(request));\n }\n",
    "response": "\n{\n  \"LINE1\": \"  bindings_.AddBinding(this, std::move(request));\",\n  \"LINE2\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  bindings_.AddBinding(this, std::move(request));\",\n  \"vulnerability2\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  bindings_.AddBinding(this, std::move(request));\",\n  \"vulnerability2\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  bindings_.AddBinding(this, std::move(request));\",\n  \"vulnerability2\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  bindings_.AddBinding(this, std::move(request));\",\n  \"vulnerability2\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  bindings_.AddBinding(this, std::move(request));\",\n  \"vulnerability2\":",
    "truly_vulnerable_lines": "  bindings_.AddBinding(this, std::move(request));\n"
  },
  {
    "code": " void MediaStreamDispatcherHost::CancelAllRequests() {\n  if (!bindings_.empty())\n    return;\n  media_stream_manager_->CancelAllRequests(render_process_id_,\n                                           render_frame_id_);\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!bindings_.empty())\",\n  \"LINE2\": \"    return;\",\n  \"LINE3\": \"  media_stream_manager_->CancelAllRequests(render_process_id_,\",\n  \"LINE4\": \"                                           render_frame_id_);\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!bindings_.empty())\",\n  \"vulnerability2\": \"    return;\",\n  \"vulnerability3\": \"  media_stream_manager_->CancelAllRequests(render_process_id_,\",\n  \"vulnerability4\": \"                                           render_frame_id_);\",\n  \"vulnerability5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!bindings_.empty())\",\n  \"vulnerability2\": \"    return;\",\n  \"vulnerability3\": \"  media_stream_manager_->CancelAllRequests(render_process_id_,\",\n  \"v",
    "truly_vulnerable_lines": "  if (!bindings_.empty())\n    return;\n  media_stream_manager_->CancelAllRequests(render_process_id_,\n                                           render_frame_id_);\n"
  },
  {
    "code": "void MediaStreamDispatcherHost::CancelRequest(int page_request_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   media_stream_manager_->CancelRequest(render_process_id_, render_frame_id_,\n                                       page_request_id);\n }\n",
    "response": "\n{\n  \"LINE1\": \"                                       page_request_id);\",\n  \"LINE2\": \"  media_stream_manager_->CancelRequest(render_process_id_, render_frame_id_,\",\n  \"LINE3\": \"                                       page_request_id);\",\n  \"LINE4\": \"  media_stream_manager_->CancelRequest(render_process_id_, render_frame_id_,\",\n  \"LINE5\": \"                                       page_request_id);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulnerability line 9\", \"v",
    "truly_vulnerable_lines": "                                       page_request_id);\n"
  },
  {
    "code": "void MediaStreamDispatcherHost::DoGenerateStream(\n    int32_t page_request_id,\n    const StreamControls& controls,\n    bool user_gesture,\n    GenerateStreamCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(MEDIA_DEVICE_INVALID_SECURITY_ORIGIN, std::string(),\n                            MediaStreamDevices(), MediaStreamDevices());\n    return;\n   }\n \n   media_stream_manager_->GenerateStream(\n      render_process_id_, render_frame_id_, page_request_id, controls,\n      std::move(salt_and_origin), user_gesture, std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceChanged,\n                          weak_factory_.GetWeakPtr()));\n}\n",
    "response": "\n{\n  \"LINE1\": \"      render_process_id_, render_frame_id_, page_request_id, controls,\",\n  \"LINE2\": \"      std::move(salt_and_origin), user_gesture, std::move(callback),\",\n  \"LINE3\": \"          weak_factory_.GetWeakPtr()),\",\n  \"LINE4\": \"          weak_factory_.GetWeakPtr()));\",\n  \"LINE5\": \"}{\"vulnerabilities\": [\"code line 1\",\n      render_process_id_, render_frame_id_, page_request_id, controls,\n      std::move(salt_and_origin), user_gesture, std::move(callback),\n          weak_factory_.GetWeakPtr()),\n          weak_factory_.GetWeakPtr()));\n}{\"vulnerabilities\": [\"code line 1\",\n      render_process_id_, render_frame_id_, page_request_id, controls,\n      std::move(salt_and_origin), user_gesture, std::move(callback),\n          weak_factory_.",
    "truly_vulnerable_lines": "      render_process_id_, render_frame_id_, page_request_id, controls,\n      std::move(salt_and_origin), user_gesture, std::move(callback),\n"
  },
  {
    "code": "void MediaStreamDispatcherHost::DoOpenDevice(\n    int32_t page_request_id,\n    const std::string& device_id,\n    MediaStreamType type,\n    OpenDeviceCallback callback,\n    MediaDeviceSaltAndOrigin salt_and_origin) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  if (!MediaStreamManager::IsOriginAllowed(render_process_id_,\n                                           salt_and_origin.origin)) {\n    std::move(callback).Run(false /* success */, std::string(),\n                            MediaStreamDevice());\n    return;\n   }\n \n   media_stream_manager_->OpenDevice(\n      render_process_id_, render_frame_id_, page_request_id, device_id, type,\n      std::move(salt_and_origin), std::move(callback),\n       base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n }\n",
    "response": "\n{\n  \"LINE1\": \"      render_process_id_, render_frame_id_, page_request_id, device_id, type,\",\n  \"LINE2\": \"      std::move(salt_and_origin), std::move(callback),\",\n  \"LINE3\": \"           weak_factory_.GetWeakPtr()));\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n      render_process_id_, render_frame_id_, page_request_id, device_id, type,\n      std::move(salt_and_origin), std::move(callback),\n      base::BindRepeating(&MediaStreamDispatcherHost::OnDeviceStopped,\n                           weak_factory_.GetWeakPtr()));\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n      render_process_id_, render_frame_id_, page_request_id, device_id, type,\n      std::move(salt_and_origin), std::move(callback),\n",
    "truly_vulnerable_lines": "      render_process_id_, render_frame_id_, page_request_id, device_id, type,\n      std::move(salt_and_origin), std::move(callback),\n"
  },
  {
    "code": " MediaStreamDispatcherHost::MediaStreamDispatcherHost(\n     int render_process_id,\n     int render_frame_id,\n     MediaStreamManager* media_stream_manager)\n     : render_process_id_(render_process_id),\n       render_frame_id_(render_frame_id),\n       media_stream_manager_(media_stream_manager),\n       salt_and_origin_callback_(\n           base::BindRepeating(&GetMediaDeviceSaltAndOrigin)),\n       weak_factory_(this) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  bindings_.set_connection_error_handler(\n      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,\n                 weak_factory_.GetWeakPtr()));\n }\n",
    "response": "\n{\n  \"LINE1\": \"bindings_.set_connection_error_handler(\",\n  \"LINE2\": \"      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,\",\n  \"LINE3\": \"                 weak_factory_.GetWeakPtr()));\",\n  \"LINE4\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\",\n  \"LINE5\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulnerability line 9\", \"v",
    "truly_vulnerable_lines": "  bindings_.set_connection_error_handler(\n      base::Bind(&MediaStreamDispatcherHost::CancelAllRequests,\n                 weak_factory_.GetWeakPtr()));\n"
  },
  {
    "code": " void MediaStreamDispatcherHost::StopStreamDevice(const std::string& device_id,\n                                                  int32_t session_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   media_stream_manager_->StopStreamDevice(render_process_id_, render_frame_id_,\n                                          device_id, session_id);\n }\n",
    "response": "\n{\n  \"LINE1\": \"                                                  int32_t session_id) {\",\n  \"LINE2\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\",\n  \"LINE3\": \"  media_stream_manager_->StopStreamDevice(render_process_id_, render_frame_id_,\",\n  \"LINE4\": \"                                          device_id, session_id);\",\n  \"LINE5\": \"  StopStreamDeviceInternal(device_id, session_id);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n                                                  int32_t session_id) {\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_id);\n                                          device_id, session_",
    "truly_vulnerable_lines": "                                          device_id, session_id);\n"
  },
  {
    "code": " MediaStreamDispatcherHost::~MediaStreamDispatcherHost() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  bindings_.CloseAllBindings();\n   CancelAllRequests();\n }\n",
    "response": "\n{\n  \"LINE1\": \"bindings_.CloseAllBindings();\",\n  \"LINE2\": \"CancelAllRequests();\",\n  \"LINE3\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\",\n  \"LINE4\": \"MediaStreamDispatcherHost::~MediaStreamDispatcherHost() {\",\n  \"LINE5\": \"  bindings_.CloseAllBindings();\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  bindings_.CloseAllBindings();\",\n  \"vulnerability2\": \"CancelAllRequests();\",\n  \"vulnerability3\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\",\n  \"vulnerability4\": \"MediaStreamDispatcherHost::~MediaStreamDispatcherHost() {\",\n  \"vulnerability5\": \"  bindings_.CloseAllBindings();\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  bindings_.CloseAllBindings();\",\n  \"vulnerability2\": \"CancelAllRequests();\",\n  \"v",
    "truly_vulnerable_lines": "  bindings_.CloseAllBindings();\n"
  },
  {
    "code": " void MediaStreamManager::CancelAllRequests(int render_process_id,\n                                           int render_frame_id) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   auto request_it = requests_.begin();\n   while (request_it != requests_.end()) {\n     if (request_it->second->requesting_process_id != render_process_id ||\n        request_it->second->requesting_frame_id != render_frame_id) {\n       ++request_it;\n       continue;\n     }\n    const std::string label = request_it->first;\n    ++request_it;\n    CancelRequest(label);\n  }\n}\n",
    "response": "\n{\n  \"LINE1\": \"        request_it->second->requesting_frame_id != render_frame_id) {\",\n  \"LINE2\": \"       ++request_it;\",\n  \"LINE3\": \"       continue;\",\n  \"LINE4\": \"     }\",\n  \"LINE5\": \"    const std::string label = request_it->first;\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"        request_it->second->requesting_frame_id != render_frame_id) {\",\n  \"vulnerability2\": \"       ++request_it;\",\n  \"vulnerability3\": \"       continue;\",\n  \"vulnerability4\": \"     }\",\n  \"vulnerability5\": \"    const std::string label = request_it->first;\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"                                           int render_frame_id) {\",\n  \"vulnerability2\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\",",
    "truly_vulnerable_lines": "                                           int render_frame_id) {\n        request_it->second->requesting_frame_id != render_frame_id) {\n"
  },
  {
    "code": " void MediaStreamManager::GenerateStream(\n     int render_process_id,\n     int render_frame_id,\n     int page_request_id,\n     const StreamControls& controls,\n     MediaDeviceSaltAndOrigin salt_and_origin,\n    bool user_gesture,\n    GenerateStreamCallback generate_stream_cb,\n    DeviceStoppedCallback device_stopped_cb,\n    DeviceChangedCallback device_changed_cb) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   DVLOG(1) << \"GenerateStream()\";\n \n   DeviceRequest* request = new DeviceRequest(\n      render_process_id, render_frame_id, page_request_id, user_gesture,\n      MEDIA_GENERATE_STREAM, controls, std::move(salt_and_origin),\n       std::move(device_stopped_cb));\n   request->device_changed_cb = std::move(device_changed_cb);\n \n  const std::string& label = AddRequest(request);\n\n  request->generate_stream_cb = std::move(generate_stream_cb);\n\n  if (generate_stream_test_callback_) {\n    if (std::move(generate_stream_test_callback_).Run(controls)) {\n      FinalizeGenerateStream(label, request);\n    } else {\n      FinalizeRequestFailed(label, request, MEDIA_DEVICE_INVALID_STATE);\n    }\n    return;\n  }\n\n  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},\n                           base::BindOnce(&MediaStreamManager::SetUpRequest,\n                                          base::Unretained(this), label));\n}\n",
    "response": "\n{\n  \"LINE1\": \"    bool user_gesture,\",\n  \"LINE2\": \"    GenerateStreamCallback generate_stream_cb,\",\n  \"LINE3\": \"    DeviceStoppedCallback device_stopped_cb,\",\n  \"LINE4\": \"    DeviceChangedCallback device_changed_cb)\",\n  \"LINE5\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\"]}{\"vulnerabilities\": [\"    bool user_gesture,\",\n  \"    GenerateStreamCallback generate_stream_cb,\",\n  \"    DeviceStoppedCallback device_stopped_cb,\",\n  \"    DeviceChangedCallback device_changed_cb)\",\n  \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\"]}{\"vulnerabilities\": [\"    bool user_gesture",
    "truly_vulnerable_lines": "      render_process_id, render_frame_id, page_request_id, user_gesture,\n      MEDIA_GENERATE_STREAM, controls, std::move(salt_and_origin),\n"
  },
  {
    "code": " std::string MediaStreamManager::MakeMediaAccessRequest(\n     int render_process_id,\n     int render_frame_id,\n     int page_request_id,\n     const StreamControls& controls,\n     const url::Origin& security_origin,\n     MediaAccessRequestCallback callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n \n   DeviceRequest* request = new DeviceRequest(\n      render_process_id, render_frame_id, page_request_id,\n       false /* user gesture */, MEDIA_DEVICE_ACCESS, controls,\n       MediaDeviceSaltAndOrigin{std::string() /* salt */,\n                                std::string() /* group_id_salt */,\n                               security_origin});\n\n  const std::string& label = AddRequest(request);\n\n  request->media_access_request_cb = std::move(callback);\n  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},\n                           base::BindOnce(&MediaStreamManager::SetUpRequest,\n                                          base::Unretained(this), label));\n  return label;\n}\n",
    "response": "\n{\n  \"LINE1\": \"      render_process_id, render_frame_id, page_request_id,\",\n  \"LINE2\": \"       false /* user gesture */, MEDIA_DEVICE_ACCESS, controls,\",\n  \"LINE3\": \"                               security_origin});\",\n  \"LINE4\": \"  const std::string& label = AddRequest(request);\",\n  \"LINE5\": \"  request->media_access_request_cb = std::move(callback);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\",\n  \"vulnerability line 6\",\n  \"v",
    "truly_vulnerable_lines": "      render_process_id, render_frame_id, page_request_id,\n"
  },
  {
    "code": " void MediaStreamManager::OpenDevice(int render_process_id,\n                                     int render_frame_id,\n                                     int page_request_id,\n                                     const std::string& device_id,\n                                     MediaStreamType type,\n                                    MediaDeviceSaltAndOrigin salt_and_origin,\n                                    OpenDeviceCallback open_device_cb,\n                                    DeviceStoppedCallback device_stopped_cb) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DCHECK(type == MEDIA_DEVICE_AUDIO_CAPTURE ||\n         type == MEDIA_DEVICE_VIDEO_CAPTURE);\n  DVLOG(1) << \"OpenDevice ({page_request_id = \" << page_request_id << \"})\";\n  StreamControls controls;\n  if (IsAudioInputMediaType(type)) {\n    controls.audio.requested = true;\n    controls.audio.stream_type = type;\n    controls.audio.device_id = device_id;\n  } else if (IsVideoInputMediaType(type)) {\n    controls.video.requested = true;\n    controls.video.stream_type = type;\n    controls.video.device_id = device_id;\n  } else {\n     NOTREACHED();\n   }\n   DeviceRequest* request = new DeviceRequest(\n      render_process_id, render_frame_id, page_request_id,\n       false /* user gesture */, MEDIA_OPEN_DEVICE_PEPPER_ONLY, controls,\n       std::move(salt_and_origin), std::move(device_stopped_cb));\n \n  const std::string& label = AddRequest(request);\n\n  request->open_device_cb = std::move(open_device_cb);\n  base::PostTaskWithTraits(FROM_HERE, {BrowserThread::IO},\n                           base::BindOnce(&MediaStreamManager::SetUpRequest,\n                                          base::Unretained(this), label));\n}\n",
    "response": "\n{\n  \"LINE1\": \"                                     MediaDeviceSaltAndOrigin salt_and_origin,\",\n  \"LINE2\": \"                                    OpenDeviceCallback open_device_cb,\",\n  \"LINE3\": \"                                    DeviceStoppedCallback device_stopped_cb)\",\n  \"LINE4\": \"  DCHECK_CURRENTLY_ON(BrowserThread::IO);\",\n  \"LINE5\": \"  DCHECK(type == MEDIA_DEVICE_AUDIO_CAPTURE ||\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n                                     MediaDeviceSaltAndOrigin salt_and_origin,\n                                     OpenDeviceCallback open_device_cb,\n                                     DeviceStoppedCallback device_stopped_cb) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  DCHECK(type == MEDIA_DEVICE_AUDIO_CAPTURE ||\n         type == MEDIA_DEVICE_VIDEO_CAPTURE);\n  DVLOG(1) << \"OpenDevice ({page_request_id = \" << page_request_id << \"",
    "truly_vulnerable_lines": "      render_process_id, render_frame_id, page_request_id,\n"
  },
  {
    "code": "   std::string MakeMediaAccessRequest(int index) {\n     const int render_process_id = 1;\n     const int render_frame_id = 1;\n     const int page_request_id = 1;\n     const url::Origin security_origin;\n     MediaStreamManager::MediaAccessRequestCallback callback =\n         base::BindOnce(&MediaStreamManagerTest::ResponseCallback,\n                        base::Unretained(this), index);\n     StreamControls controls(true, true);\n     return media_stream_manager_->MakeMediaAccessRequest(\n        render_process_id, render_frame_id, page_request_id, controls,\n        security_origin, std::move(callback));\n   }\n",
    "response": "\n{\n  \"LINE1\": \"                        base::Unretained(this), index);\",\n  \"LINE2\": \"        render_process_id, render_frame_id, page_request_id, controls,\",\n  \"LINE3\": \"        security_origin, std::move(callback));\",\n  \"LINE4\": \"    return media_stream_manager_->MakeMediaAccessRequest(\",\n  \"LINE5\": \"        render_process_id, render_frame_id, page_request_id, controls,\",\n  \"LINE6\": \"        security_origin, std::move(callback));\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6",
    "truly_vulnerable_lines": "        render_process_id, render_frame_id, page_request_id, controls,\n        security_origin, std::move(callback));\n"
  },
  {
    "code": " VideoCaptureManager::~VideoCaptureManager() {\n  DCHECK(controllers_.empty());\n   DCHECK(device_start_request_queue_.empty());\n   if (screenlock_monitor_) {\n     screenlock_monitor_->RemoveObserver(this);\n  }\n}\n",
    "response": "\n{\n  \"LINE1\": \"  DCHECK(controllers_.empty());\",\n  \"LINE2\": \"  DCHECK(device_start_request_queue_.empty());\",\n  \"LINE3\": \"  if (screenlock_monitor_) {\",\n  \"LINE4\": \"    screenlock_monitor_->RemoveObserver(this);\",\n  \"LINE5\": \"  }\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  DCHECK(controllers_.empty());\",\n  \"vulnerability2\": \"  DCHECK(device_start_request_queue_.empty());\",\n  \"vulnerability3\": \"  if (screenlock_monitor_) {\",\n  \"vulnerability4\": \"    screenlock_monitor_->RemoveObserver(this);\",\n  \"vulnerability5\": \"  }\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  DCHECK(controllers_.empty());\",\n  \"vulnerability2\": \"  DCHECK(device_start_request_queue_.empty());\",\n  \"vulner",
    "truly_vulnerable_lines": "  DCHECK(controllers_.empty());\n"
  },
  {
    "code": "   void OpenSession() {\n     const int render_process_id = 1;\n     const int render_frame_id = 1;\n     const int page_request_id = 1;\n     const url::Origin security_origin =\n         url::Origin::Create(GURL(\"http://test.com\"));\n\n    ASSERT_TRUE(opened_device_label_.empty());\n\n    MediaDeviceInfoArray video_devices;\n    {\n      base::RunLoop run_loop;\n      MediaDevicesManager::BoolDeviceTypes devices_to_enumerate;\n      devices_to_enumerate[MEDIA_DEVICE_TYPE_VIDEO_INPUT] = true;\n      media_stream_manager_->media_devices_manager()->EnumerateDevices(\n          devices_to_enumerate,\n          base::BindOnce(&VideoInputDevicesEnumerated, run_loop.QuitClosure(),\n                         browser_context_.GetMediaDeviceIDSalt(),\n                         security_origin, &video_devices));\n      run_loop.Run();\n    }\n    ASSERT_FALSE(video_devices.empty());\n\n     {\n       base::RunLoop run_loop;\n       media_stream_manager_->OpenDevice(\n          render_process_id, render_frame_id, page_request_id,\n           video_devices[0].device_id, MEDIA_DEVICE_VIDEO_CAPTURE,\n           MediaDeviceSaltAndOrigin{browser_context_.GetMediaDeviceIDSalt(),\n                                    browser_context_.GetMediaDeviceIDSalt(),\n                                   security_origin},\n          base::BindOnce(&VideoCaptureTest::OnDeviceOpened,\n                         base::Unretained(this), run_loop.QuitClosure()),\n          MediaStreamManager::DeviceStoppedCallback());\n      run_loop.Run();\n    }\n    ASSERT_NE(MediaStreamDevice::kNoId, opened_session_id_);\n  }\n",
    "response": "\n{\n  \"LINE1\": \"          render_process_id, render_frame_id, page_request_id,\",\n  \"LINE2\": \"           video_devices[0].device_id, MEDIA_DEVICE_VIDEO_CAPTURE,\",\n  \"LINE3\": \"           MediaDeviceSaltAndOrigin{browser_context_.GetMediaDeviceIDSalt(),\",\n  \"LINE4\": \"                                    browser_context_.GetMediaDeviceIDSalt(),\",\n  \"LINE5\": \"          base::BindOnce(&VideoCaptureTest::OnDeviceOpened,\",\n  \"LINE6\": \"                         base::Unretained(this), run_loop.QuitClosure()),\",\n  \"LINE7\": \"          MediaStreamManager::DeviceStoppedCallback());\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line ",
    "truly_vulnerable_lines": "          render_process_id, render_frame_id, page_request_id,\n"
  },
  {
    "code": "void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,\n                                                              bool ask_user,\n                                                              bool is_allowed) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  auto iter = sessions_.find(session_id);\n  if (iter == sessions_.end())\n    return;\n\n  Session* session = iter->second.get();\n\n  if (session->abort_requested)\n    return;\n\n   if (ask_user) {\n     SpeechRecognitionSessionContext& context = session->context;\n     context.label = media_stream_manager_->MakeMediaAccessRequest(\n        context.render_process_id, context.render_frame_id, session_id,\n        StreamControls(true, false), context.security_origin,\n         base::BindOnce(\n             &SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,\n             weak_factory_.GetWeakPtr(), session_id));\n    return;\n  }\n\n  if (is_allowed) {\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,\n                       weak_factory_.GetWeakPtr(), session_id, EVENT_START));\n  } else {\n    OnRecognitionError(\n        session_id, blink::mojom::SpeechRecognitionError(\n                        blink::mojom::SpeechRecognitionErrorCode::kNotAllowed,\n                        blink::mojom::SpeechAudioErrorDetails::kNone));\n    base::ThreadTaskRunnerHandle::Get()->PostTask(\n        FROM_HERE,\n        base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,\n                       weak_factory_.GetWeakPtr(), session_id, EVENT_ABORT));\n  }\n}\n",
    "response": "\n{\n  \"LINE1\": \"        context.render_process_id, context.render_frame_id, session_id,\",\n  \"LINE2\": \"        StreamControls(true, false), context.security_origin,\",\n  \"LINE3\": \"         base::BindOnce\",\n  \"LINE4\": \"             &SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,\",\n  \"LINE5\": \"             weak_factory_.GetWeakPtr(), session_id));\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n                                                              bool ask_user,\n                                                              bool is_allowed) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n\n  auto iter = sessions_.find(session_id);\n  if (iter == sessions_.end())\n    return;\n\n  Session* session = iter->second.get();\n\n  if (session->abort_requested)\n    return;\n\n   if (ask_user) {\n     SpeechRecognitionSessionContext& context = session->context;\n     context.label",
    "truly_vulnerable_lines": "        context.render_process_id, context.render_frame_id, session_id,\n        StreamControls(true, false), context.security_origin,\n"
  },
  {
    "code": "DOMHandler::DOMHandler()\n     : DevToolsDomainHandler(DOM::Metainfo::domainName),\n      host_(nullptr) {\n}\n",
    "response": "\n{\n  \"LINE1\": \"     : DevToolsDomainHandler(DOM::Metainfo::domainName),\",\n  \"LINE2\": \"      host_(nullptr) {\",\n  \"LINE3\": \"}\",\n  \"LINE4\": \"DOMHandler::DOMHandler()\",\n  \"LINE5\": \"     : DevToolsDomainHandler(DOM::Metainfo::domainName),\"\n}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8\", \"vulnerability9\", \"vulnerability10\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5",
    "truly_vulnerable_lines": "      host_(nullptr) {\n}\n"
  },
  {
    "code": "bool RenderFrameDevToolsAgentHost::AttachSession(DevToolsSession* session) {\n  if (!ShouldAllowSession(session))\n    return false;\n\n   protocol::EmulationHandler* emulation_handler =\n       new protocol::EmulationHandler();\n   session->AddHandler(base::WrapUnique(new protocol::BrowserHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n   session->AddHandler(base::WrapUnique(emulation_handler));\n   session->AddHandler(base::WrapUnique(new protocol::InputHandler()));\n   session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(\n      GetId(),\n      frame_tree_node_ ? frame_tree_node_->devtools_frame_token()\n                       : base::UnguessableToken(),\n      GetIOContext())));\n  session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::ServiceWorkerHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::StorageHandler()));\n  session->AddHandler(base::WrapUnique(new protocol::TargetHandler(\n      session->client()->MayAttachToBrowser()\n          ? protocol::TargetHandler::AccessMode::kRegular\n          : protocol::TargetHandler::AccessMode::kAutoAttachOnly,\n      GetId(), GetRendererChannel(), session->GetRootSession())));\n  session->AddHandler(base::WrapUnique(new protocol::PageHandler(\n      emulation_handler, session->client()->MayAffectLocalFiles())));\n  session->AddHandler(base::WrapUnique(new protocol::SecurityHandler()));\n  if (!frame_tree_node_ || !frame_tree_node_->parent()) {\n    session->AddHandler(base::WrapUnique(\n        new protocol::TracingHandler(frame_tree_node_, GetIOContext())));\n  }\n\n  if (sessions().empty()) {\n    bool use_video_capture_api = true;\n#ifdef OS_ANDROID\n    if (!CompositorImpl::IsInitialized())\n      use_video_capture_api = false;\n#endif\n    if (!use_video_capture_api)\n      frame_trace_recorder_.reset(new DevToolsFrameTraceRecorder());\n    GrantPolicy();\n#if defined(OS_ANDROID)\n    GetWakeLock()->RequestWakeLock();\n#endif\n  }\n  return true;\n}\n",
    "response": "\n{\n  \"LINE1\": \"  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\",\n  \"LINE2\": \"  session->AddHandler(base::WrapUnique(emulation_handler));\",\n  \"LINE3\": \"  session->AddHandler(base::WrapUnique(new protocol::IOHandler(\",\n  \"LINE4\": \"      GetIOContext())));\",\n  \"LINE5\": \"  session->AddHandler(base::WrapUnique(new protocol::MemoryHandler()));\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line",
    "truly_vulnerable_lines": "  session->AddHandler(base::WrapUnique(new protocol::DOMHandler()));\n"
  },
  {
    "code": "bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\n                             const PermissionSet& required_permissions,\n                             const PermissionSet& optional_permissions,\n                             bool allow_file_access,\n                             UnpackPermissionSetResult* result,\n                             std::string* error) {\n  int user_script_schemes = UserScript::ValidUserScriptSchemes();\n  int explicit_schemes = Extension::kValidHostPermissionSchemes;\n  if (!allow_file_access) {\n    user_script_schemes &= ~URLPattern::SCHEME_FILE;\n     explicit_schemes &= ~URLPattern::SCHEME_FILE;\n   }\n \n   for (const auto& origin_str : origins_input) {\n     URLPattern explicit_origin(explicit_schemes);\n     URLPattern::ParseResult parse_result = explicit_origin.Parse(origin_str);\n    if (URLPattern::ParseResult::kSuccess != parse_result) {\n      *error = ErrorUtils::FormatErrorMessage(\n          kInvalidOrigin, origin_str,\n          URLPattern::GetParseResultString(parse_result));\n       return false;\n     }\n \n     bool used_origin = false;\n     if (required_permissions.explicit_hosts().ContainsPattern(\n             explicit_origin)) {\n      used_origin = true;\n      result->required_explicit_hosts.AddPattern(explicit_origin);\n    } else if (optional_permissions.explicit_hosts().ContainsPattern(\n                   explicit_origin)) {\n      used_origin = true;\n      result->optional_explicit_hosts.AddPattern(explicit_origin);\n    }\n \n     URLPattern scriptable_origin(user_script_schemes);\n     if (scriptable_origin.Parse(origin_str) ==\n            URLPattern::ParseResult::kSuccess &&\n        required_permissions.scriptable_hosts().ContainsPattern(\n            scriptable_origin)) {\n      used_origin = true;\n      result->required_scriptable_hosts.AddPattern(scriptable_origin);\n     }\n \n     if (!used_origin)\n      result->unlisted_hosts.AddPattern(explicit_origin);\n  }\n\n  return true;\n}\n",
    "response": "\n{\n  \"LINE1\": \"bool UnpackOriginPermissions(const std::vector<std::string>& origins_input,\",\n  \"LINE2\": \"                             const PermissionSet& required_permissions,\",\n  \"LINE3\": \"                             const PermissionSet& optional_permissions,\",\n  \"LINE4\": \"                             bool allow_file_access,\",\n  \"LINE5\": \"                             UnpackPermissionSetResult* result,\",\n  \"LINE6\": \"                             std::string* error)\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\",\n  \"vulnerability line 6\",\n  \"vulnerability line 7\",\n  \"vulnerability line 8\",\n  \"vulnerability line 9\",\n  \"vulnerability line 10\",\n  \"vulnerability line 11\",\n  \"vulnerability line",
    "truly_vulnerable_lines": "            URLPattern::ParseResult::kSuccess &&\n        required_permissions.scriptable_hosts().ContainsPattern(\n            scriptable_origin)) {\n      used_origin = true;\n      result->required_scriptable_hosts.AddPattern(scriptable_origin);\n"
  },
  {
    "code": " void ChromeContentBrowserClient::OpenURL(\n    content::BrowserContext* browser_context,\n     const content::OpenURLParams& params,\n    const base::Callback<void(content::WebContents*)>& callback) {\n   DCHECK_CURRENTLY_ON(BrowserThread::UI);\n \n #if defined(OS_ANDROID)\n   ServiceTabLauncher::GetInstance()->LaunchTab(browser_context, params,\n                                               callback);\n#else\n  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),\n                            params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav_params.user_gesture = params.user_gesture;\n\n  Navigate(&nav_params);\n  callback.Run(nav_params.navigated_or_inserted_contents);\n#endif\n}\n",
    "response": "\n{\n  \"LINE1\":     content::BrowserContext* browser_context,\n    const base::Callback<void(content::WebContents*)>& callback) {\n  #if defined(OS_ANDROID)\n  #else\n  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),\n                            params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav_params.user_gesture = params.user_gesture;\n\n  Navigate(&nav_params);\n  callback.Run(nav_params.navigated_or_inserted_contents);\n#endif\n}\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n    const base::Callback<void(content::WebContents*)>& callback) {\n  #if defined(OS_ANDROID)\n  #else\n  NavigateParams nav_params(Profile::FromBrowserContext(browser_context),\n                            params.url, params.transition);\n  nav_params.FillNavigateParamsFromOpenURLParams(params);\n  nav",
    "truly_vulnerable_lines": "    content::BrowserContext* browser_context,\n    const base::Callback<void(content::WebContents*)>& callback) {\n"
  },
  {
    "code": " void WebGL2RenderingContextBase::bindSampler(GLuint unit,\n                                              WebGLSampler* sampler) {\n  if (isContextLost())\n    return;\n   bool deleted;\n   if (!CheckObjectToBeBound(\"bindSampler\", sampler, deleted))\n     return;\n  if (deleted) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"bindSampler\",\n                      \"attempted to bind a deleted sampler\");\n    return;\n  }\n\n  if (unit >= sampler_units_.size()) {\n    SynthesizeGLError(GL_INVALID_VALUE, \"bindSampler\",\n                      \"texture unit out of range\");\n    return;\n  }\n\n  sampler_units_[unit] = sampler;\n\n  ContextGL()->BindSampler(unit, ObjectOrZero(sampler));\n}\n",
    "response": "\n{\n  \"LINE1\": \"                                              WebGLSampler* sampler) {\",\n  \"LINE2\": \"  if (isContextLost())\",\n  \"LINE3\": \"    return;\",\n  \"LINE4\": \"  if (deleted) {\",\n  \"LINE5\": \"    SynthesizeGLError(GL_INVALID_OPERATION, \\\"bindSampler\\\",\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (isContextLost())\",\n  \"vulnerability2\": \"    return;\",\n  \"vulnerability3\": \"  if (deleted) {\",\n  \"vulnerability4\": \"    SynthesizeGLError(GL_INVALID_OPERATION, \\\"bindSampler\\\",\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (isContextLost())\",\n  \"vulnerability2\": \"    return;\",\n  \"vulnerability3\": \"  if (deleted) {\",\n  \"vulnerability4",
    "truly_vulnerable_lines": "  if (isContextLost())\n    return;\n"
  },
  {
    "code": " void WebGL2RenderingContextBase::bindVertexArray(\n     WebGLVertexArrayObject* vertex_array) {\n  if (isContextLost())\n     return;\n  if (vertex_array &&\n      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {\n     SynthesizeGLError(GL_INVALID_OPERATION, \"bindVertexArray\",\n                      \"invalid vertexArray\");\n     return;\n   }\n \n  if (vertex_array && !vertex_array->IsDefaultObject() &&\n      vertex_array->Object()) {\n    ContextGL()->BindVertexArrayOES(ObjectOrZero(vertex_array));\n\n    vertex_array->SetHasEverBeenBound();\n    SetBoundVertexArrayObject(vertex_array);\n  } else {\n    ContextGL()->BindVertexArrayOES(0);\n    SetBoundVertexArrayObject(nullptr);\n  }\n}\n",
    "response": "\n{\n  \"LINE1\": \"  if (isContextLost())\",\n  \"LINE2\": \"  if (vertex_array &&\",\n  \"LINE3\": \"      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {\",\n  \"LINE4\": \"     SynthesizeGLError(GL_INVALID_OPERATION, \\\"bindVertexArray\\\",\",\n  \"LINE5\": \"                      \\\"invalid vertexArray\\\");\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (isContextLost())\",\n  \"vulnerability2\": \"  if (vertex_array &&\",\n  \"vulnerability3\": \"      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {\",\n  \"vulnerability4\": \"     SynthesizeGLError(GL_INVALID_OPERATION, \\\"bindVertexArray\\\",\",\n  \"vulnerability5\": \"                      \\\"invalid vertexArray\\\");\"\n}{\"",
    "truly_vulnerable_lines": "  if (isContextLost())\n  if (vertex_array &&\n      (vertex_array->IsDeleted() || !vertex_array->Validate(nullptr, this))) {\n                      \"invalid vertexArray\");\n"
  },
  {
    "code": " void WebGL2RenderingContextBase::deleteVertexArray(\n     WebGLVertexArrayObject* vertex_array) {\n  if (isContextLost() || !vertex_array)\n     return;\n \n   if (!vertex_array->IsDefaultObject() &&\n      vertex_array == bound_vertex_array_object_)\n    SetBoundVertexArrayObject(nullptr);\n\n  vertex_array->DeleteObject(ContextGL());\n}\n",
    "response": "\n{\n  \"LINE1\": \"  if (isContextLost() || !vertex_array)\",\n  \"LINE2\": \"      vertex_array == bound_vertex_array_object_\",\n  \"LINE3\": \"    SetBoundVertexArrayObject(nullptr);\",\n  \"LINE4\": \"  vertex_array->DeleteObject(ContextGL());\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (isContextLost() || !vertex_array)\",\n\"vulnerability2\": \"      vertex_array == bound_vertex_array_object_\",\n\"vulnerability3\": \"    SetBoundVertexArrayObject(nullptr);\",\n\"vulnerability4\": \"  vertex_array->DeleteObject(ContextGL());\",\n\"vulnerability5\": \"}\"{\"vulnerabilities\": [\"vulnerability1\": \"  if (isContextLost() || !vertex_array)\",\n\"vulnerability2\": \"      vertex_array == bound_vertex_array_object_\",\n\"vulnerability",
    "truly_vulnerable_lines": "  if (isContextLost() || !vertex_array)\n"
  },
  {
    "code": "void WebGL2RenderingContextBase::framebufferTextureLayer(GLenum target,\n                                                         GLenum attachment,\n                                                         WebGLTexture* texture,\n                                                         GLint level,\n                                                         GLint layer) {\n  if (isContextLost() || !ValidateFramebufferFuncParameters(\n                              \"framebufferTextureLayer\", target, attachment))\n     return;\n   if (texture && !texture->Validate(ContextGroup(), this)) {\n    SynthesizeGLError(GL_INVALID_VALUE, \"framebufferTextureLayer\",\n                      \"no texture or texture not from this context\");\n     return;\n   }\n   GLenum textarget = texture ? texture->GetTarget() : 0;\n  if (texture) {\n    if (textarget != GL_TEXTURE_3D && textarget != GL_TEXTURE_2D_ARRAY) {\n      SynthesizeGLError(GL_INVALID_OPERATION, \"framebufferTextureLayer\",\n                        \"invalid texture type\");\n      return;\n    }\n    if (!ValidateTexFuncLayer(\"framebufferTextureLayer\", textarget, layer))\n      return;\n    if (!ValidateTexFuncLevel(\"framebufferTextureLayer\", textarget, level))\n      return;\n  }\n\n  WebGLFramebuffer* framebuffer_binding = GetFramebufferBinding(target);\n  if (!framebuffer_binding || !framebuffer_binding->Object()) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"framebufferTextureLayer\",\n                      \"no framebuffer bound\");\n    return;\n  }\n  if (framebuffer_binding && framebuffer_binding->Opaque()) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"framebufferTextureLayer\",\n                      \"opaque framebuffer bound\");\n    return;\n  }\n  framebuffer_binding->SetAttachmentForBoundFramebuffer(\n      target, attachment, textarget, texture, level, layer);\n  ApplyStencilTest();\n}\n",
    "response": "\n{\n  \"LINE1\": \"    SynthesizeGLError(GL_INVALID_VALUE, \\\"framebufferTextureLayer\\\",\",\n  \"LINE2\": \"                          \\\"no texture or texture not from this context\\\");\",\n  \"LINE3\": \"  if (texture) {\",\n  \"LINE4\": \"    if (textarget != GL_TEXTURE_3D && textarget != GL_TEXTURE_2D_ARRAY) {\",\n  \"LINE5\": \"      SynthesizeGLError(GL_INVALID_OPERATION, \\\"framebufferTextureLayer\\\",\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n                                                         GLenum target,\n                                                         GLenum attachment,\n                                                         WebGLTexture* texture,\n                                                         GLint level,\n                                                         GLint layer) {\n  if (isContextLost() || !ValidateFramebufferFuncParameters(\n                              \"framebufferTextureLayer\", target, attachment))\n                                                         GLenum target,\n                                                         GLenum attachment,\n                                                         WebGLTexture* texture,\n                                                         GLint level",
    "truly_vulnerable_lines": "    SynthesizeGLError(GL_INVALID_VALUE, \"framebufferTextureLayer\",\n                      \"no texture or texture not from this context\");\n"
  },
  {
    "code": " GLboolean WebGL2RenderingContextBase::isTransformFeedback(\n     WebGLTransformFeedback* feedback) {\n  if (isContextLost() || !feedback)\n     return 0;\n \n   if (!feedback->HasEverBeenBound())\n    return 0;\n\n  return ContextGL()->IsTransformFeedback(feedback->Object());\n}\n",
    "response": "\n{\n  \"LINE1\": \"  if (isContextLost() || !feedback)\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  if (!feedback->HasEverBeenBound())\",\n  \"LINE4\": \"    return 0;\",\n  \"LINE5\": \"  return ContextGL()->IsTransformFeedback(feedback->Object());\"\n}{\"vulnerabilities\": [\"The function is known to contain vulnerabilities. Your task is to locate the specific lines of code that cause these vulnerabilities. You should provide no more than 5 possible vulnerable lines of code. Answer only in the following JSON format:\",\n  \"LINE1\": \"code line 1\",\n  \"LINE2\": \"code line 2\",\n  \"LINE3\": \"code line 3\",\n  \"LINE4\": \"code line 4\",\n  \"LINE5\": \"code line 5\"\n}\n{\"vulnerabilities\": [\"The function is known to contain vulnerabilities. Your task is to locate the specific lines of code that cause these vulnerabilities. You should provide no more than ",
    "truly_vulnerable_lines": "  if (isContextLost() || !feedback)\n"
  },
  {
    "code": " GLboolean WebGL2RenderingContextBase::isVertexArray(\n     WebGLVertexArrayObject* vertex_array) {\n  if (isContextLost() || !vertex_array)\n     return 0;\n \n   if (!vertex_array->HasEverBeenBound())\n    return 0;\n\n  return ContextGL()->IsVertexArrayOES(vertex_array->Object());\n}\n",
    "response": "\n{\n  \"LINE1\": \"  if (isContextLost() || !vertex_array)\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  if (!vertex_array->HasEverBeenBound())\",\n  \"LINE4\": \"    return 0;\",\n  \"LINE5\": \"  return ContextGL()->IsVertexArrayOES(vertex_array->Object());\"\n}{\"vulnerabilities\": [\"The function is known to contain vulnerabilities. Your task is to locate the specific lines of code that cause these vulnerabilities. You should provide no more than 5 possible vulnerable lines of code. Answer only in the following JSON format:\",\n  \"LINE1\": \"code line 1\",\n  \"LINE2\": \"code line 2\",\n  \"LINE3\": \"code line 3\",\n  \"LINE4\": \"code line 4\",\n  \"LINE5\": \"code line 5\"\n}\n{\"vulnerabilities\": [\"The function is known to contain vulnerabilities. Your task is to locate the specific lines of code that cause these vulnerabilities. You should provide",
    "truly_vulnerable_lines": "  if (isContextLost() || !vertex_array)\n"
  },
  {
    "code": " GLboolean WebGLRenderingContextBase::isBuffer(WebGLBuffer* buffer) {\n  if (!buffer || isContextLost())\n     return 0;\n \n   if (!buffer->HasEverBeenBound())\n    return 0;\n  if (buffer->IsDeleted())\n    return 0;\n\n  return ContextGL()->IsBuffer(buffer->Object());\n}\n",
    "response": "\n{\n  \"LINE1\": \"  if (!buffer || isContextLost())\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  if (buffer->IsDeleted())\",\n  \"LINE4\": \"    return 0;\",\n  \"LINE5\": \"  return ContextGL()->IsBuffer(buffer->Object());\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!buffer || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \"  if (buffer->IsDeleted())\",\n  \"vulnerability4\": \"    return 0;\",\n  \"vulnerability5\": \"  return ContextGL()->IsBuffer(buffer->Object());\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!buffer || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \"  if (buffer->IsDe",
    "truly_vulnerable_lines": "  if (!buffer || isContextLost())\n"
  },
  {
    "code": " GLboolean WebGLRenderingContextBase::isFramebuffer(\n     WebGLFramebuffer* framebuffer) {\n  if (!framebuffer || isContextLost())\n     return 0;\n \n   if (!framebuffer->HasEverBeenBound())\n    return 0;\n  if (framebuffer->IsDeleted())\n    return 0;\n\n  return ContextGL()->IsFramebuffer(framebuffer->Object());\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!framebuffer || isContextLost())\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  if (!framebuffer->HasEverBeenBound())\",\n  \"LINE4\": \"    return 0;\",\n  \"LINE5\": \"  if (framebuffer->IsDeleted())\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!framebuffer || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \"  if (!framebuffer->HasEverBeenBound())\",\n  \"vulnerability4\": \"    return 0;\",\n  \"vulnerability5\": \"  if (framebuffer->IsDeleted())\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!framebuffer || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \"  if (!framebuffer",
    "truly_vulnerable_lines": "  if (!framebuffer || isContextLost())\n"
  },
  {
    "code": " GLboolean WebGLRenderingContextBase::isProgram(WebGLProgram* program) {\n  if (!program || isContextLost())\n     return 0;\n \n   return ContextGL()->IsProgram(program->Object());\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!program || isContextLost())\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  return ContextGL()->IsProgram(program->Object());\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"}\"\n}{\"data\": {\"LINE1\": \"  if (!program || isContextLost())\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  return ContextGL()->IsProgram(program->Object());\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"}\"\n}{\"data\": {\n  \"LINE1\": \"  if (!program || isContextLost())\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  return ContextGL()->IsProgram(program->Object());\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"}\"\n}{\"data\": {\n  \"LINE1\": \"GLboolean WebGLRenderingContextBase::isProgram(WebGLProgram*",
    "truly_vulnerable_lines": "  if (!program || isContextLost())\n"
  },
  {
    "code": " GLboolean WebGLRenderingContextBase::isRenderbuffer(\n     WebGLRenderbuffer* renderbuffer) {\n  if (!renderbuffer || isContextLost())\n     return 0;\n \n   if (!renderbuffer->HasEverBeenBound())\n    return 0;\n  if (renderbuffer->IsDeleted())\n    return 0;\n\n  return ContextGL()->IsRenderbuffer(renderbuffer->Object());\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!renderbuffer || isContextLost())\",\n  \"LINE2\": \"  if (!renderbuffer->HasEverBeenBound())\",\n  \"LINE3\": \"    return 0;\",\n  \"LINE4\": \"  if (renderbuffer->IsDeleted())\",\n  \"LINE5\": \"    return 0;\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!renderbuffer || isContextLost())\",\n  \"vulnerability2\": \"  if (!renderbuffer->HasEverBeenBound())\",\n  \"vulnerability3\": \"    return 0;\",\n  \"vulnerability4\": \"  if (renderbuffer->IsDeleted())\",\n  \"vulnerability5\": \"    return 0;\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!renderbuffer || isContextLost())\",\n  \"vulnerability2\": \"  if (!renderbuffer->HasEverBeenBound())\",\n  \"vulnerability3\":",
    "truly_vulnerable_lines": "  if (!renderbuffer || isContextLost())\n"
  },
  {
    "code": " GLboolean WebGLRenderingContextBase::isShader(WebGLShader* shader) {\n  if (!shader || isContextLost())\n     return 0;\n \n   return ContextGL()->IsShader(shader->Object());\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (!shader || isContextLost())\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  return ContextGL()->IsShader(shader->Object());\",\n  \"LINE4\": \"}\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!shader || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \"  return ContextGL()->IsShader(shader->Object());\",\n  \"vulnerability4\": \"}\",\n  \"vulnerability5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!shader || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \"  return ContextGL()->IsShader(shader->Object());\",\n  \"vulnerability4\": \"}\",",
    "truly_vulnerable_lines": "  if (!shader || isContextLost())\n"
  },
  {
    "code": " GLboolean WebGLRenderingContextBase::isTexture(WebGLTexture* texture) {\n  if (!texture || isContextLost())\n     return 0;\n \n   if (!texture->HasEverBeenBound())\n    return 0;\n  if (texture->IsDeleted())\n    return 0;\n\n  return ContextGL()->IsTexture(texture->Object());\n}\n",
    "response": "\n{\n  \"LINE1\": \"  if (!texture || isContextLost())\",\n  \"LINE2\": \"     return 0;\",\n  \"LINE3\": \"  if (texture->IsDeleted())\",\n  \"LINE4\": \"    return 0;\",\n  \"LINE5\": \"  return ContextGL()->IsTexture(texture->Object());\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!texture || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \"  if (texture->IsDeleted())\",\n  \"vulnerability4\": \"    return 0;\",\n  \"vulnerability5\": \"  return ContextGL()->IsTexture(texture->Object());\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (!texture || isContextLost())\",\n  \"vulnerability2\": \"     return 0;\",\n  \"vulnerability3\": \" ",
    "truly_vulnerable_lines": "  if (!texture || isContextLost())\n"
  },
  {
    "code": " void GCInfoTable::EnsureGCInfoIndex(const GCInfo* gc_info,\n                                     size_t* gc_info_index_slot) {\n   DCHECK(gc_info);\n   DCHECK(gc_info_index_slot);\n  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());\n  MutexLocker locker(mutex);\n \n   if (*gc_info_index_slot)\n     return;\n \n  int index = ++gc_info_index_;\n   size_t gc_info_index = static_cast<size_t>(index);\n   CHECK(gc_info_index < GCInfoTable::kMaxIndex);\n  if (gc_info_index >= gc_info_table_size_)\n     Resize();\n \n  g_gc_info_table[gc_info_index] = gc_info;\n   ReleaseStore(reinterpret_cast<int*>(gc_info_index_slot), index);\n }\n",
    "response": "\n{\n  \"LINE1\": \"DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());\",\n  \"LINE2\": \"MutexLocker locker(mutex);\",\n  \"LINE3\": \"int index = ++gc_info_index_;\",\n  \"LINE4\": \"   size_t gc_info_index = static_cast<size_t>(index);\",\n  \"LINE5\": \"   CHECK(gc_info_index < GCInfoTable::kMaxIndex);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n                                     size_t* gc_info_index_slot) {\n  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());\n  MutexLocker locker(mutex);\n  int index = ++gc_info_index_;\n  size_t gc_info_index = static_cast<size_t>(index);\n  CHECK(gc_info_index < GCInfoTable::kMaxIndex);\n",
    "truly_vulnerable_lines": "  DEFINE_THREAD_SAFE_STATIC_LOCAL(Mutex, mutex, ());\n  MutexLocker locker(mutex);\n  int index = ++gc_info_index_;\n  if (gc_info_index >= gc_info_table_size_)\n  g_gc_info_table[gc_info_index] = gc_info;\n"
  },
  {
    "code": "void GCInfoTable::Init() {\n  CHECK(!g_gc_info_table);\n   Resize();\n }\n",
    "response": "\n{\n  \"LINE1\": \"   Resize();\",\n  \"LINE2\": \"}\",\n  \"LINE3\": \"void GCInfoTable::Init() {\",\n  \"LINE4\": \"  CHECK(!g_gc_info_table);\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8\", \"vulnerability9\", \"vulnerability10\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8",
    "truly_vulnerable_lines": "  CHECK(!g_gc_info_table);\n"
  },
  {
    "code": " void GCInfoTable::Resize() {\n  static const int kGcInfoZapValue = 0x33;\n  const size_t kInitialSize = 512;\n  size_t new_size =\n      gc_info_table_size_ ? 2 * gc_info_table_size_ : kInitialSize;\n  DCHECK(new_size < GCInfoTable::kMaxIndex);\n  g_gc_info_table =\n      reinterpret_cast<GCInfo const**>(WTF::Partitions::FastRealloc(\n          g_gc_info_table, new_size * sizeof(GCInfo), \"GCInfo\"));\n  DCHECK(g_gc_info_table);\n  memset(reinterpret_cast<uint8_t*>(g_gc_info_table) +\n             gc_info_table_size_ * sizeof(GCInfo),\n         kGcInfoZapValue, (new_size - gc_info_table_size_) * sizeof(GCInfo));\n  gc_info_table_size_ = new_size;\n }\n",
    "response": "\n{\n  \"LINE1\": \"  static const int kGcInfoZapValue = 0x33;\",\n  \"LINE2\": \"  const size_t kInitialSize = 512;\",\n  \"LINE3\": \"  size_t new_size =\",\n  \"LINE4\": \"      gc_info_table_size_ ? 2 * gc_info_table_size_ : kInitialSize;\",\n  \"LINE5\": \"  DCHECK(new_size < GCInfoTable::kMaxIndex);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability",
    "truly_vulnerable_lines": "  static const int kGcInfoZapValue = 0x33;\n  const size_t kInitialSize = 512;\n  size_t new_size =\n      gc_info_table_size_ ? 2 * gc_info_table_size_ : kInitialSize;\n  DCHECK(new_size < GCInfoTable::kMaxIndex);\n  g_gc_info_table =\n      reinterpret_cast<GCInfo const**>(WTF::Partitions::FastRealloc(\n          g_gc_info_table, new_size * sizeof(GCInfo), \"GCInfo\"));\n  DCHECK(g_gc_info_table);\n  memset(reinterpret_cast<uint8_t*>(g_gc_info_table) +\n             gc_info_table_size_ * sizeof(GCInfo),\n         kGcInfoZapValue, (new_size - gc_info_table_size_) * sizeof(GCInfo));\n  gc_info_table_size_ = new_size;\n"
  },
  {
    "code": "void ThreadHeap::WriteBarrier(void* value) {\n  DCHECK(thread_state_->IsIncrementalMarking());\n  DCHECK(value);\n  DCHECK_NE(value, reinterpret_cast<void*>(-1));\n\n  BasePage* const page = PageFromObject(value);\n  HeapObjectHeader* const header =\n      page->IsLargeObjectPage()\n          ? static_cast<LargeObjectPage*>(page)->GetHeapObjectHeader()\n          : static_cast<NormalPage*>(page)->FindHeaderFromAddress(\n                reinterpret_cast<Address>(const_cast<void*>(value)));\n  if (header->IsMarked())\n    return;\n\n   header->Mark();\n   marking_worklist_->Push(\n       WorklistTaskId::MainThread,\n      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n }\n",
    "response": "\n{\n  \"LINE1\": \"      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n}{\"vulnerabilities\": [\"vulnerability1\": \"      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n\"]}{\"vulnerabilities\": [\"vulnerability1\": \"      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n\"]}{\"vulnerabilities\": [\"vulnerability1\": \"      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n\"]}{\"vulnerabilities\": [\"vulnerability1\": \"      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n\"]}{\"vulnerabilities\": [\"vulnerability1\": \"      {header->Payload(),",
    "truly_vulnerable_lines": "      {header->Payload(), ThreadHeap::GcInfo(header->GcInfoIndex())->trace_});\n"
  },
  {
    "code": " void HeapObjectHeader::Finalize(Address object, size_t object_size) {\n   HeapAllocHooks::FreeHookIfEnabled(object);\n  const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());\n   if (gc_info->HasFinalizer())\n     gc_info->finalize_(object);\n \n  ASAN_RETIRE_CONTAINER_ANNOTATION(object, object_size);\n}\n",
    "response": "\n{\n  \"LINE1\": \"const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());\",\n  \"LINE2\": \"   if (gc_info->HasFinalizer())\",\n  \"LINE3\": \"     gc_info->finalize_(object);\",\n  \"LINE4\": \"  ASAN_RETIRE_CONTAINER_ANNOTATION(object, object_size);\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\"]}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\", \"vulnerability 6\", \"vulnerability 7\", \"vulnerability 8\", \"vulnerability 9\", \"vulnerability 10\", \"vulner",
    "truly_vulnerable_lines": "  const GCInfo* gc_info = ThreadHeap::GcInfo(GcInfoIndex());\n"
  },
  {
    "code": "  void ProcessBackingStore(HeapObjectHeader* header) {\n     EXPECT_TRUE(header->IsValid());\n     EXPECT_TRUE(header->IsMarked());\n     header->Unmark();\n    ThreadHeap::GcInfo(header->GcInfoIndex())->trace_(this, header->Payload());\n   }\n",
    "response": "\n{\n  \"LINE1\": \"    ThreadHeap::GcInfo(header->GcInfoIndex())->trace_(this, header->Payload());\",\n  \"LINE2\": \"  }\",\n  \"LINE3\": \"  void ProcessBackingStore(HeapObjectHeader* header) {\",\n  \"LINE4\": \"     EXPECT_TRUE(header->IsValid());\",\n  \"LINE5\": \"     EXPECT_TRUE(header->IsMarked());\"\n}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8\", \"vulnerability9\", \"vulnerability10\", \"vulnerability11\", \"vulnerability12\", \"vulner",
    "truly_vulnerable_lines": "    ThreadHeap::GcInfo(header->GcInfoIndex())->trace_(this, header->Payload());\n"
  },
  {
    "code": " void MarkingVisitor::ConservativelyMarkHeader(HeapObjectHeader* header) {\n  const GCInfo* gc_info = ThreadHeap::GcInfo(header->GcInfoIndex());\n   if (gc_info->HasVTable() && !VTableInitialized(header->Payload())) {\n    MarkHeaderNoTracing(header);\n#if DCHECK_IS_ON()\n    DCHECK(IsUninitializedMemory(header->Payload(), header->PayloadSize()));\n#endif\n  } else {\n    MarkHeader(header, gc_info->trace_);\n  }\n}\n",
    "response": "\n{\n  \"LINE1\": \"    MarkHeaderNoTracing(header);\",\n  \"LINE2\": \"#if DCHECK_IS_ON()\",\n  \"LINE3\": \"    DCHECK(IsUninitializedMemory(header->Payload(), header->PayloadSize()));\",\n  \"LINE4\": \"  } else {\",\n  \"LINE5\": \"    MarkHeader(header, gc_info->trace_);\"\n}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\"]}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\", \"vulnerability 6\", \"vulnerability 7\", \"vulnerability 8\", \"vulnerability 9\", \"vulnerability 10\"]}{\"vulnerabilities\": [\"vulnerability 1",
    "truly_vulnerable_lines": "  const GCInfo* gc_info = ThreadHeap::GcInfo(header->GcInfoIndex());\n"
  },
  {
    "code": "void ProcessHeap::Init() {\n  total_allocated_space_ = 0;\n   total_allocated_object_size_ = 0;\n   total_marked_object_size_ = 0;\n \n  GCInfoTable::Init();\n   base::SamplingHeapProfiler::SetHooksInstallCallback([]() {\n     HeapAllocHooks::SetAllocationHook(&BlinkGCAllocHook);\n     HeapAllocHooks::SetFreeHook(&BlinkGCFreeHook);\n  });\n}\n",
    "response": "\n{\n  \"LINE1\": \"  GCInfoTable::Init();\",\n  \"LINE2\": \"   base::SamplingHeapProfiler::SetHooksInstallCallback([]() {\",\n  \"LINE3\": \"     HeapAllocHooks::SetAllocationHook(&BlinkGCAllocHook);\",\n  \"LINE4\": \"     HeapAllocHooks::SetFreeHook(&BlinkGCFreeHook);\",\n  \"LINE5\": \"  });\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulnerability line 9\", \"vulnerability",
    "truly_vulnerable_lines": "  GCInfoTable::Init();\n"
  },
  {
    "code": "bool Performance::PassesTimingAllowCheck(\n    const ResourceResponse& response,\n     const SecurityOrigin& initiator_security_origin,\n     const AtomicString& original_timing_allow_origin,\n     ExecutionContext* context) {\n   scoped_refptr<const SecurityOrigin> resource_origin =\n      SecurityOrigin::Create(response.Url());\n   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\n     return true;\n \n  const AtomicString& timing_allow_origin_string =\n      original_timing_allow_origin.IsEmpty()\n          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\n          : original_timing_allow_origin;\n  if (timing_allow_origin_string.IsEmpty() ||\n      EqualIgnoringASCIICase(timing_allow_origin_string, \"null\"))\n    return false;\n\n  if (timing_allow_origin_string == \"*\") {\n    UseCounter::Count(context, WebFeature::kStarInTimingAllowOrigin);\n    return true;\n  }\n\n  const String& security_origin = initiator_security_origin.ToString();\n  Vector<String> timing_allow_origins;\n  timing_allow_origin_string.GetString().Split(',', timing_allow_origins);\n  if (timing_allow_origins.size() > 1) {\n    UseCounter::Count(context, WebFeature::kMultipleOriginsInTimingAllowOrigin);\n  } else if (timing_allow_origins.size() == 1 &&\n             timing_allow_origin_string != \"*\") {\n    UseCounter::Count(context, WebFeature::kSingleOriginInTimingAllowOrigin);\n  }\n  for (const String& allow_origin : timing_allow_origins) {\n    const String allow_origin_stripped = allow_origin.StripWhiteSpace();\n    if (allow_origin_stripped == security_origin ||\n        allow_origin_stripped == \"*\") {\n      return true;\n    }\n  }\n\n  return false;\n}\n",
    "response": "\n{\n  \"LINE1\": \"      SecurityOrigin::Create(response.Url());\",\n  \"LINE2\": \"   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\",\n  \"LINE3\": \"  const AtomicString& timing_allow_origin_string =\",\n  \"LINE4\": \"      original_timing_allow_origin.IsEmpty()\",\n  \"LINE5\": \"          ? response.HttpHeaderField(HTTPNames::Timing_Allow_Origin)\"\n}{\"vulnerabilities\": [\"The function contains a vulnerability in the following lines of code:\",\n  \"   scoped_refptr<const SecurityOrigin> resource_origin =\",\n  \"      SecurityOrigin::Create(response.Url());\",\n  \"   if (resource_origin->IsSameSchemeHostPort(&initiator_security_origin))\",\n  \"  const AtomicString& timing_allow_origin_string =\",\n  \"      original_timing_allow_origin.IsEmpty()\",\n  \"          ? response.HttpHeaderField(HTTPNames::Timing_",
    "truly_vulnerable_lines": "      SecurityOrigin::Create(response.Url());\n"
  },
  {
    "code": "MediaElementAudioSourceHandler::MediaElementAudioSourceHandler(\n    AudioNode& node,\n    HTMLMediaElement& media_element)\n    : AudioHandler(kNodeTypeMediaElementAudioSource,\n                   node,\n                   node.context()->sampleRate()),\n       media_element_(media_element),\n       source_number_of_channels_(0),\n       source_sample_rate_(0),\n      passes_current_src_cors_access_check_(\n          PassesCurrentSrcCORSAccessCheck(media_element.currentSrc())),\n      maybe_print_cors_message_(!passes_current_src_cors_access_check_),\n      current_src_string_(media_element.currentSrc().GetString()) {\n   DCHECK(IsMainThread());\n  AddOutput(2);\n\n  if (Context()->GetExecutionContext()) {\n    task_runner_ = Context()->GetExecutionContext()->GetTaskRunner(\n        TaskType::kMediaElementEvent);\n  }\n\n  Initialize();\n}\n",
    "response": "\n{\n  \"LINE1\": \"      passes_current_src_cors_access_check_(\n          PassesCurrentSrcCORSAccessCheck(media_element.currentSrc())),\n      maybe_print_cors_message_(!passes_current_src_cors_access_check_),\n      current_src_string_(media_element.currentSrc().GetString()) {\n}{\"vulnerabilities\": [\"vulnerability1\": \"      passes_current_src_cors_access_check_(\n          PassesCurrentSrcCORSAccessCheck(media_element.currentSrc())),\n      maybe_print_cors_message_(!passes_current_src_cors_access_check_),\n      current_src_string_(media_element.currentSrc().GetString()) {\n  AddOutput(2);\n\n  if (Context()->GetExecutionContext()) {\n    task_runner_ = Context()->GetExecutionContext()->GetTaskRunner(\n        TaskType::kMediaElementEvent);\n  }\n\n  Initialize();\n}{\"",
    "truly_vulnerable_lines": "      passes_current_src_cors_access_check_(\n          PassesCurrentSrcCORSAccessCheck(media_element.currentSrc())),\n      maybe_print_cors_message_(!passes_current_src_cors_access_check_),\n      current_src_string_(media_element.currentSrc().GetString()) {\n"
  },
  {
    "code": "void MediaElementAudioSourceHandler::OnCurrentSrcChanged(\n    const KURL& current_src) {\n  DCHECK(IsMainThread());\n  Locker<MediaElementAudioSourceHandler> locker(*this);\n \n  passes_current_src_cors_access_check_ =\n      PassesCurrentSrcCORSAccessCheck(current_src);\n \n  maybe_print_cors_message_ = !passes_current_src_cors_access_check_;\n  current_src_string_ = current_src.GetString();\n}\n",
    "response": "\n{\n  \"LINE1\": \"  passes_current_src_cors_access_check_ =\",\n  \"LINE2\": \"      PassesCurrentSrcCORSAccessCheck(current_src);\",\n  \"LINE3\": \"  maybe_print_cors_message_ = !passes_current_src_cors_access_check_;\",\n  \"LINE4\": \"  current_src_string_ = current_src.GetString();\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  passes_current_src_cors_access_check_ =\",\n  \"vulnerability2\": \"      PassesCurrentSrcCORSAccessCheck(current_src);\",\n  \"vulnerability3\": \"  maybe_print_cors_message_ = !passes_current_src_cors_access_check_;\",\n  \"vulnerability4\": \"  current_src_string_ = current_src.GetString();\",\n  \"vulnerability5\": \"}\"\n}{\"vul",
    "truly_vulnerable_lines": "    const KURL& current_src) {\n  DCHECK(IsMainThread());\n  Locker<MediaElementAudioSourceHandler> locker(*this);\n  passes_current_src_cors_access_check_ =\n      PassesCurrentSrcCORSAccessCheck(current_src);\n  maybe_print_cors_message_ = !passes_current_src_cors_access_check_;\n  current_src_string_ = current_src.GetString();\n}\n"
  },
  {
    "code": "void MediaElementAudioSourceNode::OnCurrentSrcChanged(const KURL& current_src) {\n  GetMediaElementAudioSourceHandler().OnCurrentSrcChanged(current_src);\n}\n",
    "response": "\n{\n  \"LINE1\": \"void MediaElementAudioSourceNode::OnCurrentSrcChanged(const KURL& current_src) {\",\n  \"LINE2\": \"  GetMediaElementAudioSourceHandler().OnCurrentSrcChanged(current_src);\",\n  \"LINE3\": \"}\",\n  \"LINE4\": \"\",\n  \"LINE5\": \"\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  if (m_mediaSource) {\",\n  \"vulnerability2\": \"    m_mediaSource->setMediaSource(this);\",\n  \"vulnerability3\": \"  } else {\",\n  \"vulnerability4\": \"    m_mediaElement->setMediaSource(this);\",\n  \"vulnerability5\": \"  }\",\n  \"vulnerability6\": \"  m_mediaElement->setMediaSource(this);\",\n  \"vulnerability7\": \"  m_mediaElement->setMediaSource(this);\",\n  \"vulnerability8\": \"  m_mediaElement->setMediaSource(this);",
    "truly_vulnerable_lines": "  GetMediaElementAudioSourceHandler().OnCurrentSrcChanged(current_src);\n}\n"
  },
  {
    "code": "bool MediaElementAudioSourceHandler::PassesCORSAccessCheck() {\n  DCHECK(MediaElement());\n  return (MediaElement()->GetWebMediaPlayer() &&\n          MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n         passes_current_src_cors_access_check_;\n}\n",
    "response": "\n{\n  \"LINE1\": \"          MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\",\n  \"LINE2\": \"         passes_current_src_cors_access_check_;\",\n  \"LINE3\": \"}\",\n  \"LINE4\": \"bool MediaElementAudioSourceHandler::PassesCORSAccessCheck() {\",\n  \"LINE5\": \"  DCHECK(MediaElement());\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"          MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\",\n  \"vulnerability2\": \"         passes_current_src_cors_access_check_;\",\n  \"vulnerability3\": \"}\",\n  \"vulnerability4\": \"bool MediaElementAudioSourceHandler::PassesCORSAccessCheck() {\",\n  \"vulnerability5\": \"  DCHECK(MediaElement());\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  DCHECK(MediaElement());\",\n  \"vulnerability2\":",
    "truly_vulnerable_lines": "  DCHECK(MediaElement());\n  return (MediaElement()->GetWebMediaPlayer() &&\n          MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) ||\n         passes_current_src_cors_access_check_;\n}\n"
  },
  {
    "code": "bool MediaElementAudioSourceHandler::PassesCurrentSrcCORSAccessCheck(\n    const KURL& current_src) {\n  DCHECK(IsMainThread());\n  return Context()->GetSecurityOrigin() &&\n         Context()->GetSecurityOrigin()->CanRequest(current_src);\n }\n",
    "response": "\n{\n  \"LINE1\": \"         Context()->GetSecurityOrigin()->CanRequest(current_src);\",\n  \"LINE2\": \"      return Context()->GetSecurityOrigin() &&\",\n  \"LINE3\": \"      return Context()->GetSecurityOrigin()->CanRequest(current_src);\",\n  \"LINE4\": \"      return Context()->GetSecurityOrigin() &&\",\n  \"LINE5\": \"      return Context()->GetSecurityOrigin()->CanRequest(current_src);\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"      return Context()->GetSecurityOrigin() &&\",\n  \"vulnerability2\": \"      return Context()->GetSecurityOrigin()->CanRequest(current_src);\",\n  \"vulnerability3\": \"      return Context()->GetSecurityOrigin() &&\",\n  \"vulnerability4\": \"      return Context()->GetSecurityOrigin()->CanRequest(current_src);\",\n  \"vulnerability5\": \"      return Context()->GetSecurityOrigin() &&\"\n}{\"vulnerabilities\": [\"vulnerability1\":",
    "truly_vulnerable_lines": "    const KURL& current_src) {\n  DCHECK(IsMainThread());\n  return Context()->GetSecurityOrigin() &&\n         Context()->GetSecurityOrigin()->CanRequest(current_src);\n"
  },
  {
    "code": "void MediaElementAudioSourceHandler::Process(size_t number_of_frames) {\n  AudioBus* output_bus = Output(0).Bus();\n\n  MutexTryLocker try_locker(process_lock_);\n  if (try_locker.Locked()) {\n    if (!MediaElement() || !source_sample_rate_) {\n      output_bus->Zero();\n      return;\n    }\n\n    if (source_number_of_channels_ != output_bus->NumberOfChannels()) {\n      output_bus->Zero();\n      return;\n    }\n\n    AudioSourceProvider& provider = MediaElement()->GetAudioSourceProvider();\n    if (multi_channel_resampler_.get()) {\n      DCHECK_NE(source_sample_rate_, Context()->sampleRate());\n      multi_channel_resampler_->Process(&provider, output_bus,\n                                        number_of_frames);\n    } else {\n      DCHECK_EQ(source_sample_rate_, Context()->sampleRate());\n       provider.ProvideInput(output_bus, number_of_frames);\n     }\n    if (!PassesCORSAccessCheck()) {\n      if (maybe_print_cors_message_) {\n        maybe_print_cors_message_ = false;\n        PostCrossThreadTask(\n            *task_runner_, FROM_HERE,\n            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,\n                            WrapRefCounted(this), current_src_string_));\n      }\n       output_bus->Zero();\n     }\n   } else {\n    output_bus->Zero();\n  }\n}\n",
    "response": "\n{\n  \"LINE1\": \"    if (!PassesCORSAccessCheck()) {\",\n  \"LINE2\": \"      if (maybe_print_cors_message_) {\",\n  \"LINE3\": \"        maybe_print_cors_message_ = false;\",\n  \"LINE4\": \"        PostCrossThreadTask(\",\n  \"LINE5\": \"            *task_runner_, FROM_HERE,\",\n  \"LINE6\": \"            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,\"\n}{\"vulnerabilities\": [\"output_bus->Zero();\"]}{\"vulnerabilities\": [\"    if (!PassesCORSAccessCheck()) {\",\n  \"      if (maybe_print_cors_message_) {\",\n  \"        maybe_print_cors_message_ = false;\",\n  \"        PostCrossThreadTask(\",\n  \"            *task_runner_, FROM_HERE,\",\n  \"            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,\"\n}{\"vulnerabilities\": [\"output_bus->Zero();",
    "truly_vulnerable_lines": "    if (!PassesCORSAccessCheck()) {\n      if (maybe_print_cors_message_) {\n        maybe_print_cors_message_ = false;\n        PostCrossThreadTask(\n            *task_runner_, FROM_HERE,\n            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,\n                            WrapRefCounted(this), current_src_string_));\n      }\n"
  },
  {
    "code": "ExtensionInstallDialogView::ExtensionInstallDialogView(\n    Profile* profile,\n    content::PageNavigator* navigator,\n    const ExtensionInstallPrompt::DoneCallback& done_callback,\n    std::unique_ptr<ExtensionInstallPrompt::Prompt> prompt)\n    : profile_(profile),\n      navigator_(navigator),\n      done_callback_(done_callback),\n       prompt_(std::move(prompt)),\n       container_(NULL),\n       scroll_view_(NULL),\n      handled_result_(false) {\n   InitView();\n }\n",
    "response": "\n{\n  \"LINE1\": \"handled_result_ = false;\",\n  \"LINE2\": \"      handled_result_(false) {\",\n  \"LINE3\": \"   InitView();\",\n  \"LINE4\": \"handled_result_ = false;\",\n  \"LINE5\": \"      handled_result_(false) {\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"      handled_result_(false) {\",\n  \"LINE1\": \"handled_result_ = false;\",\n  \"LINE2\": \"      handled_result_(false) {\",\n  \"LINE3\": \"   InitView();\",\n  \"LINE4\": \"handled_result_ = false;\",\n  \"LINE5\": \"      handled_result_(false) {\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"      handled_result_(false) {\",\n  \"LINE1\": \"handled_result_ = false;\",\n  \"LINE2\": \"      handled_result_(false) {\",\n  \"LINE3\": \"   InitView();\",\n  \"LINE4\":",
    "truly_vulnerable_lines": "      handled_result_(false) {\n"
  },
  {
    "code": " ExtensionFunction::ResponseAction BluetoothSocketSendFunction::Run() {\n   DCHECK_CURRENTLY_ON(work_thread_id());\n \n  auto params = bluetooth_socket::Send::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n \n  io_buffer_size_ = params->data.size();\n  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n \n  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n   if (!socket)\n     return RespondNow(Error(kSocketNotFoundError));\n \n  socket->Send(io_buffer_,\n               io_buffer_size_,\n               base::Bind(&BluetoothSocketSendFunction::OnSuccess, this),\n               base::Bind(&BluetoothSocketSendFunction::OnError, this));\n  return did_respond() ? AlreadyResponded() : RespondLater();\n}\n",
    "response": "\n{\n  \"LINE1\": \"  auto params = bluetooth_socket::Send::Params::Create(*args_);\",\n  \"LINE2\": \"  EXTENSION_FUNCTION_VALIDATE(params.get());\",\n  \"LINE3\": \"  io_buffer_size_ = params->data.size();\",\n  \"LINE4\": \"  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\",\n  \"LINE5\": \"  BluetoothApiSocket* socket = GetSocket(params->socket_id);\"\n}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\"]}{\"vulnerabilities\": [\"vulnerability1\", \"vulnerability2\", \"vulnerability3\", \"vulnerability4\", \"vulnerability5\", \"vulnerability6\", \"vulnerability7\", \"vulnerability8\", \"vulnerability9\", \"vulnerability10\", \"vulner",
    "truly_vulnerable_lines": "  auto params = bluetooth_socket::Send::Params::Create(*args_);\n  EXTENSION_FUNCTION_VALIDATE(params.get());\n  io_buffer_size_ = params->data.size();\n  io_buffer_ = new net::WrappedIOBuffer(params->data.data());\n  BluetoothApiSocket* socket = GetSocket(params->socket_id);\n"
  },
  {
    "code": " void HTMLMediaElement::ChangeNetworkStateFromLoadingToIdle() {\n   progress_event_timer_.Stop();\n \n  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress())\n    ScheduleEvent(EventTypeNames::progress);\n  ScheduleEvent(EventTypeNames::suspend);\n  SetNetworkState(kNetworkIdle);\n }\n",
    "response": "\n{\n  \"LINE1\": \"  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress())\",\n  \"LINE2\": \"    ScheduleEvent(EventTypeNames::progress);\",\n  \"LINE3\": \"  ScheduleEvent(EventTypeNames::suspend);\",\n  \"LINE4\": \"  SetNetworkState(kNetworkIdle);\",\n  \"LINE5\": \"}\"\n}{\"vulnerabilities\": [\"The function contains a vulnerability related to the use of the \\\"GetWebMediaPlayer()\\\" function. This function is called multiple times in the code, which could lead to potential issues if it is not properly initialized or if it does not behave as expected.\", \n\"The function contains a vulnerability related to the use of the \\\"GetWebMediaPlayer()\\\" function. This function is called multiple times in the code, which could lead to potential issues if it is not properly initialized or if it does not behave as expected.\"]}{\"vulnerabilities\": [\"The function contains a vulnerability related to the use of the \\\"GetWebMediaPlayer()\\\" function. This function is called multiple times in the code, which could lead",
    "truly_vulnerable_lines": "  if (GetWebMediaPlayer() && GetWebMediaPlayer()->DidLoadingProgress())\n    ScheduleEvent(EventTypeNames::progress);\n  ScheduleEvent(EventTypeNames::suspend);\n  SetNetworkState(kNetworkIdle);\n"
  },
  {
    "code": " void HTMLMediaElement::MediaLoadingFailed(WebMediaPlayer::NetworkState error,\n                                          const String& message) {\n   BLINK_MEDIA_LOG << \"MediaLoadingFailed(\" << (void*)this << \", \"\n                  << static_cast<int>(error) << \", message='\" << message\n                   << \"')\";\n \n   StopPeriodicTimers();\n \n  if (ready_state_ < kHaveMetadata &&\n      load_state_ == kLoadingFromSourceElement) {\n    if (current_source_node_) {\n      current_source_node_->ScheduleErrorEvent();\n    } else {\n      BLINK_MEDIA_LOG << \"mediaLoadingFailed(\" << (void*)this\n                      << \") - error event not sent, <source> was removed\";\n    }\n\n\n    ForgetResourceSpecificTracks();\n\n    if (HavePotentialSourceChild()) {\n      BLINK_MEDIA_LOG << \"mediaLoadingFailed(\" << (void*)this\n                      << \") - scheduling next <source>\";\n      ScheduleNextSourceChild();\n    } else {\n      BLINK_MEDIA_LOG << \"mediaLoadingFailed(\" << (void*)this\n                      << \") - no more <source> elements, waiting\";\n      WaitForSourceChange();\n    }\n\n    return;\n  }\n\n  if (error == WebMediaPlayer::kNetworkStateNetworkError &&\n      ready_state_ >= kHaveMetadata) {\n    MediaEngineError(MediaError::Create(MediaError::kMediaErrNetwork, message));\n  } else if (error == WebMediaPlayer::kNetworkStateDecodeError) {\n    MediaEngineError(MediaError::Create(MediaError::kMediaErrDecode, message));\n  } else if ((error == WebMediaPlayer::kNetworkStateFormatError ||\n              error == WebMediaPlayer::kNetworkStateNetworkError) &&\n             load_state_ == kLoadingFromSrcAttr) {\n    if (message.IsEmpty()) {\n      NoneSupported(BuildElementErrorMessage(\n          error == WebMediaPlayer::kNetworkStateFormatError ? \"Format error\"\n                                                            : \"Network error\"));\n    } else {\n      NoneSupported(message);\n    }\n  }\n\n  UpdateDisplayState();\n}\n",
    "response": "\n{\n  \"LINE1\": \"code line 1\",\n  \"LINE2\": \"code line 2\",\n  \"LINE3\": \"code line 3\",\n  \"LINE4\": \"code line 4\",\n  \"LINE5\": \"code line 5\"\n}\n{\"LINE1\": \"                                          const String& message) {\",\n  \"LINE2\": \"                   << static_cast<int>(error) << \", message='\" << message\n}{\"LINE1\": \"  if (ready_state_ < kHaveMetadata &&\",\n  \"LINE2\": \"      load_state_ == kLoadingFromSourceElement) {\",\n  \"LINE3\": \"    if (current_source_node_) {\",\n  \"LINE4\": \"      current_source_node_->ScheduleErrorEvent();\",\n  \"LINE5\": \"    } else {\"\n}{\"LINE1\": \"  if (ready_state_ < kHaveMetadata &&\",\n  \"LINE2\": \"      load_state_ == kLoadingFromSourceElement) {\",\n  \"LINE3\": \"    if (current_source_node_) {",
    "truly_vulnerable_lines": "                                          const String& message) {\n                  << static_cast<int>(error) << \", message='\" << message\n"
  },
  {
    "code": "void HTMLMediaElement::NoneSupported(const String& message) {\n  BLINK_MEDIA_LOG << \"NoneSupported(\" << (void*)this << \", message='\" << message\n                  << \"')\";\n \n   StopPeriodicTimers();\n   load_state_ = kWaitingForSource;\n   current_source_node_ = nullptr;\n \n \n  error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);\n\n  ForgetResourceSpecificTracks();\n\n  SetNetworkState(kNetworkNoSource);\n\n  UpdateDisplayState();\n\n  ScheduleEvent(EventTypeNames::error);\n\n  ScheduleRejectPlayPromises(kNotSupportedError);\n\n  CloseMediaSource();\n\n  SetShouldDelayLoadEvent(false);\n\n  if (GetLayoutObject())\n    GetLayoutObject()->UpdateFromElement();\n}\n",
    "response": "\n{\n  \"LINE1\": \"  error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);\",\n  \"LINE2\": \"  ForgetResourceSpecificTracks();\",\n  \"LINE3\": \"  SetNetworkState(kNetworkNoSource);\",\n  \"LINE4\": \"  UpdateDisplayState();\",\n  \"LINE5\": \"  ScheduleEvent(EventTypeNames::error);\"\n}{\"vulnerabilities\": [\"vulnerability1\": \"  error_ = MediaError::Create(MediaError::kMediaErrSrcNotSupported, message);\",\n  \"vulnerability2\": \"  ForgetResourceSpecificTracks();\",\n  \"vulnerability3\": \"  SetNetworkState(kNetworkNoSource);\",\n  \"vulnerability4\": \"  UpdateDisplayState();\",\n  \"vulnerability5\": \"  ScheduleEvent(EventTypeNames::error);\"]}{\"vulnerabilities\": [\"vulnerability1\": \"  error_ = MediaError::Create(MediaError::kMediaErrSrcNot",
    "truly_vulnerable_lines": "  BLINK_MEDIA_LOG << \"NoneSupported(\" << (void*)this << \", message='\" << message\n                  << \"')\";\n"
  },
  {
    "code": "gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {\n  if (ShouldApplyDisplayCentering())\n    return CalculatePaddingForDisplayCentering();\n \n   const int icons_size = shelf_view_->GetSizeOfAppIcons(\n       shelf_view_->number_of_visible_apps(), false);\n  gfx::Insets padding_insets(\n      /*vertical= */ 0,\n      /*horizontal= */ ShelfConfig::Get()->app_icon_group_margin());\n \n   const int available_size_for_app_icons =\n       (GetShelf()->IsHorizontalAlignment() ? width() : height()) -\n      2 * ShelfConfig::Get()->app_icon_group_margin();\n\n  int gap =\n      layout_strategy_ == kNotShowArrowButtons\n           ? available_size_for_app_icons - icons_size  // shelf centering\n           : CalculateOverflowPadding(available_size_for_app_icons);  // overflow\n \n  padding_insets.set_left(padding_insets.left() + gap / 2);\n  padding_insets.set_right(padding_insets.right() +\n                           (gap % 2 ? gap / 2 + 1 : gap / 2));\n \n   return padding_insets;\n }\n",
    "response": "\n{\n  \"LINE1\": \"gfx::Insets ScrollableShelfView::CalculateEdgePadding() const {\",\n  \"LINE2\": \"  if (ShouldApplyDisplayCentering())\",\n  \"LINE3\": \"    return CalculatePaddingForDisplayCentering();\",\n  \"LINE4\": \"  gfx::Insets padding_insets(\",\n  \"LINE5\": \"  padding_insets.set_left(padding_insets.left() + gap / 2);\",\n  \"LINE6\": \"  padding_insets.set_right(padding_insets.right() +\",\n  \"LINE7\": \"                           (gap % 2 ? gap / 2 + 1 : gap / 2));\",\n  \"LINE8\": \"  return padding_insets;\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  gfx::Insets padding_insets(\n      /*vertical= */ 0,\n      /*horizontal= */ ShelfConfig::Get()->app_icon_group_margin());\n  gfx::Insets padding_insets",
    "truly_vulnerable_lines": "  gfx::Insets padding_insets(\n      /*vertical= */ 0,\n      /*horizontal= */ ShelfConfig::Get()->app_icon_group_margin());\n  padding_insets.set_left(padding_insets.left() + gap / 2);\n  padding_insets.set_right(padding_insets.right() +\n                           (gap % 2 ? gap / 2 + 1 : gap / 2));\n"
  },
  {
    "code": "gfx::Insets ScrollableShelfView::CalculatePaddingForDisplayCentering() const {\n  const int icons_size = shelf_view_->GetSizeOfAppIcons(\n      shelf_view_->number_of_visible_apps(), false);\n  const gfx::Rect display_bounds =\n      screen_util::GetDisplayBoundsWithShelf(GetWidget()->GetNativeWindow());\n  const int display_size_primary = GetShelf()->PrimaryAxisValue(\n      display_bounds.width(), display_bounds.height());\n  const int gap = (display_size_primary - icons_size) / 2;\n \n   const gfx::Rect screen_bounds = GetBoundsInScreen();\n  const int left_padding = gap - GetShelf()->PrimaryAxisValue(\n                                     screen_bounds.x() - display_bounds.x(),\n                                     screen_bounds.y() - display_bounds.y());\n  const int right_padding =\n       gap - GetShelf()->PrimaryAxisValue(\n                 display_bounds.right() - screen_bounds.right(),\n                 display_bounds.bottom() - screen_bounds.bottom());\n \n  return gfx::Insets(0, left_padding, 0, right_padding);\n }\n",
    "response": "\n{\n  \"LINE1\": \"  const int icons_size = shelf_view_->GetSizeOfAppIcons(\",\n  \"LINE2\": \"      shelf_view_->number_of_visible_apps(), false);\",\n  \"LINE3\": \"  const gfx::Rect display_bounds =\",\n  \"LINE4\": \"      screen_util::GetDisplayBoundsWithShelf(GetWidget()->GetNativeWindow());\",\n  \"LINE5\": \"  const int display_size_primary = GetShelf()->PrimaryAxisValue(\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"v",
    "truly_vulnerable_lines": "  const int left_padding = gap - GetShelf()->PrimaryAxisValue(\n                                     screen_bounds.x() - display_bounds.x(),\n                                     screen_bounds.y() - display_bounds.y());\n  const int right_padding =\n  return gfx::Insets(0, left_padding, 0, right_padding);\n"
  },
  {
    "code": " float ScrollableShelfView::CalculatePageScrollingOffset(bool forward) const {\n  float offset = space_for_icons_ - kArrowButtonGroupWidth -\n                  ShelfConfig::Get()->button_size() - GetAppIconEndPadding();\n   if (layout_strategy_ == kShowRightArrowButton)\n     offset -= (kArrowButtonGroupWidth - GetAppIconEndPadding());\n  DCHECK_GT(offset, 0);\n\n  if (!forward)\n    offset = -offset;\n\n  return offset;\n}\n",
    "response": "\n{\n  \"LINE1\": \"  float offset = space_for_icons_ - kArrowButtonGroupWidth -\",\n  \"LINE2\": \"                  ShelfConfig::Get()->button_size() - GetAppIconEndPadding();\",\n  \"LINE3\": \"   if (layout_strategy_ == kShowRightArrowButton)\",\n  \"LINE4\": \"     offset -= (kArrowButtonGroupWidth - GetAppIconEndPadding());\",\n  \"LINE5\": \"  DCHECK_GT(offset, 0);\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  \"vulnerability line 2\",\n  \"vulnerability line 3\",\n  \"vulnerability line 4\",\n  \"vulnerability line 5\"]}{\"vulnerabilities\": [\"  float offset = space_for_icons_ - kArrowButtonGroupWidth -\",\n  \"                  ShelfConfig::Get()->button_size() - GetAppIconEndPadding();\",\n  \"  DCHECK_GT(offset, 0);\",",
    "truly_vulnerable_lines": "  float offset = space_for_icons_ - kArrowButtonGroupWidth -\n"
  },
  {
    "code": "int ScrollableShelfView::CalculateScrollUpperBound() const {\n  if (layout_strategy_ == kNotShowArrowButtons)\n     return 0;\n \n  int available_length = space_for_icons_ - 2 * GetAppIconEndPadding();\n \n   const gfx::Size shelf_preferred_size(\n      shelf_container_view_->GetPreferredSize());\n  const int preferred_length =\n      (GetShelf()->IsHorizontalAlignment() ? shelf_preferred_size.width()\n                                           : shelf_preferred_size.height());\n\n  return std::max(0, preferred_length - available_length);\n}\n",
    "response": "\n{\n  \"LINE1\": \"  int available_length = space_for_icons_ - 2 * GetAppIconEndPadding();\",\n  \"LINE2\": \"      shelf_container_view_->GetPreferredSize());\",\n  \"LINE3\": \"  const int preferred_length =\",\n  \"LINE4\": \"      (GetShelf()->IsHorizontalAlignment() ? shelf_preferred_size.width()\",\n  \"LINE5\": \"                                           : shelf_preferred_size.height());\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n  if (layout_strategy_ == kNotShowArrowButtons)\n      return 0;\n  int available_length = space_for_icons_ - 2 * GetAppIconEndPadding();\n  const gfx::Size shelf_preferred_size(\n      shelf_container_view_->GetPreferredSize());\n  const int preferred_length =\n      (GetShelf()->IsHorizontalAlignment() ? shelf_preferred_size.width()\n                                           : shelf_pref",
    "truly_vulnerable_lines": "  int available_length = space_for_icons_ - 2 * GetAppIconEndPadding();\n"
  },
  {
    "code": "   explicit RemoveDownloadsTester(TestingProfile* testing_profile)\n      : download_manager_(new content::MockDownloadManager()),\n        chrome_download_manager_delegate_(testing_profile) {\n     content::BrowserContext::SetDownloadManagerForTesting(\n         testing_profile, base::WrapUnique(download_manager_));\n    EXPECT_EQ(download_manager_,\n              content::BrowserContext::GetDownloadManager(testing_profile));\n    EXPECT_CALL(*download_manager_, GetDelegate())\n        .WillOnce(Return(&chrome_download_manager_delegate_));\n     EXPECT_CALL(*download_manager_, Shutdown());\n   }\n",
    "response": "\n{\n  \"LINE1\": \"     content::BrowserContext::SetDownloadManagerForTesting(\",\n  \"LINE2\": \"         testing_profile, base::WrapUnique(download_manager_));\",\n  \"LINE3\": \"    EXPECT_EQ(download_manager_,\",\n  \"LINE4\": \"              content::BrowserContext::GetDownloadManager(testing_profile));\",\n  \"LINE5\": \"    EXPECT_CALL(*download_manager_, Shutdown());\"\n}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\"]}{\"vulnerabilities\": [\"vulnerability 1\", \"vulnerability 2\", \"vulnerability 3\", \"vulnerability 4\", \"vulnerability 5\", \"vulnerability 6\", \"vulnerability 7\", \"vulnerability 8\", \"vulnerability 9\", \"vulnerability 10\", \"vulnerability 11\", \"",
    "truly_vulnerable_lines": "      : download_manager_(new content::MockDownloadManager()),\n        chrome_download_manager_delegate_(testing_profile) {\n    EXPECT_EQ(download_manager_,\n              content::BrowserContext::GetDownloadManager(testing_profile));\n    EXPECT_CALL(*download_manager_, GetDelegate())\n        .WillOnce(Return(&chrome_download_manager_delegate_));\n"
  },
  {
    "code": " DownloadCoreServiceImpl::GetDownloadManagerDelegate() {\n   DownloadManager* manager = BrowserContext::GetDownloadManager(profile_);\n  if (download_manager_created_) {\n    DCHECK(static_cast<DownloadManagerDelegate*>(manager_delegate_.get()) ==\n           manager->GetDelegate());\n     return manager_delegate_.get();\n  }\n   download_manager_created_ = true;\n \n  if (!manager_delegate_.get())\n    manager_delegate_.reset(new ChromeDownloadManagerDelegate(profile_));\n\n  manager_delegate_->SetDownloadManager(manager);\n\n#if BUILDFLAG(ENABLE_EXTENSIONS)\n  extension_event_router_.reset(\n      new extensions::ExtensionDownloadsEventRouter(profile_, manager));\n#endif\n\n  if (!profile_->IsOffTheRecord()) {\n    history::HistoryService* history = HistoryServiceFactory::GetForProfile(\n        profile_, ServiceAccessType::EXPLICIT_ACCESS);\n    history->GetNextDownloadId(\n        manager_delegate_->GetDownloadIdReceiverCallback());\n    download_history_.reset(new DownloadHistory(\n        manager, std::unique_ptr<DownloadHistory::HistoryAdapter>(\n                     new DownloadHistory::HistoryAdapter(history))));\n  }\n\n  download_ui_.reset(new DownloadUIController(\n      manager, std::unique_ptr<DownloadUIController::Delegate>()));\n \n   g_browser_process->download_status_updater()->AddManager(manager);\n \n   return manager_delegate_.get();\n}\n",
    "response": "\n{\n  \"LINE1\": \"  if (download_manager_created_) {\",\n  \"LINE2\": \"    DCHECK(static_cast<DownloadManagerDelegate*>(manager_delegate_.get()) ==\",\n  \"LINE3\": \"           manager->GetDelegate());\",\n  \"LINE4\": \"     return manager_delegate_.get();\",\n  \"LINE5\": \"  }\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulnerability line 9\", \"vulnerability line 10\", \"vulnerability line ",
    "truly_vulnerable_lines": "  if (download_manager_created_) {\n    DCHECK(static_cast<DownloadManagerDelegate*>(manager_delegate_.get()) ==\n           manager->GetDelegate());\n  }\n"
  },
  {
    "code": "void DownloadCoreServiceImpl::SetDownloadManagerDelegateForTesting(\n    std::unique_ptr<ChromeDownloadManagerDelegate> new_delegate) {\n   manager_delegate_.swap(new_delegate);\n   DownloadManager* dm = BrowserContext::GetDownloadManager(profile_);\n   dm->SetDelegate(manager_delegate_.get());\n  manager_delegate_->SetDownloadManager(dm);\n   if (new_delegate)\n     new_delegate->Shutdown();\n }\n",
    "response": "\n{\n  \"LINE1\": \"   manager_delegate_.swap(new_delegate);\",\n  \"LINE2\": \"   DownloadManager* dm = BrowserContext::GetDownloadManager(profile_);\",\n  \"LINE3\": \"   dm->SetDelegate(manager_delegate_.get());\",\n  \"LINE4\": \"  manager_delegate_->SetDownloadManager(dm);\",\n  \"LINE5\": \"   if (new_delegate)\"\n}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\"]}{\"vulnerabilities\": [\"vulnerability line 1\", \"vulnerability line 2\", \"vulnerability line 3\", \"vulnerability line 4\", \"vulnerability line 5\", \"vulnerability line 6\", \"vulnerability line 7\", \"vulnerability line 8\", \"vulnerability line 9",
    "truly_vulnerable_lines": "  manager_delegate_->SetDownloadManager(dm);\n"
  },
  {
    "code": "void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(\n    uint32_t download_id,\n    const content::DownloadTargetCallback& callback,\n    const base::FilePath& suggested_path) {\n  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);\n \n   callback.Run(suggested_path,\n                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,\n               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\n                suggested_path.AddExtension(FILE_PATH_LITERAL(\".crdownload\")),\n                content::DOWNLOAD_INTERRUPT_REASON_NONE);\n }\n",
    "response": "\n{\n  \"LINE1\": \"               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\",\n  \"LINE2\": \"                suggested_path.AddExtension(FILE_PATH_LITERAL(\".crdownload\")),\",\n  \"LINE3\": \"                content::DOWNLOAD_INTERRUPT_REASON_NONE);\",\n  \"LINE4\": \"               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\",\n  \"LINE5\": \"                suggested_path.AddExtension(FILE_PATH_LITERAL(\".crdownload\")),\"\n}{\"vulnerabilities\": [\"vulnerability line 1\",\n                content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,\n               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\n                suggested_path.AddExtension(FILE_PATH_LITERAL(\".crdownload\")),\n                content::DOWNLOAD_INTERRUPT_REASON_NONE);\n]{\"vulnerabilities\": [\"",
    "truly_vulnerable_lines": "               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,\n"
  },
  {
    "code": "void HTMLStyleElement::DidNotifySubtreeInsertionsToDocument() {\n  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\n      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n}\n",
    "response": "\n{\n  \"LINE1\": \"void HTMLStyleElement::DidNotifySubtreeInsertionsToDocument() {\",\n  \"LINE2\": \"  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\",\n  \"LINE3\": \"      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n}\n}{\"vulnerabilities\": [\"vulnerability1\": \"    if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\",\n  \"vulnerability2\": \"        kErrorOccurredLoadingSubresource);\",\n  \"vulnerability3\": \"    NotifyLoadedSheetAndAllCriticalSubresources(\",\n  \"vulnerability4\": \"    if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\",\n  \"vulnerability5\": \"        kErrorOccurredLoadingSubresource);\",\n  \"vulnerability6\": \"    NotifyLoadedSheetAndAllCriticalSubresources(\",",
    "truly_vulnerable_lines": "  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\n      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n}\n"
  },
  {
    "code": " Node::InsertionNotificationRequest HTMLStyleElement::InsertedInto(\n     ContainerNode* insertion_point) {\n   HTMLElement::InsertedInto(insertion_point);\n  return kInsertionShouldCallDidNotifySubtreeInsertions;\n }\n",
    "response": "\n{\n  \"LINE1\": \"  return kInsertionShouldCallDidNotifySubtreeInsertions;\",\n  \"LINE2\": \"   HTMLElement::InsertedInto(insertion_point);\",\n  \"LINE3\": \"     ContainerNode* insertion_point) {\",\n  \"LINE4\": \"   HTMLElement::InsertedInto(insertion_point);\",\n  \"LINE5\": \" return kInsertionShouldCallDidNotifySubtreeInsertions;\"\n}{\"vulnerabilities\": [\"The function contains a vulnerability related to the use of the \\\"return\\\" keyword in an unreachable code block.\", \"The function contains a vulnerability related to the use of the \\\"return\\\" keyword in an unreachable code block.\"]}{\"vulnerabilities\": [\"The function contains a vulnerability related to the use of the \\\"return\\\" keyword in an unreachable code block.\"]}{\"vulnerabilities\": [\"The function contains a vulnerability related to the use of the \\\"return\\\" keyword in an unreachable code block.\", \"The function contains a vulnerability related to the use of the \\\"return",
    "truly_vulnerable_lines": "  return kInsertionShouldCallDidNotifySubtreeInsertions;\n"
  },
  {
    "code": "void SVGStyleElement::DidNotifySubtreeInsertionsToDocument() {\n  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\n      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n }\n",
    "response": "\n{\n  \"LINE1\": \"void SVGStyleElement::DidNotifySubtreeInsertionsToDocument() {\",\n  \"LINE2\": \"  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\",\n  \"LINE3\": \"      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n}{\"vulnerabilities\": [\"vulnerability1\": \"    if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\",\n  \"vulnerability2\": \"        kErrorOccurredLoadingSubresource);\",\n  \"vulnerability3\": \"    if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\",\n  \"vulnerability4\": \"        kErrorOccurredLoadingSubresource);\",\n  \"vulnerability5\": \"    if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\",\n  \"vulnerability6\": \"        kErrorOccurredLoadingSubresource);\",\n",
    "truly_vulnerable_lines": "  if (StyleElement::ProcessStyleSheet(GetDocument(), *this) ==\n      StyleElement::kProcessingFatalError)\n    NotifyLoadedSheetAndAllCriticalSubresources(\n        kErrorOccurredLoadingSubresource);\n"
  },
  {
    "code": " Node::InsertionNotificationRequest SVGStyleElement::InsertedInto(\n     ContainerNode* insertion_point) {\n   SVGElement::InsertedInto(insertion_point);\n  return kInsertionShouldCallDidNotifySubtreeInsertions;\n}\n",
    "response": "\n{\n  \"LINE1\": \"   SVGElement::InsertedInto(insertion_point);\",\n  \"LINE2\": \" return kInsertionShouldCallDidNotifySubtreeInsertions;\",\n  \"LINE3\": \"}\",\n  \"LINE4\": \"  ContainerNode* insertion_point) {\",\n  \"LINE5\": \"     ContainerNode* insertion_point) {\"\n}{\"vulnerabilities\": [\"The function contains a vulnerability related to the use of the \\\"strcpy\\\" function. The vulnerability is caused by the use of the \\\"strcpy\\\" function without checking the size of the destination buffer. This can lead to buffer overflows if the source string is larger than the destination buffer.\", \n\"The function contains a vulnerability related to the use of the \\\"strcpy\\\" function. The vulnerability is caused by the use of the \\\"strcpy\\\" function without checking the size of the destination buffer. This can lead to buffer overflows if the source string is larger than the destination buffer.\"]}{\"vulnerabilities\": [\"The function contains a vulnerability related to the use of the \\\"strc",
    "truly_vulnerable_lines": "  return kInsertionShouldCallDidNotifySubtreeInsertions;\n}\n"
  }
]